
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Dynamics Models for Decision Making &#8212; Practical Reinforcement Learning: From Algorithms to Applications</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"bm": ["{\\boldsymbol #1}", 1]}, "processEscapes": true}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ssm';</script>
    <script src="_static/iframe-modal.js?v=f72a1242"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Programs as Models" href="simulation.html" />
    <link rel="prev" title="Why Build a Model? For Whom?" href="modeling.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Practical Reinforcement Learning: From Algorithms to Applications</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Why This Book?
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modeling</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Why Build a Model? For Whom?</a></li>

<li class="toctree-l1 current active"><a class="current reference internal" href="#">Dynamics Models for Decision Making</a></li>




<li class="toctree-l1"><a class="reference internal" href="simulation.html">Programs as Models</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Trajectory Optimization</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ocp.html">Discrete-Time Trajectory Optimization</a></li>


<li class="toctree-l1"><a class="reference internal" href="cocp.html">Trajectory Optimization in Continuous Time</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Trajectories to Policies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mpc.html">Model Predictive Control</a></li>




<li class="toctree-l1"><a class="reference internal" href="dp.html">Dynamic Programming</a></li>



</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Approximate Dynamic Programming</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="regmdp.html">Smooth Bellman Optimality Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="projdp.html">Projection Methods for Functional Equations</a></li>
<li class="toctree-l1"><a class="reference internal" href="simadp.html">Simulation-Based Approximate Dynamic Programming</a></li>



<li class="toctree-l1"><a class="reference internal" href="cadp.html">Policy Parametrization Methods</a></li>







</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix_examples.html">Example COCPs</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_ivps.html">Solving Initial Value Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_nlp.html">Nonlinear Programming</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/edit/main/ssm.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/issues/new?title=Issue%20on%20page%20%2Fssm.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/ssm.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Dynamics Models for Decision Making</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Dynamics Models for Decision Making</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-statespace-perspective">The State‑Space Perspective</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discrete-versus-continuous-time">Discrete versus continuous time</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-deterministic-dynamics-hvac-control">Examples of Deterministic Dynamics: HVAC Control</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-do-we-control">What Do We Control?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-this-model">Why This Model?</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#from-deterministic-to-stochastic">From Deterministic to Stochastic</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-plus-noise">Function plus Noise</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#transition-kernel">Transition Kernel</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#continuous-time-analogue">Continuous-Time Analogue</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-managing-a-quebec-hydroelectric-reservoir">Example: Managing a Québec Hydroelectric Reservoir</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-observability">Partial Observability</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#observation-kernel-view">Observation Kernel View</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example-stabilizing-a-telescope-s-vision-with-adaptive-optics">Example – Stabilizing a Telescope’s Vision with Adaptive Optics</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="dynamics-models-for-decision-making">
<h1>Dynamics Models for Decision Making<a class="headerlink" href="#dynamics-models-for-decision-making" title="Link to this heading">#</a></h1>
<p>The kind of model we need here is a <strong>dynamics model</strong>. It does not just describe correlations. It tells us how a system <strong>evolves in time</strong> and, most importantly for control, how that evolution <strong>responds to inputs</strong> we choose.</p>
<p>A dynamics model earns its keep by answering counterfactuals of the form: <em>given an initial condition and an input schedule, what trajectory should I expect?</em> That ability to roll a trajectory forward under different candidate inputs is the backbone of planning, policy evaluation, and learning from interaction.</p>
<p>At this level, we can think of the model as a trajectory generator:</p>
<div class="math notranslate nohighlight">
\[
(\mathbf{x}_0,\ \{\mathbf{u}_t\},\ \{\mathbf{d}_t\}) \ \longmapsto\ \{\mathbf{x}_t,\ \mathbf{y}_t\}_{t=0:T},
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> are <strong>controls</strong> we set, <span class="math notranslate nohighlight">\(\mathbf{d}_t\)</span> are <strong>exogenous drivers</strong> we do not control (weather, inflow, demand), <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> are internal <strong>system variables</strong>, and <span class="math notranslate nohighlight">\(\mathbf{y}_t\)</span> are <strong>observations</strong>. The split between <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> is practical: it separates what we can act on from what we must accommodate.</p>
<p>Two design pressures shape such models:</p>
<ol class="arabic simple">
<li><p><strong>Responsiveness to inputs.</strong> The model must expose the levers that matter for the decision problem, even if everything underneath is approximate.</p></li>
<li><p><strong>Memory management.</strong> To simulate step by step, we need a compact summary of the past that is sufficient to predict the next step once an input arrives. That summary is what we will call the <strong>state</strong>.</p></li>
</ol>
<p>This brings us to a standard but powerful representation. Rather than carry the full history, we look for a variable <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> that captures “what matters so far” for predicting what comes next under a given input. With that variable in hand, the model advances in small increments and can be composed with estimators and controllers.</p>
<p>With this motivation in place, we can now introduce the formalism.</p>
</section>
<section id="the-statespace-perspective">
<h1>The State‑Space Perspective<a class="headerlink" href="#the-statespace-perspective" title="Link to this heading">#</a></h1>
<p>Most dynamics models, whether derived from physics or learned from data, can be cast into <strong>state‑space form</strong>. The state <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is the compact memory that summarizes the past for prediction and control. Inputs <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> perturb that state, exogenous drivers <span class="math notranslate nohighlight">\(\mathbf{d}\)</span> push it around, and outputs <span class="math notranslate nohighlight">\(\mathbf{y}\)</span> are what we can measure. The equations look the same whether time is treated in discrete steps or as a continuous variable.</p>
<section id="discrete-versus-continuous-time">
<h2>Discrete versus continuous time<a class="headerlink" href="#discrete-versus-continuous-time" title="Link to this heading">#</a></h2>
<p>How we represent time is dictated by how we sense and actuate: digital controllers sample and apply inputs in steps; the underlying physics evolve continuously.</p>
<p>Time can be represented in two complementary ways, depending on how the system is sensed, actuated, or modelled.</p>
<p>In <strong>discrete time</strong>, we treat time as an integer counter, <span class="math notranslate nohighlight">\(t = 0, 1, 2, \dots\)</span>, advancing in fixed steps. This matches how digital systems operate: sensors are sampled periodically, decisions are made at regular intervals, and most logged data takes this form.</p>
<p><strong>Continuous time</strong> treats time as a real variable, <span class="math notranslate nohighlight">\(t \in \mathbb{R}_{\ge 0}\)</span>. Many physical systems (mechanical, thermal, chemical) are most naturally expressed this way, using differential equations to describe how state changes.</p>
<p>The two views are interchangeable to some extent. A continuous-time model can be discretized through numerical integration, although this involves approximation. The degree of approximation depends on both the step size <span class="math notranslate nohighlight">\(\Delta t\)</span> and the integration algorithm used. Conversely, a discrete-time policy can be extended to continuous time by holding inputs constant over time intervals (a zeroth-order hold), or by interpolating between values.</p>
<p>In physical systems, this hybrid setup is almost always present. Control software sends discrete commands to hardware (say, the output of a PID controller) which are then processed by a DAC (digital-to-analog converter) and applied to the plant through analog signals. The hardware might hold a voltage constant, ramp it, or apply some analog shaping. On the sensing side, continuous signals are sampled via ADCs before reaching a digital controller. So in practice, even systems governed by continuous dynamics end up interfacing with the digital world through discrete-time approximations.</p>
<p>This raises a natural question: if everything eventually gets discretized anyway, why not just model everything in discrete time from the start?</p>
<p>In many cases, we do. But continuous-time models can still be useful, sometimes even necessary. They often make physical assumptions more explicit, connect more naturally to domain knowledge (e.g. differential equations in mechanics or thermodynamics), and expose invariances or conserved quantities that get obscured by time discretization. They also make it easier to model systems at different time scales, or to reason about how behaviors change as resolution increases. So while implementation happens in discrete time, thinking in continuous time can clarify the structure of the model.</p>
<p>Still, it’s helpful to see how both representations look in mathematical form. The state-space equations are nearly identical with different notations depending on how time is represented.</p>
<p><strong>Discrete time</strong></p>
<p>Having defined state as the summary we carry forward, a step of prediction applies the chosen input and advances the state.</p>
<p><span class="math notranslate nohighlight">\(\mathbf{x}_{t+1} = f_t(\mathbf{x}_t, \mathbf{u}_t), \qquad \mathbf{y}_t = h_t(\mathbf{x}_t, \mathbf{u}_t).\)</span></p>
<p><strong>Continuous time</strong></p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}}(t) = f(\mathbf{x}(t), \mathbf{u}(t)), \qquad \mathbf{y}(t) = h(\mathbf{x}(t), \mathbf{u}(t)).\)</span></p>
<p>The dot denotes a derivative with respect to real time; everything else (state, control, observation) remains the same.</p>
<p>When the functions <span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(h\)</span> are linear we obtain</p>
<p>Linearity is not a belief about the world, it is a modeling choice that trades fidelity for transparency and speed.</p>
<p><span class="math notranslate nohighlight">\(\dot{\mathbf{x}} = A\mathbf{x} + B\mathbf{u}, \qquad \mathbf{y} = C\mathbf{x} + D\mathbf{u}.\)</span></p>
<p>The matrices <span class="math notranslate nohighlight">\(A, B, C, D\)</span> may vary with <span class="math notranslate nohighlight">\(t\)</span>.  Readers with an ML background will recognise the parallel with recurrent neural networks: the state is the hidden vector, the control the input, and the output the read‑out layer.</p>
<p>Classical control often moves to the frequency domain, using Laplace and Z‑transforms to turn differential and difference equations into algebraic ones. That is invaluable for stability analysis of linear time‑invariant systems, but the time‑domain state‑space view is more flexible for learning and simulation, so we will keep our primary focus there.</p>
</section>
</section>
<section id="examples-of-deterministic-dynamics-hvac-control">
<h1>Examples of Deterministic Dynamics: HVAC Control<a class="headerlink" href="#examples-of-deterministic-dynamics-hvac-control" title="Link to this heading">#</a></h1>
<p>Imagine you’re in Montréal, in the middle of February. Outside it’s -20°C, but inside your home, a thermostat tries to keep things comfortable. When the indoor temperature drops below your setpoint, the heating system kicks in. That system (a small building, a heater, the surrounding weather) can be modeled mathematically.</p>
<p>We start with a very simple approximation: treat the entire room as a single “thermal mass,” like a big air-filled box that heats up or cools down depending on how much heat flows in or out.</p>
<p>Let <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> be the indoor air temperature at time <span class="math notranslate nohighlight">\(t\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> be the heating power supplied by the HVAC system. The outside air temperature, denoted <span class="math notranslate nohighlight">\(\mathbf{d}(t)\)</span>, affects the system too, acting as a known disturbance. Then the rate of change of indoor temperature is:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = -\frac{1}{RC}\mathbf{x}(t) + \frac{1}{RC}\mathbf{d}(t) + \frac{1}{C}\mathbf{u}(t).
\]</div>
<p>Here:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(R\)</span> is a thermal resistance: how well the walls insulate.</p></li>
<li><p><span class="math notranslate nohighlight">\(C\)</span> is a thermal capacitance: how much energy it takes to heat the air.</p></li>
</ul>
<p>This is a <strong>continuous-time linear system</strong>, and we can write it in standard state-space form:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = \mathbf{A}\mathbf{x}(t) + \mathbf{B}\mathbf{u}(t) + \mathbf{E}\mathbf{d}(t), \quad \mathbf{y}(t) = \mathbf{C}\mathbf{x}(t),
\]</div>
<p>with:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span>: indoor air temperature (the state)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span>: heater input (the control)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{d}(t)\)</span>: outdoor temperature (disturbance)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{y}(t)\)</span>: observed indoor temperature (output)</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{A} = -\frac{1}{RC}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{B} = \frac{1}{C}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{E} = \frac{1}{RC}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{C} = 1\)</span></p></li>
</ul>
<p>This model is simple, but too simplistic. It ignores the fact that the walls themselves store heat and release it slowly. This kind of delay is called <strong>thermal inertia</strong>: even if you turn the heater off, the walls might continue to warm the room for a while.</p>
<p>To capture this effect, we need to expand our state to include the wall temperature. We now model two coupled thermal masses: one for the air, and one for the wall. Heat can flow from the heater into the air, from the air into the wall, and from the wall out to the environment. This gives a more realistic description of how heat moves through a building envelope.</p>
<p>We write down an energy balance for each mass:</p>
<ul class="simple">
<li><p>For the air:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
C_{\text{air}} \frac{dT_{\text{in}}}{dt} = \frac{T_{\text{wall}} - T_{\text{in}}}{R_{\text{ia}}} + u(t),
\]</div>
<ul class="simple">
<li><p>For the wall:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
C_{\text{wall}} \frac{dT_{\text{wall}}}{dt} = \frac{T_{\text{out}} - T_{\text{wall}}}{R_{\text{wo}}} - \frac{T_{\text{wall}} - T_{\text{in}}}{R_{\text{ia}}}.
\]</div>
<p>Each term on the right-hand side corresponds to a flow of heat: the air gains heat from the wall and the heater, and the wall exchanges heat with both the air and the outside.</p>
<p>Now define the state vector:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{x}(t) = \begin{bmatrix} T_{\text{in}}(t) \\ T_{\text{wall}}(t) \end{bmatrix},
\quad \mathbf{u}(t) = u(t),
\quad \mathbf{d}(t) = T_{\text{out}}(t).
\end{split}\]</div>
<p>Dividing both equations by their respective capacitances and rearranging terms, we arrive at the coupled system:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = \mathbf{A}\mathbf{x}(t) + \mathbf{B}\mathbf{u}(t) + \mathbf{E}\mathbf{d}(t), \quad \mathbf{y}(t) = \mathbf{C}\mathbf{x}(t),
\]</div>
<p>with:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{A} = \begin{bmatrix}
-\frac{1}{R_{\text{ia}}C_{\text{air}}} &amp; \frac{1}{R_{\text{ia}}C_{\text{air}}} \\
\frac{1}{R_{\text{ia}}C_{\text{wall}}} &amp; -\left(\frac{1}{R_{\text{ia}}} + \frac{1}{R_{\text{wo}}}\right) \frac{1}{C_{\text{wall}}}
\end{bmatrix},
\quad
\mathbf{B} = \begin{bmatrix} \frac{1}{C_{\text{air}}} \\ 0 \end{bmatrix},
\quad
\mathbf{E} = \begin{bmatrix} 0 \\ \frac{1}{R_{\text{wo}}C_{\text{wall}}} \end{bmatrix},
\quad
\mathbf{C} = \begin{bmatrix} 1 &amp; 0 \end{bmatrix}.
\end{split}\]</div>
<p>Each entry in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> has a physical interpretation:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(A_{11}\)</span>: heat loss from the air to the wall</p></li>
<li><p><span class="math notranslate nohighlight">\(A_{12}\)</span>: heat gain by the air from the wall</p></li>
<li><p><span class="math notranslate nohighlight">\(A_{21}\)</span>: heat gain by the wall from the air</p></li>
<li><p><span class="math notranslate nohighlight">\(A_{22}\)</span>: net loss from the wall to both the air and the outside</p></li>
</ul>
<p>The temperatures are now dynamically coupled: any change in one affects the other. The wall acts as a buffer that absorbs and releases heat over time.</p>
<p>This is still a linear system, just with a 2D state. But already it behaves differently. The walls absorb and release heat, smoothing out fluctuations and slowing down the system’s response.</p>
<p>As we add more rooms, walls, or building elements, the system grows. Each new temperature adds a new state. The equations still have the same structure, and their sparsity follows the building layout. Nodes represent temperatures; edges encode how heat flows between them.</p>
<section id="what-do-we-control">
<h2>What Do We Control?<a class="headerlink" href="#what-do-we-control" title="Link to this heading">#</a></h2>
<p>This network of states is what we control. What we mean by “control input” <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> depends on both what we want to achieve and what we can implement in practice.</p>
<p>The most direct interpretation is to let <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> represent the actual heating power delivered to the system, measured in watts. This makes sense when modeling from physical principles or simulating a system with fine-grained actuation.</p>
<p>In many real buildings, however, thermostats don’t issue power commands. They activate a relay, turning the heater on or off based on whether the measured temperature crosses a setpoint. Some systems allow for modulated control—such as varying fan speed or partially opening a valve—but those details are often hidden behind firmware or closed controllers.</p>
<p>A common implementation involves a <strong>PID control loop</strong> that compares the measured temperature to a setpoint and adjusts the control signal accordingly. While the actual logic might be simple, the resulting behavior appears smoothed or delayed from the perspective of the building.</p>
<p>Depending on the abstraction level, we might:</p>
<ul class="simple">
<li><p>Treat <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> as continuous power input, if designing the full control logic.</p></li>
<li><p>Use it as a setpoint input, assuming a lower-level controller handles the rest.</p></li>
<li><p>Or reduce it to a binary signal—heater on or off—when working with logged behavior from a smart thermostat.</p></li>
</ul>
<p>Each perspective shapes the kind of model we build and the kind of control problem we pose. If we’re aiming to design a controller from scratch, it may be worth modeling the full closed-loop dynamics. If the goal is to tune setpoints or learn policies from data, a coarser abstraction might be not only sufficient, but more robust.</p>
</section>
<section id="why-this-model">
<h2>Why This Model?<a class="headerlink" href="#why-this-model" title="Link to this heading">#</a></h2>
<p>At this point, you might wonder: why go through the trouble of building this kind of physics-based model at all? After all, if we can log indoor temperatures, thermostat actions, and weather data, isn’t it easier to just learn a model from data? A neural ODE, for example, would let us define a parameterized function:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{z}}(t) = f_{\boldsymbol{\theta}}(\mathbf{z}(t), \mathbf{u}(t), \mathbf{d}(t)), \quad \mathbf{y}(t) = g_{\boldsymbol{\theta}}(\mathbf{z}(t)),
\]</div>
<p>with both <span class="math notranslate nohighlight">\(f_{\boldsymbol{\theta}}\)</span> and <span class="math notranslate nohighlight">\(g_{\boldsymbol{\theta}}\)</span> learned from data. The internal state <span class="math notranslate nohighlight">\(\mathbf{z}(t)\)</span> is not tied to any physical quantity. It just needs to be expressive enough to explain the observations.</p>
<p>That flexibility can be useful, particularly when a large dataset is already available. But in building control and energy modeling, the constraints are usually different.</p>
<p>Often, the engineer or consultant on site is working under tight time and information budgets. A floor plan might be available, along with some basic specs on insulation or window types, and a few days of logged sensor data. The task might be to simulate load under different weather scenarios, tune a controller, or just help understand why a room is slow to heat up. The model has to be built quickly, adapted easily, and remain understandable to others working on the same system.</p>
<p>In that context, RC models are often the default choice: not because they are inherently better, but because they fit the workflow.</p>
<p><strong>Interpretability.</strong>
The parameters correspond to things you can reason about: thermal resistance, capacitance, heat transfer between zones. You can cross-check values against architectural plans, or adjust them manually when something doesn’t line up. You can tell which wall or zone is contributing to slow recovery times.</p>
<p><strong>Identifiability with limited data.</strong>
RC models can often be calibrated from short data traces, even when not all state variables are directly observable. The structure already imposes constraints: heat flows from hot to cold, dynamics are passive, responses are smooth. Those properties help narrow the space of valid parameter settings. A neural ODE, in contrast, typically needs more data to settle into stable and plausible dynamics—especially if no additional constraints are enforced during training.</p>
<p><strong>Simplicity and reuse.</strong>
Once the model is built, it’s straightforward to modify. If a window is replaced, or a wall gets insulated, you only need to update a few numbers.  It’s easy to pass along to another engineer or embed in a larger simulation. A model like</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}} = \mathbf{A}\mathbf{x} + \mathbf{B}\mathbf{u} + \mathbf{E}\mathbf{d}
\]</div>
<p>is linear and low-dimensional. Simulating it is cheap, even if you do it many times. That may not matter now, but it will matter later, when we want to optimize over trajectories or learn from them.</p>
<p>This doesn’t mean RC models are always sufficient. They simplify or ignore many effects: solar gains, occupancy, nonlinearities, humidity, equipment switching behavior. If those effects are significant, and you have enough data, a black-box model (neural ODE or otherwise) might achieve lower prediction error. In practice, though, it’s common to combine the two: use the RC structure as a backbone, and learn a residual model to correct for unmodeled dynamics.</p>
</section>
</section>
<section id="from-deterministic-to-stochastic">
<h1>From Deterministic to Stochastic<a class="headerlink" href="#from-deterministic-to-stochastic" title="Link to this heading">#</a></h1>
<p>The models we’ve seen so far were deterministic: given an initial state and input sequence, the system evolves in a fixed, predictable way. But real systems rarely behave so neatly. Sensors are noisy. Parameters drift. The world changes in ways we can’t fully model.</p>
<p>To account for this uncertainty, we move from deterministic dynamics to <strong>stochastic models</strong>. There are two equivalent but conceptually distinct ways to do this.</p>
<section id="function-plus-noise">
<h2>Function plus Noise<a class="headerlink" href="#function-plus-noise" title="Link to this heading">#</a></h2>
<p>The most direct extension adds a noise term to the dynamics:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = f_t(\mathbf{x}_t, \mathbf{u}_t, \mathbf{w}_t), \quad \mathbf{w}_t \sim p_{\mathbf{w}}.
\]</div>
<p>If the noise is additive and Gaussian, we recover the standard linear-Gaussian setup used in Kalman filtering:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = A\mathbf{x}_t + B\mathbf{u}_t + \mathbf{w}_t, \quad \mathbf{w}_t \sim \mathcal{N}(0, Q).
\]</div>
<p>But we’re not restricted to Gaussian or additive noise. For instance, if the noise distribution is non-Gaussian:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = f(\mathbf{x}_t, \mathbf{u}_t) + \mathbf{w}_t, \quad \mathbf{w}_t \sim \text{Laplace}, \ \text{or}\ \text{Student-t},
\]</div>
<p>then <span class="math notranslate nohighlight">\(\mathbf{x}_{t+1}\)</span> inherits those properties. This is known as a <strong>convolution model</strong>: the next-state distribution is a shifted version of the noise distribution, centered around the deterministic prediction. More formally, it’s a special case of a <strong>pushforward measure</strong>: the randomness from <span class="math notranslate nohighlight">\(\mathbf{w}_t\)</span> is “pushed forward” through the function <span class="math notranslate nohighlight">\(f\)</span> to yield a distribution over outcomes.</p>
<p>Or the noise might enter multiplicatively:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = f(\mathbf{x}_t, \mathbf{u}_t) + \Gamma(\mathbf{x}_t, \mathbf{u}_t) \mathbf{w}_t,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Gamma\)</span> is a matrix that modulates the effect of the noise, potentially depending on state and control. If <span class="math notranslate nohighlight">\(\Gamma\)</span> is invertible, we can even write down an explicit density via a change-of-variables:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{x}_{t+1} \mid \mathbf{x}_t, \mathbf{u}_t) = p_{\mathbf{w}}\left(\Gamma^{-1}(\mathbf{x}_t, \mathbf{u}_t)\left[\mathbf{x}_{t+1} - f(\mathbf{x}_t, \mathbf{u}_t)\right] \right)\cdot \left| \det \Gamma^{-1} \right|.
\]</div>
<p>This kind of structured noise is common in practice, for example, when disturbances are amplified at certain operating points.</p>
<p>The <strong>function-plus-noise</strong> view is natural when we have a physical or simulator-based model and want to account for uncertainty around it. It is <strong>constructive</strong>: we know how the system evolves and how the randomness enters. This means we can <strong>track the source of variability along a trajectory</strong>, which is particularly useful for techniques like <strong>reparameterization</strong> or <strong>infinitesimal perturbation analysis (IPA)</strong>. These methods rely on being able to differentiate through the noise injection mechanism, something that is much easier when the noise is explicit and structured.</p>
</section>
<section id="transition-kernel">
<h2>Transition Kernel<a class="headerlink" href="#transition-kernel" title="Link to this heading">#</a></h2>
<p>The second perspective skips over the internal noise and defines the system directly in terms of the probability distribution over next states:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{x}_{t+1} \mid \mathbf{x}_t, \mathbf{u}_t).
\]</div>
<p>This <strong>transition kernel</strong> encodes all the uncertainty in the system’s evolution, without reference to any underlying noise source or functional form.</p>
<p>This view is strictly more general: it includes the function-plus-noise case as a special instance. If we do know the function <span class="math notranslate nohighlight">\(f\)</span> and the noise distribution <span class="math notranslate nohighlight">\(p_{\mathbf{w}}\)</span> from the generative model, then the transition kernel is obtained by “pushing” the randomness through the function:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{x}_{t+1} \mid \mathbf{x}_t, \mathbf{u}_t) = \int \delta(\mathbf{x}_{t+1} - f(\mathbf{x}_t, \mathbf{u}_t, \mathbf{w})) \, p_{\mathbf{w}}(\mathbf{w}) \, d\mathbf{w}.
\]</div>
<p>This might look abstract, but it’s just marginalization: for each possible noise value <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>, we compute the resulting next state, and then average over all possible <span class="math notranslate nohighlight">\(\mathbf{w}\)</span>, weighted by how likely each one is.</p>
<p>If the noise were discrete, this becomes a sum:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{x}_{t+1} \mid \mathbf{x}_t, \mathbf{u}_t) = \sum_{i=1}^k \mathbb{1}\{f(\mathbf{x}_t, \mathbf{u}_t, w_i) = \mathbf{x}_{t+1}\} \cdot p_i
\]</div>
<p>This abstraction is especially useful when we don’t know (or don’t care about) the underlying function or noise distribution. All we need is the ability to sample transitions or estimate their likelihoods. This is the default formulation in reinforcement learning, econometrics, and other settings focused on behavior rather than mechanism.</p>
</section>
<section id="continuous-time-analogue">
<h2>Continuous-Time Analogue<a class="headerlink" href="#continuous-time-analogue" title="Link to this heading">#</a></h2>
<p>In continuous time, the stochastic dynamics of a system are often described using a <strong>stochastic differential equation (SDE)</strong>:</p>
<div class="math notranslate nohighlight">
\[
d\mathbf{X}_t = f(\mathbf{X}_t, \mathbf{U}_t)\,dt + \sigma(\mathbf{X}_t, \mathbf{U}_t)\,d\mathbf{W}_t,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{W}_t\)</span> is Brownian motion. The first term, called the <strong>drift</strong>, describes the average motion of the system. The second, scaled by <span class="math notranslate nohighlight">\(\sigma\)</span>, models how random fluctuations (diffusion) enter over time. Just like in discrete time, this is a <strong>function + noise</strong> model: the state evolves through a deterministic path perturbed by stochastic input.</p>
<p>This generative view again induces a probability distribution over future states. At any future time <span class="math notranslate nohighlight">\(t + \Delta t\)</span>, the system doesn’t land at a single state but is described by a distribution that depends on the initial condition and the noise along the way.</p>
<p>Mathematically, this distribution evolves according to what’s called the <strong>Fokker–Planck equation</strong>—a partial differential equation that governs how probability density “flows” through time. It plays the same role here as the transition kernel did in discrete time: describing how likely the system is to be in any given state, without referring to the noise directly.</p>
<p>While the mathematical generalization is clean, working with continuous-time stochastic models can be more challenging. Simulating sample paths is often straightforward (eg. nowadays diffusion models in generative AI), but writing down or computing the exact transition distribution usually isn’t. That’s why many practical methods still rely on discrete-time approximations, even when the underlying system is continuous.</p>
<section id="example-managing-a-quebec-hydroelectric-reservoir">
<h3>Example: Managing a Québec Hydroelectric Reservoir<a class="headerlink" href="#example-managing-a-quebec-hydroelectric-reservoir" title="Link to this heading">#</a></h3>
<p>On the James Bay plateau, 1 400 km north of Montréal, the Robert-Bourassa reservoir stores roughly 62 km³ of water, more than the volume of Lake Ontario above its minimum operating level. Sixteen giant turbines sit 140 m below the surface, converting that stored head into 5.6 GW of electricity, about a fifth of Hydro-Québec’s total capacity. A steady share of that output feeds Québec’s aluminium smelters, which depend on stable, uninterrupted power.</p>
<p>Water managers face competing objectives:</p>
<ul class="simple">
<li><p><strong>Flood safety.</strong> Sudden snowmelt or storms can overfill the basin, forcing emergency spillways to open. These events are spectacular, but carry real downstream risk and economic cost.</p></li>
<li><p><strong>Energy reliability.</strong> If the level falls too low, turbines sit idle and contracts go unmet. Voltage dips at the smelters are measured in lost millions.</p></li>
</ul>
<p>A basic deterministic model for the reservoir’s mass balance is just bookkeeping:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = \mathbf{x}_t + \mathbf{r}_t - \mathbf{u}_t,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> is the current reservoir level, <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> is the controlled outflow through turbines, and <span class="math notranslate nohighlight">\(\mathbf{r}_t\)</span> is the natural inflow from rainfall and upstream runoff.</p>
<p>But inflow is variable, and its statistical structure matters. Two hydrological regimes dominate:</p>
<ul class="simple">
<li><p>In spring, melting snow over days can produce a long-tailed inflow distribution, often modeled as log-normal or Gamma.</p></li>
<li><p>In summer, convective storms yield a skewed mixture: a point mass at zero (no rain), and a thin but heavy tail capturing sudden bursts.</p></li>
</ul>
<p>This motivates a simple stochastic extension:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{x}_{t+1} = \mathbf{x}_t - \mathbf{u}_t + \mathbf{w}_t, \quad
\mathbf{w}_t \sim
\begin{cases}
0 &amp; \text{with prob. } p_0, \\\\
\text{LogNormal}(\mu, \sigma^2) &amp; \text{with prob. } 1 - p_0.
\end{cases}
\end{split}\]</div>
<p>Here the physics is fixed, and all uncertainty sits in the inflow term <span class="math notranslate nohighlight">\(\mathbf{w}_t\)</span>. Rather than fitting a full transition model from <span class="math notranslate nohighlight">\((\mathbf{x}_t, \mathbf{u}_t)\)</span> to <span class="math notranslate nohighlight">\(\mathbf{x}_{t+1}\)</span>, we can isolate the inflow by rearranging the mass balance:</p>
<div class="math notranslate nohighlight">
\[
\hat{\mathbf{w}}_t = \mathbf{x}_{t+1} - \mathbf{x}_t + \mathbf{u}_t.
\]</div>
<p>This gives a direct estimate of the realized inflow at each timestep. From there, the problem becomes one of density estimation: fit a probabilistic model to the residuals <span class="math notranslate nohighlight">\(\hat{\mathbf{w}}_t\)</span>. In spring, this might be a log-normal distribution. In summer, a two-part mixture: a point mass at zero, and an exponential tail. These distributions can be estimated by maximum likelihood, or adjusted using additional features (covariates) such as upstream snowpack or forecasted temperature.</p>
<p>This setup has practical benefits. Fixing the physical part of the model (how levels respond to inflow and outflow) helps focus the statistical modeling effort. Rather than fitting a full system model, we only need to estimate the variability in inflows. This reduces the number of degrees of freedom and makes the estimation problem easier to interpret. It also avoids conflating uncertainty in inflow with uncertainty in the system’s response.</p>
<p>Compare this to a more generic approach, such as linear regression:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = a \mathbf{x}_t + b \mathbf{u}_t + \varepsilon_t.
\]</div>
<p>This is straightforward to fit, but offers no guarantee that the result behaves sensibly. The model might violate conservation of mass, or compensate for inflow variation by adjusting coefficients <span class="math notranslate nohighlight">\(a\)</span> and <span class="math notranslate nohighlight">\(b\)</span>. This can lead to misleading conclusions, especially when extrapolating beyond the training data.</p>
<!-- Hydro‑Québec engineers rely on structured models in practice. Over 150 gauging stations across the La Grande basin report real-time flows, levels, and precipitation to Environment Canada's HYDAT database, which is accessible through a public API. These data feed into Hydro‑Québec's SCADA systems, along with snow-course readings and rainfall estimates. From there, engineers build seasonal inflow models and update them daily.

Synthetic years are then generated by sampling from these models. Each sampled inflow sequence is pushed through the deterministic mass balance, producing a possible reservoir trajectory. These Monte Carlo rollouts are used directly for planning. They help evaluate turbine schedules, size safety margins, and identify periods of elevated risk.

Structured models are not just a matter of physical fidelity. They shape how data is used, how uncertainty is handled, and how downstream decisions are informed. The separation between known dynamics and unknown inputs gives a cleaner interface between estimation and control. -->
</section>
</section>
</section>
<section id="partial-observability">
<h1>Partial Observability<a class="headerlink" href="#partial-observability" title="Link to this heading">#</a></h1>
<p>So far, we’ve assumed that the full system state <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> is available. But in most real-world settings, only a partial or noisy observation is accessible. Sensors have limited coverage, measurements come with noise, and some variables aren’t observable at all.</p>
<p>To model this, we introduce an <strong>observation equation</strong> alongside the system dynamics:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{x}_{t+1} &amp;= f_t(\mathbf{x}_t, \mathbf{u}_t, \mathbf{w}_t), \quad \mathbf{w}_t \sim p_{\mathbf{w}}, \\
\mathbf{y}_t &amp;= h_t(\mathbf{x}_t, \mathbf{v}_t), \quad \mathbf{v}_t \sim p_{\mathbf{v}}.
\end{aligned}
\end{split}\]</div>
<p>The state <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> evolves under control inputs <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> and process noise <span class="math notranslate nohighlight">\(\mathbf{w}_t\)</span>, but we don’t get to see <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> directly. Instead, we observe <span class="math notranslate nohighlight">\(\mathbf{y}_t\)</span>, which depends on <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> through some possibly nonlinear, noisy function <span class="math notranslate nohighlight">\(h_t\)</span>. The noise <span class="math notranslate nohighlight">\(\mathbf{v}_t\)</span> captures measurement uncertainty.</p>
<p>This setup defines a partially observed system. Even if the underlying dynamics are known, we still face uncertainty due to limited visibility into the true state. The controller or estimator must rely on the observations <span class="math notranslate nohighlight">\(\mathbf{y}_{0\:t}\)</span> to make sense of the hidden trajectory.</p>
<p>In the <strong>deterministic</strong> case, if the output map <span class="math notranslate nohighlight">\(h_t\)</span> is full-rank and invertible, we may be able to reconstruct the state directly from the output: no filtering required. But once noise is introduced, that invertibility becomes more subtle: even if <span class="math notranslate nohighlight">\(h_t\)</span> is bijective, the presence of <span class="math notranslate nohighlight">\(\mathbf{v}_t\)</span> prevents us from recovering <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> exactly. In this case, we must shift from inversion to estimation, often via probabilistic inference.</p>
<p>In the <strong>linear-Gaussian case</strong>, the model simplifies to:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{x}_{t+1} &amp;= A\mathbf{x}_t + B\mathbf{u}_t + \mathbf{w}_t, \quad \mathbf{w}_t \sim \mathcal{N}(0, Q), \\
\mathbf{y}_t &amp;= C\mathbf{x}_t + D\mathbf{u}_t + \mathbf{v}_t, \quad \mathbf{v}_t \sim \mathcal{N}(0, R).
\end{aligned}
\end{split}\]</div>
<p>This is the classical state-space model used in signal processing and control. It’s fully specified by the system matrices and the covariances <span class="math notranslate nohighlight">\(Q\)</span> and <span class="math notranslate nohighlight">\(R\)</span>. The state is no longer known, but under these assumptions it can be estimated recursively using the <strong>Kalman filter</strong>, which maintains a Gaussian belief over <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span>.</p>
<p>Even when the model is nonlinear or non-Gaussian, the structure remains the same: a dynamic state evolves, and a separate observation process links it to the data we see. Many modern estimation techniques, including extended and unscented Kalman filters, particle filters, and learned neural estimators, build on this core structure.</p>
<section id="observation-kernel-view">
<h2>Observation Kernel View<a class="headerlink" href="#observation-kernel-view" title="Link to this heading">#</a></h2>
<p>Just as we moved from function-based dynamics to transition kernels, we can abstract away the noise source and define the <strong>observation distribution</strong> directly:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{y}_t \mid \mathbf{x}_t).
\]</div>
<p>This kernel summarizes what the sensors tell us about the hidden state. If we know the generative model—say, that <span class="math notranslate nohighlight">\(\mathbf{y}_t = h_t(\mathbf{x}_t) + \mathbf{v}_t\)</span> with known <span class="math notranslate nohighlight">\(p_{\mathbf{v}}\)</span>—then this kernel is induced by marginalizing out <span class="math notranslate nohighlight">\(\mathbf{v}_t\)</span>:</p>
<div class="math notranslate nohighlight">
\[
p(\mathbf{y}_t \mid \mathbf{x}_t) = \int \delta\bigl(\mathbf{y}_t - h_t(\mathbf{x}_t, \mathbf{v})\bigr)\, p_{\mathbf{v}}(\mathbf{v})\, d\mathbf{v}.
\]</div>
<p>But we don’t have to start from the generative form. In practice, we might define or learn <span class="math notranslate nohighlight">\(p(\mathbf{y}_t \mid \mathbf{x}_t)\)</span> directly, especially when dealing with black-box sensors, perception models, or abstract measurement processes.</p>
</section>
<section id="example-stabilizing-a-telescope-s-vision-with-adaptive-optics">
<h2>Example – Stabilizing a Telescope’s Vision with Adaptive Optics<a class="headerlink" href="#example-stabilizing-a-telescope-s-vision-with-adaptive-optics" title="Link to this heading">#</a></h2>
<p>On Earth, even the largest telescopes can’t see perfectly. As starlight travels through the atmosphere, tiny air pockets with different temperatures bend the light in slightly different directions. The result is a distorted image: instead of a sharp point, a star looks like a flickering blob. The distortion happens fast, on the order of milliseconds, and changes continuously as wind moves the turbulent layers overhead.</p>
<p>This is where <strong>adaptive optics (AO)</strong> comes in. AO systems aim to cancel out these distortions in real time. They do this by measuring how the incoming wavefront of light is distorted and using a flexible mirror to apply a counter-distortion that straightens it back out. But there’s a catch: you can’t observe the wavefront directly. You only get noisy measurements of its <strong>slopes</strong> (the angles of tilt at various points), and you have to act fast, before the atmosphere changes again.</p>
<p>To design a controller here, we need a model of how the distortions evolve. And that means building a decision-making model: one that includes uncertainty, partial observability, and fast feedback.</p>
<p><strong>State.</strong> The main object we’re trying to track is the distortion of the incoming wavefront. We can’t observe this phase field <span class="math notranslate nohighlight">\(\phi(\mathbf{r}, t)\)</span> directly, but we can represent it approximately using a finite basis (e.g., Fourier or Zernike). The coefficients of this expansion form our internal state:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_t \in \mathbb{R}^n \quad \text{(wavefront distortion at time } t).
\]</div>
<p><strong>Dynamics.</strong> The atmosphere evolves in time. A simple but surprisingly effective model assumes the turbulence is “frozen” and just blown across the telescope by the wind. That gives us a <strong>discrete-time linear model</strong>:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = \mathbf{A} \mathbf{x}_t + \mathbf{w}_t,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> shifts the distortion pattern in space, and <span class="math notranslate nohighlight">\(\mathbf{w}_t\)</span> is a small random change from evolving turbulence. This noise is not arbitrary: its statistics follow a power law derived from <strong>Kolmogorov’s turbulence model</strong>. In particular, higher spatial frequencies (small-scale wiggles) have less energy than low ones. That lets us build a prior on how likely different distortions are.</p>
<p><strong>Observations.</strong> We can’t see the full wavefront. Instead, we use a <strong>wavefront sensor</strong>: a camera that captures how the light bends. What it actually measures are local slopes: the gradients of the wavefront, not the wavefront itself. So our observation model is:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{y}_t = \mathbf{C} \mathbf{x}_t + \boldsymbol{\varepsilon}_t,
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> is a known matrix that maps wavefront distortion to measurable slope angles, and <span class="math notranslate nohighlight">\(\boldsymbol{\varepsilon}_t\)</span> is measurement noise (e.g., due to photon limits).</p>
<p><strong>Control.</strong> Our job is to flatten the wavefront using a deformable mirror. The mirror can apply a small counter-distortion <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> that subtracts from the atmospheric one:</p>
<div class="math notranslate nohighlight">
\[
\text{Residual state:} \quad \mathbf{x}_t^{\text{res}} = \mathbf{x}_t - \mathbf{B} \mathbf{u}_t.
\]</div>
<p>The goal is to choose <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> to minimize the residual distortion by making the light flat again.</p>
<p><strong>Why a model matters.</strong> Without a model, we’d just react to the current noisy measurements. But with a model, we can predict how the wavefront will evolve, filter out noise, and act preemptively. This is essential in AO, where decisions must be made every millisecond. Kalman filters are often used to track the hidden state <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span>, combining model predictions with noisy measurements, and linear-quadratic regulators (LQR) or other optimal controllers use those estimates to choose the best correction.</p>
<p><strong>Time structure.</strong> This is a rare case where <strong>continuous-time modeling</strong> also plays a role. The true evolution of the turbulence is continuous, and we can model it using a <strong>stochastic differential equation (SDE)</strong>:</p>
<div class="math notranslate nohighlight">
\[
d\mathbf{x}(t) = \mathbf{F} \mathbf{x}(t)\,dt + \mathbf{G}\,d\mathbf{W}(t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{W}(t)\)</span> is Brownian motion and the matrix <span class="math notranslate nohighlight">\(\mathbf{G}\)</span> encodes the Kolmogorov spectrum. Discretizing this equation gives us the <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span> matrices for the discrete-time model above.</p>
<!-- ## Data-Driven Identification

Not all models come from physics. Sometimes, we fit them directly from data.

Even a basic linear regression of the form:

$$
x_{t+1} = a x_t + b u_t + c + \varepsilon_t
$$

is a dynamical model. But things can get more sophisticated. Subspace identification methods, sparse regressions like SINDy, Koopman embeddings, neural ODEs—all of these let us learn models from observed trajectories. The key question is how much structure we assume. Do we enforce linearity? Time-invariance? Do we try to model the noise? -->
<!-- 
# Comparing Physics-Based RC Models with Black-Box Fits

The data used in this experiment comes from the *Building Energy Geeks* repository, an open-source collection created to demonstrate statistical learning techniques in building energy performance. The file `statespace.csv` provides a time series of indoor and outdoor temperatures together with heating power and solar irradiance. While not tied to a specific building description in the repository, it is designed to mimic realistic conditions either from actual sensor measurements or detailed simulation outputs. This dataset serves as a concrete foundation to explore the contrast between physics-based modeling and purely data-driven approaches.

At the core of our study lies the so-called **2R2C model**, a reduced-order representation of building thermal dynamics. The name refers to two resistances and two capacitances arranged in a thermal network that captures how heat flows between the indoor environment, the building envelope, and the outdoors. The indoor air temperature $T_i$ is influenced by the envelope temperature $T_e$, which itself exchanges heat with the external environment at temperature $T_o$. The resistances $R_i$ and $R_o$ describe the ease of heat conduction across these boundaries, while the capacitances $C_i$ and $C_e$ represent the heat storage capacity of the indoor air and of the building mass. By including the effect of heating input $\Phi_H$ and solar gains $\Phi_S$, the model balances both controllable and environmental influences.  

Mathematically, the dynamics are written as a pair of coupled ordinary differential equations. The first governs the indoor air temperature and is given by

$$
\frac{dT_i}{dt} = \frac{T_e - T_i}{R_i C_i} + \frac{\eta_H \Phi_H}{C_i} + \frac{A_i \Phi_S}{C_i},
$$

while the second governs the envelope temperature,

$$
\frac{dT_e}{dt} = \frac{T_i - T_e}{R_i C_e} + \frac{T_o - T_e}{R_o C_e} + \frac{A_e \Phi_S}{C_e}.
$$

Here $\eta_H$ represents the efficiency of the heating system and $A_i, A_e$ are effective areas for solar gains. Since the original dataset is indexed in hours rather than seconds, the right-hand side of both equations must be scaled by a factor of 3600 to ensure correct integration over the chosen time unit.

The task is to identify the parameters of this model from data. To do so, we fit the parameters by minimizing the discrepancy between the simulated indoor temperature $T_i$ and the measured trajectory within a training window of 10 to 40 hours. A robust least-squares method with Huber loss is used so that large deviations, possibly due to noise or outliers, do not dominate the fit. Early time points in the training window are given slightly higher weight to ensure that the transient behavior is captured accurately, which is important when the system is initialized away from equilibrium. Once fitted, the model is simulated forward over the entire 0–100 hour horizon, allowing us to test its predictive power on an unseen window spanning 50 to 90 hours.

To provide meaningful context, we benchmark this physics-based model against two black-box alternatives. The first is a linear regression model that directly maps the contemporaneous values of outdoor temperature, heating power, and solar irradiance to the indoor temperature. This approach ignores temporal dynamics and treats the problem as a purely static regression. The second is a multilayer perceptron (MLP) that is trained with autoregressive lags. Specifically, the MLP is provided with the recent history of indoor temperatures together with the external inputs to predict the next indoor temperature. During training, a technique known as teacher forcing is employed, meaning the true past values of $T_i$ are always supplied, which allows the network to achieve a very tight fit on the training window. However, when rolled out on the test window without access to the ground-truth future values, small prediction errors accumulate, and the model struggles to generalize.

The results of this comparison illustrate a fundamental point. Although the MLP is highly flexible and achieves excellent accuracy on the training window, its predictions deteriorate rapidly on unseen data, demonstrating the pitfalls of overfitting and the instability of purely data-driven models in autoregressive settings. The linear regression baseline performs moderately but fails to capture the underlying physics, leading to systematic errors. In contrast, the 2R2C model, despite being governed by only a handful of parameters, extrapolates much more consistently. It responds in the correct direction to changes in heating and solar inputs, maintains stable long-term predictions, and provides parameters that map directly to interpretable physical properties such as insulation and thermal mass.  

This example therefore highlights the dual advantages of physics-based modeling: the ability to generalize beyond the training window and the guarantee of action-consistency rooted in thermodynamic reasoning. At the same time, it underscores the limitations of purely data-driven black-box models when asked to predict system behavior under conditions not seen during training.

```{code-cell} ipython3
:tags: [hide-input]
:load: _static/rcnetwork.py
``` -->
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="modeling.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Why Build a Model? For Whom?</p>
      </div>
    </a>
    <a class="right-next"
       href="simulation.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Programs as Models</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Dynamics Models for Decision Making</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-statespace-perspective">The State‑Space Perspective</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discrete-versus-continuous-time">Discrete versus continuous time</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-deterministic-dynamics-hvac-control">Examples of Deterministic Dynamics: HVAC Control</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#what-do-we-control">What Do We Control?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#why-this-model">Why This Model?</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#from-deterministic-to-stochastic">From Deterministic to Stochastic</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#function-plus-noise">Function plus Noise</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#transition-kernel">Transition Kernel</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#continuous-time-analogue">Continuous-Time Analogue</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-managing-a-quebec-hydroelectric-reservoir">Example: Managing a Québec Hydroelectric Reservoir</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#partial-observability">Partial Observability</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#observation-kernel-view">Observation Kernel View</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example-stabilizing-a-telescope-s-vision-with-adaptive-optics">Example – Stabilizing a Telescope’s Vision with Adaptive Optics</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pierre-Luc Bacon
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>