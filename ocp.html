
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Discrete-Time Trajectory Optimization &#8212; Practical Reinforcement Learning: From Algorithms to Applications</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- So that users can add custom icons -->
  <script src="_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"bm": ["{\\boldsymbol #1}", 1]}, "processEscapes": true}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'ocp';</script>
    <script src="_static/hydro.js?v=67e01585"></script>
    <script src="_static/iframe-modal.js?v=f72a1242"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Continuous-Time Trajectory Optimization" href="cocp.html" />
    <link rel="prev" title="Programs as Models" href="simulation.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Practical Reinforcement Learning: From Algorithms to Applications</p>
  
</a></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Why This Book?
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modeling</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Why Build a Model? For Whom?</a></li>

<li class="toctree-l1"><a class="reference internal" href="ssm.html">Dynamics Models for Decision Making</a></li>




<li class="toctree-l1"><a class="reference internal" href="simulation.html">Programs as Models</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Trajectory Optimization</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Discrete-Time Trajectory Optimization</a></li>

<li class="toctree-l1"><a class="reference internal" href="cocp.html">Continuous-Time Trajectory Optimization</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Trajectories to Policies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mpc.html">From Trajectories to Policies</a></li>



<li class="toctree-l1"><a class="reference internal" href="dp.html">Dynamic Programming</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Learning from Data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="adp.html">Approximate Dynamic Programming</a></li>





<li class="toctree-l1"><a class="reference internal" href="cadp.html">Policy Parametrization Methods</a></li>







</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix.html">Nonlinear Programming</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/edit/main/ocp.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/issues/new?title=Issue%20on%20page%20%2Focp.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/ocp.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Discrete-Time Trajectory Optimization</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Discrete-Time Trajectory Optimization</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discrete-time-optimal-control-problems-docps">Discrete-Time Optimal Control Problems (DOCPs)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-docps">Examples of DOCPs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#periodic-inventory-control">Periodic Inventory Control</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-day-portfolio-rebalancing">End-of-Day Portfolio Rebalancing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#daily-ad-budget-allocation-with-carryover">Daily Ad-Budget Allocation with Carryover</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#docps-arising-from-the-discretization-of-continuous-time-ocps">DOCPs Arising from the Discretization of Continuous-Time OCPs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#programs-as-docps-and-differentiable-programming">Programs as DOCPs and Differentiable Programming</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#example-http-retrier-optimization">Example: HTTP Retrier Optimization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#example-gradient-descent-with-momentum-as-docp">Example: Gradient Descent with Momentum as DOCP</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variants-lagrange-and-mayer-problems">Variants: Lagrange and Mayer Problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reducing-to-mayer-form-by-state-augmentation">Reducing to Mayer Form by State Augmentation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-methods-for-solving-docps">Numerical Methods for Solving DOCPs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simultaneous-methods">Simultaneous Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-direct-solution-to-the-eco-cruise-problem">Example: Direct Solution to the Eco-cruise Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#solution">Solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sequential-methods">Sequential Methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#in-between-sequential-and-simultaneous">In Between Sequential and Simultaneous</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="discrete-time-trajectory-optimization">
<h1>Discrete-Time Trajectory Optimization<a class="headerlink" href="#discrete-time-trajectory-optimization" title="Link to this heading">#</a></h1>
<p>In the previous chapter, we examined different ways to represent dynamical systems: continuous versus discrete time, deterministic versus stochastic, fully versus partially observable, and even simulation-based views such as agent-based or programmatic models. Our focus was on the <strong>structure of models</strong>: how they capture evolution, uncertainty, and information.</p>
<p>In this chapter, we turn to what makes these models useful for <strong>decision-making</strong>. The goal is no longer just to describe how a system behaves, but to leverage that description to <strong>compute actions over time</strong>. This doesn’t mean the model prescribes actions on its own. Rather, it provides the scaffolding for optimization: given a model and an objective, we can derive the control inputs that make the modeled system behave well according to a chosen criterion.</p>
<p>Our entry point will be trajectory optimization. By a <strong>trajectory</strong>, we mean the time-indexed sequence of states and controls that the system follows under a plan: the states <span class="math notranslate nohighlight">\((\mathbf{x}_1, \dots, \mathbf{x}_T)\)</span> together with the controls <span class="math notranslate nohighlight">\((\mathbf{u}_1, \dots, \mathbf{u}_{T-1})\)</span>. In this chapter, we focus on an <strong>open-loop</strong> viewpoint: starting from a known initial state, we compute the entire sequence of controls in advance and then apply it as-is. This is appealing because, for discrete-time problems, it yields a finite-dimensional optimization over a vector of decisions and cleanly exposes the structure of the constraints. In continuous time, the base formulation is infinite-dimensional; in this course we will rely on direct methods—time discretization and parameterization—to transform it into a finite-dimensional nonlinear program.</p>
<p>Open loop also has a clear limitation: if reality deviates from the model—due to disturbances, model mismatch, or unanticipated events—the state you actually reach may differ from the predicted one. The precomputed controls that were optimal for the nominal trajectory can then lead you further off course, and errors can compound over time.</p>
<p>Later, we will study <strong>closed-loop (feedback)</strong> strategies, where the choice of action at time <span class="math notranslate nohighlight">\(t\)</span> can depend on the state observed at time <span class="math notranslate nohighlight">\(t\)</span>. Instead of a single sequence, we optimize a policy <span class="math notranslate nohighlight">\(\pi_t\)</span> mapping states to controls, <span class="math notranslate nohighlight">\(\mathbf{u}_t = \pi_t(\mathbf{x}_t)\)</span>. Feedback makes plans resilient to unforeseen situations by adapting on the fly, but it leads to a more challenging problem class. We start with open-loop trajectory optimization to build core concepts and tools before tackling feedback design.</p>
<section id="discrete-time-optimal-control-problems-docps">
<h2>Discrete-Time Optimal Control Problems (DOCPs)<a class="headerlink" href="#discrete-time-optimal-control-problems-docps" title="Link to this heading">#</a></h2>
<p>Consider a system described by a <strong>state</strong> <span class="math notranslate nohighlight">\(\mathbf{x}_t \in \mathbb{R}^n\)</span>, summarizing everything needed to predict its evolution. At each stage <span class="math notranslate nohighlight">\(t\)</span>, we can influence the system through a <strong>control input</strong> <span class="math notranslate nohighlight">\(\mathbf{u}_t \in \mathbb{R}^m\)</span>. The dynamics specify how the state evolves:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{t+1} = \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{f}_t\)</span> may be nonlinear or time-varying. We assume the initial state <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> is known.</p>
<p>The goal is to pick a sequence of controls <span class="math notranslate nohighlight">\(\mathbf{u}_1,\dots,\mathbf{u}_{T-1}\)</span> that makes the trajectory desirable. But desirable in what sense? That depends on an <strong>objective function</strong>, which often includes two components:</p>
<div class="math notranslate nohighlight">
\[
\text{(i) stage cost: } c_t(\mathbf{x}_t,\mathbf{u}_t), \qquad \text{(ii) terminal cost: } c_T(\mathbf{x}_T).
\]</div>
<p>The stage cost reflects ongoing penalties—energy, delay, risk. The terminal cost measures the value (or cost) of ending in a particular state. <strong>Together, these give the canonical Bolza form</strong>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t,\mathbf{u}_t) \\
\text{subject to} \quad &amp; \mathbf{x}_{t+1} = \mathbf{f}_t(\mathbf{x}_t,\mathbf{u}_t), \ t=1,\dots,T-1.
\end{aligned}
\end{split}\]</div>
<p>Written this way, it may seem obvious that the decision variables are the controls <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span>. After all, in most intuitive descriptions of control, we think of choosing inputs to influence the system. But notice that in the program above, the entire state trajectory also appears as a set of variables, linked to the controls by the dynamics constraints. This is intentional: it reflects one way of writing the problem that makes the constraints explicit.</p>
<p>Why introduce <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> as decision variables if they can be simulated forward from the controls? Many readers hesitate here, and the question is natural: <em>If the model is deterministic and <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span> is known, why not pick <span class="math notranslate nohighlight">\(\mathbf{u}_{1:T-1}\)</span> and compute <span class="math notranslate nohighlight">\(\mathbf{x}_{2:T}\)</span> on the fly?</em> That instinct leads to <strong>single shooting</strong>, a method we will return to shortly.</p>
<p>Already in this formulation, though, we see an important theme: <strong>the structure of the problem matters</strong>. Ignoring it can make our life much harder. The reason is twofold:</p>
<ul class="simple">
<li><p><strong>Dimensionality grows with the horizon.</strong> For a horizon of length <span class="math notranslate nohighlight">\(T\)</span>, the program has roughly <span class="math notranslate nohighlight">\((T-1)(m+n)\)</span> decision variables.</p></li>
<li><p><strong>Temporal coupling.</strong> Each control affects all future states and costs. The feasible set is not a simple box but a narrow manifold defined by the dynamics.</p></li>
</ul>
<p>Together, these features explain why specialized methods exist and why the way we write the problem influences the algorithms we can use. Whether we keep states explicit or eliminate them through forward simulation determines not just the problem size, but also its conditioning and the trade-offs between robustness and computational effort.</p>
<section id="examples-of-docps">
<h3>Examples of DOCPs<a class="headerlink" href="#examples-of-docps" title="Link to this heading">#</a></h3>
<p>To make things concrete, here are three problems that are naturally posed as discrete-time OCPs. In each case, we seek an optimal trajectory of states and controls over a finite horizon.</p>
<section id="periodic-inventory-control">
<h4>Periodic Inventory Control<a class="headerlink" href="#periodic-inventory-control" title="Link to this heading">#</a></h4>
<p>Decisions are made once per period: choose order quantity <span class="math notranslate nohighlight">\(u_k \ge 0\)</span> to meet forecast demand <span class="math notranslate nohighlight">\(d_k\)</span>. The state <span class="math notranslate nohighlight">\(x_k\)</span> is on-hand inventory with dynamics <span class="math notranslate nohighlight">\(x_{k+1} = x_k + u_k - d_k\)</span>. A typical stage cost is <span class="math notranslate nohighlight">\(c_k(x_k,u_k) = h\,[x_k]_+ + p\,[-x_k]_+ + c\,u_k\)</span>, trading off holding, backorder, and ordering costs. The horizon objective is <span class="math notranslate nohighlight">\(\min \sum_{k=0}^{T-1} c_k(x_k,u_k)\)</span> subject to bounds.</p>
</section>
<section id="end-of-day-portfolio-rebalancing">
<h4>End-of-Day Portfolio Rebalancing<a class="headerlink" href="#end-of-day-portfolio-rebalancing" title="Link to this heading">#</a></h4>
<p>At each trading day <span class="math notranslate nohighlight">\(k\)</span>, choose trades <span class="math notranslate nohighlight">\(u_k\)</span> to adjust holdings <span class="math notranslate nohighlight">\(h_k\)</span> before next-day returns <span class="math notranslate nohighlight">\(r_{k}\)</span> realize. Deterministic planning uses predicted returns <span class="math notranslate nohighlight">\(\mu_k\)</span>, with dynamics <span class="math notranslate nohighlight">\(h_{k+1} = (h_k + u_k) \odot (\mathbf{1} + \mu_k)\)</span> and budget/box constraints. The stage cost can capture transaction costs and risk, e.g., <span class="math notranslate nohighlight">\(c_k(h_k,u_k) = \tau\lVert u_k \rVert_1 + \tfrac{\lambda}{2}\,h_k^\top \Sigma_k h_k\)</span>, with a terminal utility or wealth objective.</p>
</section>
<section id="daily-ad-budget-allocation-with-carryover">
<h4>Daily Ad-Budget Allocation with Carryover<a class="headerlink" href="#daily-ad-budget-allocation-with-carryover" title="Link to this heading">#</a></h4>
<p>Allocate spend <span class="math notranslate nohighlight">\(u_k \in [0, U_{\max}]\)</span> to build awareness <span class="math notranslate nohighlight">\(s_k\)</span> with carryover dynamics <span class="math notranslate nohighlight">\(s_{k+1} = \alpha s_k + \beta u_k\)</span>. Conversions/revenue at day <span class="math notranslate nohighlight">\(k\)</span> follow a response curve <span class="math notranslate nohighlight">\(g(s_k,u_k)\)</span>; the goal is <span class="math notranslate nohighlight">\(\max \sum_{k=0}^{T-1} g(s_k,u_k) - c\,u_k\)</span> subject to spend limits. This is naturally discrete because decisions and measurements occur daily.</p>
</section>
</section>
<section id="docps-arising-from-the-discretization-of-continuous-time-ocps">
<h3>DOCPs Arising from the Discretization of Continuous-Time OCPs<a class="headerlink" href="#docps-arising-from-the-discretization-of-continuous-time-ocps" title="Link to this heading">#</a></h3>
<p>Although many applications are natively discrete-time, it is also common to obtain a DOCP by discretizing a continuous-time formulation. Consider a system on <span class="math notranslate nohighlight">\([0, T_c]\)</span> given by</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = \mathbf{f}(t, \mathbf{x}(t), \mathbf{u}(t)), \qquad \mathbf{x}(0) = \mathbf{x}_0.
\]</div>
<p>Choose a step size <span class="math notranslate nohighlight">\(\Delta &gt; 0\)</span> and grid <span class="math notranslate nohighlight">\(t_k = k\,\Delta\)</span>. A one-step integration scheme induces a discrete map <span class="math notranslate nohighlight">\(\mathbf{F}_\Delta\)</span> so that</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1} = \mathbf{F}_\Delta(\mathbf{x}_k, \mathbf{u}_k, t_k),\qquad k=0,\dots, T-1,
\]</div>
<p>where, for example, explicit Euler gives <span class="math notranslate nohighlight">\(\mathbf{F}_\Delta(\mathbf{x},\mathbf{u},t) = \mathbf{x} + \Delta\,\mathbf{f}(t,\mathbf{x},\mathbf{u})\)</span>. The resulting discrete-time optimal control problem takes the Bolza form with these induced dynamics:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{\mathbf{x}_k,\mathbf{u}_k\}}\; &amp; c_T(\mathbf{x}_T) + \sum_{k=0}^{T-1} c_k(\mathbf{x}_k,\mathbf{u}_k) \\
\text{s.t.}\; &amp; \mathbf{x}_{k+1} - \mathbf{F}_\Delta(\mathbf{x}_k,\mathbf{u}_k, t_k) = 0,\quad k=0,\dots,T-1, \\
&amp; \mathbf{x}_0 = \mathbf{x}_\mathrm{init}.
\end{aligned}
\end{split}\]</div>
</section>
<section id="programs-as-docps-and-differentiable-programming">
<h3>Programs as DOCPs and Differentiable Programming<a class="headerlink" href="#programs-as-docps-and-differentiable-programming" title="Link to this heading">#</a></h3>
<p>It is often useful to view a computer program itself as a discrete-time dynamical system. Let the <strong>program state</strong> collect memory, buffers, and intermediate variables, and let the <strong>control</strong> represent inputs or tunable decisions at each step. A single execution step defines a transition map</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}=\Phi_k(\mathbf{x}_k,\mathbf{u}_k),
\]</div>
<p>and a scalar objective (e.g., loss, error, runtime, energy) yields a DOCP:</p>
<div class="math notranslate nohighlight">
\[
\min_{\{\mathbf{u}_k\}} \; c_T(\mathbf{x}_T)+\sum_{k=0}^{T-1} c_k(\mathbf{x}_k,\mathbf{u}_k)
\quad\text{s.t.}\quad \mathbf{x}_{k+1}=\Phi_k(\mathbf{x}_k,\mathbf{u}_k).
\]</div>
<p>In differentiable programming (e.g., JAX, PyTorch), the composed map <span class="math notranslate nohighlight">\(\Phi_{T-1}\circ\cdots\circ\Phi_0\)</span> is differentiable, enabling reverse-mode automatic differentiation and efficient gradient-based trajectory optimization. When parts of the program are non-differentiable (discrete branches, simulators with events), DOCPs can still be solved using derivative-free or weak-gradient methods (eg. finite differences, SPSA, Nelder–Mead, CMA-ES, or evolutionary strategies) optionally combined with smoothing, relaxations, or stochastic estimators to navigate non-smooth regions.</p>
<section id="example-http-retrier-optimization">
<h4>Example: HTTP Retrier Optimization<a class="headerlink" href="#example-http-retrier-optimization" title="Link to this heading">#</a></h4>
<p>As an example we cast the problem of optimizing a “HTTP retrier with backoff” as a DOCP where the state tracks wall-clock time, attempt index, success, last code, and jitter; the control is the chosen wait time before the next request (the backoff schedule); the transition encapsulates waiting and a probabilistic request outcome; and the objective penalizes latency and failure. We then optimize the schedule either directly (per-step SPSA) or via a two-parameter exponential policy using common random numbers for variance reduction.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span> <span class="nn">math</span><span class="o">,</span> <span class="nn">random</span>

<span class="c1"># ---------------------------</span>
<span class="c1"># PROGRAM = &quot;HTTP retrier with backoff&quot;</span>
<span class="c1"># ---------------------------</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">State</span><span class="p">:</span>
    <span class="n">t</span><span class="p">:</span> <span class="nb">float</span>            <span class="c1"># wall-clock time (s)</span>
    <span class="n">k</span><span class="p">:</span> <span class="nb">int</span>              <span class="c1"># attempt index</span>
    <span class="n">done</span><span class="p">:</span> <span class="nb">bool</span>          <span class="c1"># success flag</span>
    <span class="n">code</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span>    <span class="c1"># last HTTP code or None</span>
    <span class="n">jitter</span><span class="p">:</span> <span class="nb">float</span>       <span class="c1"># per-run jitter (simulates clock/socket noise)</span>

<span class="c1"># Controls (decision variables): per-step wait times (backoff schedule)</span>
<span class="c1"># u[k] can be optimized; in a fixed policy you&#39;d set u[k] = base * gamma**k</span>
<span class="c1"># We&#39;ll keep them bounded for realism.</span>
<span class="k">def</span> <span class="nf">clamp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">hi</span><span class="p">):</span> <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">hi</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>

<span class="c1"># Simulated environment: availability is time-varying (spiky outage)</span>
<span class="k">def</span> <span class="nf">server_success_prob</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># Low availability for the first 2 seconds, then rebounds</span>
    <span class="n">base</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mf">2.0</span> <span class="k">else</span> <span class="mf">0.85</span>
    <span class="c1"># Some diurnal-like wobble (toy)</span>
    <span class="n">wobble</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">t</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">clamp</span><span class="p">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">wobble</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">http_request</span><span class="p">():</span>
    <span class="c1"># Just returns a code; success = 200, failure = 503</span>
    <span class="k">return</span> <span class="mi">200</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="mi">503</span>

<span class="c1"># -------- DOCP ingredients --------</span>
<span class="c1"># State x_k = (t, k, done, code, jitter)</span>
<span class="c1"># Control u_k = wait time before next attempt (our backoff schedule entry)</span>
<span class="c1"># Transition Phi_k: one &quot;program step&quot; = (optional wait) + (one request) + (branch)</span>
<span class="k">def</span> <span class="nf">Phi</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">u_k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">State</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">done</span><span class="p">:</span>
        <span class="c1"># No-ops after success (absorbing state)</span>
        <span class="k">return</span> <span class="n">State</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">jitter</span><span class="p">)</span>

    <span class="c1"># 1) Wait according to control (backoff schedule) + jitter</span>
    <span class="n">wait</span> <span class="o">=</span> <span class="n">clamp</span><span class="p">(</span><span class="n">u_k</span> <span class="o">+</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">jitter</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="n">wait</span>

    <span class="c1"># 2) Environment: success probability depends on time t</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">server_success_prob</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># 3) &quot;Perform request&quot;: success with prob p; otherwise 503</span>
    <span class="n">code</span> <span class="o">=</span> <span class="mi">200</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p</span> <span class="k">else</span> <span class="mi">503</span>
    <span class="n">done</span> <span class="o">=</span> <span class="p">(</span><span class="n">code</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span>

    <span class="c1"># 4) Advance attempt counter and wall clock</span>
    <span class="k">return</span> <span class="n">State</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">done</span><span class="o">=</span><span class="n">done</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="n">code</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="n">state</span><span class="o">.</span><span class="n">jitter</span><span class="p">)</span>

<span class="c1"># Stage cost: latency penalty each step; heavy penalty if still failing late</span>
<span class="k">def</span> <span class="nf">stage_cost</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">u_k</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># Latency/energy per unit wait + small per-step overhead when not done</span>
    <span class="k">return</span> <span class="mf">0.20</span> <span class="o">*</span> <span class="n">u_k</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.00</span> <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">done</span> <span class="k">else</span> <span class="mf">0.002</span><span class="p">)</span>

<span class="c1"># Terminal cost: if failed after horizon, big penalty; if succeeded, pay total time</span>
<span class="k">def</span> <span class="nf">terminal_cost</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">State</span><span class="p">,</span> <span class="n">max_attempts</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># Pay for elapsed time; fail late incurs extra penalty</span>
    <span class="k">return</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">state</span><span class="o">.</span><span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="mf">5.0</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">state</span><span class="o">.</span><span class="n">done</span> <span class="ow">and</span> <span class="n">state</span><span class="o">.</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="n">max_attempts</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">rollout</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">State</span><span class="p">(</span><span class="n">t</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">done</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">code</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jitter</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">J</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_attempts</span><span class="p">):</span>
        <span class="n">J</span> <span class="o">+=</span> <span class="n">stage_cost</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Phi</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">done</span><span class="p">:</span>  <span class="c1"># early stop like a real program</span>
            <span class="k">break</span>
    <span class="n">J</span> <span class="o">+=</span> <span class="n">terminal_cost</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">max_attempts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">J</span><span class="p">,</span> <span class="n">s</span>  <span class="c1"># return final state for debugging if needed</span>

<span class="c1"># ---------- helpers for SPSA with common random numbers ----------</span>
<span class="k">def</span> <span class="nf">eval_policy</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
    <span class="c1"># Average over a fixed set of seeds (CRN helps SPSA a lot)</span>
    <span class="n">Js</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sd</span> <span class="ow">in</span> <span class="n">seeds</span><span class="p">:</span>
        <span class="n">J</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="n">max_attempts</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">sd</span><span class="p">)</span>
        <span class="n">Js</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Js</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">Js</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">project_waits</span><span class="p">(</span><span class="n">u</span><span class="p">):</span>
    <span class="c1"># Keep waits in [0, 3] for realism</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u</span><span class="p">]</span>

<span class="c1"># ---------- schedule parameterizations ----------</span>
<span class="k">def</span> <span class="nf">schedule_exp</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">gamma</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="c1"># u[k] = base * gamma**k</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">base</span> <span class="o">*</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">**</span> <span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>

<span class="c1"># If you prefer per-step but monotone nonnegative waits, use softplus increments:</span>
<span class="k">def</span> <span class="nf">schedule_softplus</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
    <span class="c1"># z in R^K -&gt; u monotone via cumulative softplus increments</span>
    <span class="k">def</span> <span class="nf">softplus</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span> <span class="o">+</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
    <span class="n">inc</span> <span class="o">=</span> <span class="p">[</span><span class="n">softplus</span><span class="p">(</span><span class="n">zi</span><span class="p">)</span> <span class="k">for</span> <span class="n">zi</span> <span class="ow">in</span> <span class="n">z</span><span class="p">]</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">s_accum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">):</span>
        <span class="n">s_accum</span> <span class="o">+=</span> <span class="n">inc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">u</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s_accum</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">u</span>

<span class="c1"># ---------------------------</span>
<span class="c1"># Black-box optimization (SPSA) of the schedule u[0:K]</span>
<span class="c1"># ---------------------------</span>
<span class="k">def</span> <span class="nf">spsa_optimize</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c1"># Initialize a conservative schedule (small linear backoff)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.2</span>      <span class="c1"># learning rate</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="mf">0.1</span>         <span class="c1"># perturbation scale</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">iters</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mf">0.101</span><span class="p">)</span>
        <span class="c1"># Rademacher perturbation</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
        <span class="n">u_plus</span>  <span class="o">=</span> <span class="p">[</span><span class="n">clamp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
        <span class="n">u_minus</span> <span class="o">=</span> <span class="p">[</span><span class="n">clamp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>

        <span class="n">Jp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u_plus</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Jm</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u_minus</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">t</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># SPSA gradient estimate</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">[(</span><span class="n">Jp</span> <span class="o">-</span> <span class="n">Jm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">c</span> <span class="o">*</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
        <span class="c1"># Update (project back to bounds)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="p">[</span><span class="n">clamp</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">g</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">u</span>

<span class="c1"># ---------- SPSA over 2 parameters (base, gamma) with CRN ----------</span>
<span class="k">def</span> <span class="nf">spsa_optimize_exp</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nmc</span><span class="o">=</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="c1"># fixed seeds reused every iteration (CRN)</span>
    <span class="n">seeds</span> <span class="o">=</span> <span class="p">[</span><span class="n">seed</span> <span class="o">+</span> <span class="mi">1000</span> <span class="o">+</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Nmc</span><span class="p">)]</span>

    <span class="c1"># init: small base, mild growth</span>
    <span class="n">base</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">1.4</span>
    <span class="n">alpha0</span><span class="p">,</span> <span class="n">c0</span> <span class="o">=</span> <span class="mf">0.15</span><span class="p">,</span> <span class="mf">0.2</span>  <span class="c1"># learning rate and perturbation scales</span>

    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">iters</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">a_t</span> <span class="o">=</span> <span class="n">alpha0</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mf">0.602</span><span class="p">)</span>   <span class="c1"># standard SPSA decay</span>
        <span class="n">c_t</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">/</span> <span class="p">(</span><span class="n">t</span> <span class="o">**</span> <span class="mf">0.101</span><span class="p">)</span>

        <span class="c1"># Rademacher perturbations for 2 params</span>
        <span class="n">d_base</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.0</span>
        <span class="n">d_gamma</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="n">base_plus</span>  <span class="o">=</span> <span class="n">base</span>  <span class="o">+</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_base</span>
        <span class="n">base_minus</span> <span class="o">=</span> <span class="n">base</span>  <span class="o">-</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_base</span>
        <span class="n">gamma_plus</span>  <span class="o">=</span> <span class="n">gamma</span> <span class="o">+</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_gamma</span>
        <span class="n">gamma_minus</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_gamma</span>

        <span class="n">u_plus</span>  <span class="o">=</span> <span class="n">project_waits</span><span class="p">(</span><span class="n">schedule_exp</span><span class="p">(</span><span class="n">base_plus</span><span class="p">,</span>  <span class="n">gamma_plus</span><span class="p">,</span>  <span class="n">K</span><span class="p">))</span>
        <span class="n">u_minus</span> <span class="o">=</span> <span class="n">project_waits</span><span class="p">(</span><span class="n">schedule_exp</span><span class="p">(</span><span class="n">base_minus</span><span class="p">,</span> <span class="n">gamma_minus</span><span class="p">,</span> <span class="n">K</span><span class="p">))</span>

        <span class="n">Jp</span> <span class="o">=</span> <span class="n">eval_policy</span><span class="p">(</span><span class="n">u_plus</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>
        <span class="n">Jm</span> <span class="o">=</span> <span class="n">eval_policy</span><span class="p">(</span><span class="n">u_minus</span><span class="p">,</span> <span class="n">seeds</span><span class="p">,</span> <span class="n">max_attempts</span><span class="o">=</span><span class="n">K</span><span class="p">)</span>

        <span class="c1"># SPSA gradient estimate</span>
        <span class="n">g_base</span>  <span class="o">=</span> <span class="p">(</span><span class="n">Jp</span> <span class="o">-</span> <span class="n">Jm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_base</span><span class="p">)</span>
        <span class="n">g_gamma</span> <span class="o">=</span> <span class="p">(</span><span class="n">Jp</span> <span class="o">-</span> <span class="n">Jm</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">c_t</span> <span class="o">*</span> <span class="n">d_gamma</span><span class="p">)</span>

        <span class="c1"># Update</span>
        <span class="n">base</span>  <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">base</span>  <span class="o">-</span> <span class="n">a_t</span> <span class="o">*</span> <span class="n">g_base</span><span class="p">)</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">gamma</span> <span class="o">-</span> <span class="n">a_t</span> <span class="o">*</span> <span class="n">g_gamma</span><span class="p">)</span>  <span class="c1"># keep reasonable</span>

    <span class="k">return</span> <span class="n">base</span><span class="p">,</span> <span class="n">gamma</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">K</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="c1"># Baseline linear schedule</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.05</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">K</span><span class="p">)]</span>
    <span class="n">J0</span><span class="p">,</span> <span class="n">s0</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">)</span>

    <span class="c1"># Optimize per-step waits (K-dim SPSA)</span>
    <span class="n">u_opt</span> <span class="o">=</span> <span class="n">spsa_optimize</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span>
    <span class="n">J1</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u_opt</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">999</span><span class="p">)</span>

    <span class="c1"># Optimize exponential schedule parameters (2-dim SPSA with CRN)</span>
    <span class="n">base_opt</span><span class="p">,</span> <span class="n">gamma_opt</span> <span class="o">=</span> <span class="n">spsa_optimize_exp</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="n">K</span><span class="p">,</span> <span class="n">iters</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">321</span><span class="p">,</span> <span class="n">Nmc</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>
    <span class="n">u_exp</span> <span class="o">=</span> <span class="n">project_waits</span><span class="p">(</span><span class="n">schedule_exp</span><span class="p">(</span><span class="n">base_opt</span><span class="p">,</span> <span class="n">gamma_opt</span><span class="p">,</span> <span class="n">K</span><span class="p">))</span>
    <span class="n">J2</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">rollout</span><span class="p">(</span><span class="n">u_exp</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">777</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial schedule:&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u0</span><span class="p">],</span> <span class="s2">&quot;  Cost ≈&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">J0</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized (per-step SPSA):&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u_opt</span><span class="p">],</span> <span class="s2">&quot;  Cost ≈&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">J1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimized (exp base, gamma): base=&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">base_opt</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="s2">&quot; gamma=&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">gamma_opt</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span>
          <span class="s2">&quot;  schedule=&quot;</span><span class="p">,</span> <span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">u_exp</span><span class="p">],</span> <span class="s2">&quot;  Cost ≈&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">J2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Attempts (init → per-step → exp):&quot;</span><span class="p">,</span> <span class="n">s0</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;→&quot;</span><span class="p">,</span> <span class="n">s1</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;→&quot;</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
          <span class="s2">&quot;  Success codes:&quot;</span><span class="p">,</span> <span class="n">s0</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">s1</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">s2</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial schedule: [0.05, 0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75]   Cost ≈ 0.029
Optimized (per-step SPSA): [2.855, 0.145, 0.094, 2.704, 0.092, 2.908, 2.704, 2.855]   Cost ≈ 1.433
Optimized (exp base, gamma): base= 0.192  gamma= 1.542   schedule= [0.192, 0.297, 0.458, 0.706, 1.09, 1.681, 2.592, 3.0]   Cost ≈ 1.365
Attempts (init → per-step → exp): 1 → 1 → 5   Success codes: 200 200 200
</pre></div>
</div>
</div>
</div>
</section>
<section id="example-gradient-descent-with-momentum-as-docp">
<h4>Example: Gradient Descent with Momentum as DOCP<a class="headerlink" href="#example-gradient-descent-with-momentum-as-docp" title="Link to this heading">#</a></h4>
<p>To connect this lens to familiar practice—and to hyperparameter optimization—treat the learning rate and momentum (or their schedules) as controls. Rather than fixing them a priori, we can optimize them as part of a trajectory optimization. The optimizer itself becomes the dynamical system whose execution we shape to minimize final loss.</p>
<p>Program: gradient descent with momentum on a quadratic loss. We fit <span class="math notranslate nohighlight">\(\boldsymbol{\theta}\in\mathbb{R}^p\)</span> to data <span class="math notranslate nohighlight">\((\mathbf{A},\mathbf{b})\)</span> by minimizing</p>
<div class="math notranslate nohighlight">
\[
\ell(\boldsymbol{\theta})=\tfrac{1}{2}\,\lVert\mathbf{A}\boldsymbol{\theta}-\mathbf{b}\rVert_2^2.
\]</div>
<p>The program maintains parameters <span class="math notranslate nohighlight">\(\boldsymbol{\theta}_k\)</span> and momentum <span class="math notranslate nohighlight">\(\mathbf{m}_k\)</span>. Each iteration does:</p>
<ol class="arabic simple">
<li><p>compute gradient <span class="math notranslate nohighlight">\( \mathbf{g}_k=\nabla_{\boldsymbol{\theta}}\ell(\boldsymbol{\theta}_k)=\mathbf{A}^\top(\mathbf{A}\boldsymbol{\theta}_k-\mathbf{b})\)</span></p></li>
<li><p>update momentum <span class="math notranslate nohighlight">\( \mathbf{m}_{k+1}=\beta_k \, \mathbf{m}_k + \mathbf{g}_k\)</span></p></li>
<li><p>update parameters <span class="math notranslate nohighlight">\( \boldsymbol{\theta}_{k+1}=\boldsymbol{\theta}_k - \alpha_k \, \mathbf{m}_{k+1}\)</span></p></li>
</ol>
<p>State, control, and transition. Define the state <span class="math notranslate nohighlight">\(\mathbf{x}_k=\begin{bmatrix}\boldsymbol{\theta}_k\\ \mathbf{m}_k\end{bmatrix}\in\mathbb{R}^{2p}\)</span> and the control <span class="math notranslate nohighlight">\(\mathbf{u}_k=\begin{bmatrix}\alpha_k\\ \beta_k\end{bmatrix}\)</span>. One program step is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\Phi_k(\mathbf{x}_k,\mathbf{u}_k)=
\begin{bmatrix}
\boldsymbol{\theta}_k - \alpha_k\!\left(\beta_k \, \mathbf{m}_k + \mathbf{A}^\top(\mathbf{A}\boldsymbol{\theta}_k-\mathbf{b})\right)\\[2mm]
\beta_k \, \mathbf{m}_k + \mathbf{A}^\top(\mathbf{A}\boldsymbol{\theta}_k-\mathbf{b})
\end{bmatrix}.
\end{split}\]</div>
<p>Executing the program for <span class="math notranslate nohighlight">\(T\)</span> iterations gives the trajectory</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{x}_{k+1}=\Phi_k(\mathbf{x}_k,\mathbf{u}_k),\quad k=0,\dots,T-1,\qquad
\mathbf{x}_0=\begin{bmatrix}\boldsymbol{\theta}_0\\ \mathbf{m}_0\end{bmatrix}.
\end{split}\]</div>
<p>Objective as a DOCP. Choose terminal cost <span class="math notranslate nohighlight">\(c_T(\mathbf{x}_T)=\ell(\boldsymbol{\theta}_T)\)</span> and (optionally) stage costs <span class="math notranslate nohighlight">\(c_k(\mathbf{x}_k,\mathbf{u}_k)=\rho_\alpha \, \alpha_k^2+\rho_\beta\,(\beta_k- \bar\beta)^2\)</span>. The program-as-control problem is</p>
<div class="math notranslate nohighlight">
\[
\min_{\{\alpha_k,\beta_k\}} \; \ell(\boldsymbol{\theta}_T)+\sum_{k=0}^{T-1}\big(\rho_\alpha \, \alpha_k^2+\rho_\beta\,(\beta_k-\bar\beta)^2\big)
\quad\text{s.t.}\quad \mathbf{x}_{k+1}=\Phi_k(\mathbf{x}_k,\mathbf{u}_k).
\]</div>
<p>Backpropagation = reverse-time costate recursion. Because <span class="math notranslate nohighlight">\(\Phi_k\)</span> is differentiable, reverse-mode AD computes <span class="math notranslate nohighlight">\(\nabla_{\mathbf{u}_{0:T-1}} \big(c_T+\sum c_k\big)\)</span> by propagating a costate <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}_k=\partial \mathcal{J}/\partial \mathbf{x}_k\)</span> backward:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\lambda}_T=\nabla_{\mathbf{x}_T} c_T,\qquad
\boldsymbol{\lambda}_k=\nabla_{\mathbf{x}_k} c_k + \left(\nabla_{\mathbf{x}_k}\Phi_k\right)^\top \boldsymbol{\lambda}_{k+1},
\]</div>
<p>and the gradients with respect to controls are</p>
<div class="math notranslate nohighlight">
\[
\nabla_{\mathbf{u}_k}\mathcal{J}=\nabla_{\mathbf{u}_k} c_k + \left(\nabla_{\mathbf{u}_k}\Phi_k\right)^\top \boldsymbol{\lambda}_{k+1}.
\]</div>
<p>Unrolling a tiny horizon (<span class="math notranslate nohighlight">\(T=3\)</span>) to see the composition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{x}_1&amp;=\Phi_0(\mathbf{x}_0,\mathbf{u}_0),\\
\mathbf{x}_2&amp;=\Phi_1(\mathbf{x}_1,\mathbf{u}_1),\\
\mathbf{x}_3&amp;=\Phi_2(\mathbf{x}_2,\mathbf{u}_2),\qquad
\mathcal{J}=c_T(\mathbf{x}_3)+\sum_{k=0}^{2} c_k(\mathbf{x}_k,\mathbf{u}_k).
\end{aligned}
\end{split}\]</div>
<p>What if the program branches? Suppose we insert a “skip-small-gradients” branch</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\theta}_{k+1}=\boldsymbol{\theta}_k - \alpha_k\,\mathbf{m}_{k+1}\,\mathbf{1}\{ \lVert\mathbf{g}_k\rVert&gt;\tau\},
\]</div>
<p>which is non-differentiable because of the indicator. The DOCP view still applies, but gradients are unreliable. Two practical paths: smooth the branch (e.g., replace <span class="math notranslate nohighlight">\(\mathbf{1}\{\cdot\}\)</span> with <span class="math notranslate nohighlight">\(\sigma((\lVert\mathbf{g}_k\rVert-\tau)/\epsilon)\)</span> for small <span class="math notranslate nohighlight">\(\epsilon\)</span>) and use autodiff; or go derivative-free on <span class="math notranslate nohighlight">\(\{\alpha_k,\beta_k,\tau\}\)</span> (e.g., SPSA or CMA-ES) while keeping the inner dynamics exact.</p>
</section>
</section>
<section id="variants-lagrange-and-mayer-problems">
<h3>Variants: Lagrange and Mayer Problems<a class="headerlink" href="#variants-lagrange-and-mayer-problems" title="Link to this heading">#</a></h3>
<p>The Bolza form is general enough to cover most situations, but two common special cases are worth noting:</p>
<ul class="simple">
<li><p><strong>Lagrange problem (no terminal cost)</strong>
If the objective only accumulates stage costs:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\min_{\mathbf{u}_{1:T-1}} \sum_{t=1}^{T-1} c_t(\mathbf{x}_t,\mathbf{u}_t).
\]</div>
<p>Example: <em>Energy minimization for a delivery drone</em>. The concern is total battery use, regardless of the final position.</p>
<ul class="simple">
<li><p><strong>Mayer problem (terminal cost only)</strong>
If the objective depends only on the final state:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\min_{\mathbf{u}_{1:T-1}} c_T(\mathbf{x}_T).
\]</div>
<p>Example: <em>Satellite orbital transfer</em>. The only goal is to reach a specified orbit, no matter the fuel spent along the way.</p>
<p>These distinctions matter when deriving optimality conditions, but conceptually they fit in the same framework: the system evolves over time, and we choose controls to shape the trajectory.</p>
</section>
<section id="reducing-to-mayer-form-by-state-augmentation">
<h3>Reducing to Mayer Form by State Augmentation<a class="headerlink" href="#reducing-to-mayer-form-by-state-augmentation" title="Link to this heading">#</a></h3>
<p>Although Bolza, Lagrange, and Mayer problems look different, they are equivalent in expressive power. Any problem with running costs can be rewritten as a Mayer problem (one whose objective depends only on the final state) through a simple trick: <strong>augment the state with a running sum of costs</strong>.</p>
<p>The idea is straightforward. Introduce a new variable, <span class="math notranslate nohighlight">\(y_t\)</span>, that keeps track of the cumulative cost so far. At each step, we update this running sum along with the system state:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\tilde{\mathbf{x}}_{t+1} =
\begin{pmatrix}
\mathbf{f}_t(\mathbf{x}_t,\mathbf{u}_t) \\
y_t + c_t(\mathbf{x}_t,\mathbf{u}_t)
\end{pmatrix},
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\mathbf{x}}_t = (\mathbf{x}_t, y_t)\)</span>. The terminal cost then becomes:</p>
<div class="math notranslate nohighlight">
\[
\tilde{c}_T(\tilde{\mathbf{x}}_T) = c_T(\mathbf{x}_T) + y_T.
\]</div>
<p>The overall effect is that the explicit sum <span class="math notranslate nohighlight">\(\sum_{t=1}^{T-1} c_t(\mathbf{x}_t,\mathbf{u}_t)\)</span> disappears from the objective and is captured implicitly by the augmented state. This lets us write every optimal control problem in Mayer form.</p>
<p>Why do this? Two reasons. First, it often simplifies <strong>mathematical derivations</strong>, as we will see later when deriving necessary conditions. Second, it can <strong>streamline algorithmic implementation</strong>: instead of writing separate code paths for Mayer, Lagrange, and Bolza problems, we can reduce everything to one canonical form. That said, this “one size fits all” approach isn’t always best in practice—specialized formulations can sometimes be more efficient computationally, especially when the running cost has simple structure.</p>
<p>The unifying theme is that a DOCP may look like a generic NLP on paper, but its structure matters. Ignoring that structure often leads to impractical solutions, whereas formulations that expose sparsity and respect temporal coupling allow modern solvers to scale effectively. In the following sections, we will examine how these choices play out in practice through single shooting, multiple shooting, and collocation methods, and why different formulations strike different trade-offs between robustness and computational effort.</p>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="numerical-methods-for-solving-docps">
<h1>Numerical Methods for Solving DOCPs<a class="headerlink" href="#numerical-methods-for-solving-docps" title="Link to this heading">#</a></h1>
<section id="simultaneous-methods">
<h2>Simultaneous Methods<a class="headerlink" href="#simultaneous-methods" title="Link to this heading">#</a></h2>
<p>Once a discrete-time optimal control problem (DOCP) has been formulated, the question becomes how to compute a solution.
If we collect all states and controls into a single vector <span class="math notranslate nohighlight">\(\mathbf{z}\)</span>, the problem can be written in the canonical form of a nonlinear program (NLP):</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; f(\mathbf{z}) \\
\text{subject to} \quad &amp; \mathbf{g}(\mathbf{z}) \le 0, \\
&amp; \mathbf{h}(\mathbf{z}) = 0,
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{h}\)</span> enforces the dynamics and <span class="math notranslate nohighlight">\(\mathbf{g}\)</span> encodes path or box constraints. Standard solvers such as IPOPT or SNOPT accept this formulation directly, which might suggest that trajectory optimization is simply a matter of handing the problem to a black box.</p>
<p>In practice, however, this simplicity is misleading. Optimal control problems have structural characteristics that make them considerably harder than generic nonlinear programs of comparable size. The number of variables grows with the planning horizon, since both states and controls appear explicitly. A horizon of length <span class="math notranslate nohighlight">\(T\)</span> with state dimension <span class="math notranslate nohighlight">\(n\)</span> and control dimension <span class="math notranslate nohighlight">\(m\)</span> already implies on the order of <span class="math notranslate nohighlight">\((T-1)(n+m)\)</span> decision variables. More importantly, these variables are tightly linked by the dynamics: each decision affects all subsequent states and costs. This temporal coupling means the feasible set is highly structured, and naive formulations that ignore this often lead to poor numerical conditioning and slow convergence.</p>
<p>These properties influence not only the difficulty of the problem but also the choice of algorithm. For instance, one approach is to collapse the problem to control inputs only and compute states by simulation; this single-shooting formulation eliminates equality constraints but introduces strong nonlinear dependencies on the controls, making the optimization sensitive to initial guesses. At the other extreme, methods such as multiple shooting or direct collocation retain states as explicit variables and enforce dynamics through constraints, leading to larger problems but with a sparsity structure that specialized solvers can exploit efficiently. The decision between these strategies is therefore not cosmetic: it determines whether the solver can take advantage of the problem’s structure.</p>
<p>The same logic applies when selecting an optimizer. For small-scale problems, it is common to rely on general-purpose routines such as those in <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code>. Derivative-free methods like Nelder–Mead require no gradients but scale poorly as dimensionality increases. Quasi-Newton schemes such as BFGS work well for moderate dimensions and can approximate gradients by finite differences, while large-scale trajectory optimization often calls for gradient-based constrained solvers such as interior-point or sequential quadratic programming methods that can exploit sparse Jacobians and benefit from automatic differentiation. Stochastic techniques, including genetic algorithms, simulated annealing, or particle swarm optimization, occasionally appear when gradients are unavailable, but their cost grows rapidly with dimension and they are rarely competitive for structured optimal control problems.</p>
<!-- ### On the Choice of Optimizer

Although the code example uses SLSQP, many alternatives exist. `scipy.optimize.minimize` provides a menu of options, and each has implications for speed, robustness, and scalability:

* **Derivative-free methods** such as Nelder–Mead avoid gradients altogether. They are attractive when gradients are unavailable or noisy, but they scale poorly with dimension.
* **Quasi-Newton methods** like BFGS approximate gradients by finite differences. They work well for moderate-scale problems and often outperform derivative-free schemes when the objective is smooth.
* **Gradient-based constrained solvers** such as interior-point or SQP methods exploit derivatives—exact or automatic—and are typically the most efficient for large structured problems like trajectory optimization.

Beyond these, **stochastic optimizers** occasionally appear in practice, especially when gradients are unreliable or the loss landscape is rugged. Random search is the simplest example, while genetic algorithms, simulated annealing, and particle swarm optimization introduce mechanisms for global exploration at the cost of significant computational effort.

Which method to choose depends on the context: problem size, availability of derivatives, and computational resources. When automatic differentiation is accessible, first-order methods like L-BFGS or Adam often dominate, particularly for single-shooting formulations where the objective is smooth and unconstrained except for simple bounds. This is why researchers with a machine learning background tend to gravitate toward these techniques: they integrate seamlessly with existing frameworks and run efficiently on GPUs. -->
<section id="example-direct-solution-to-the-eco-cruise-problem">
<h3>Example: Direct Solution to the Eco-cruise Problem<a class="headerlink" href="#example-direct-solution-to-the-eco-cruise-problem" title="Link to this heading">#</a></h3>
<p>Many modern vehicles include features that aim to improve energy efficiency without requiring extra effort from the driver. One such feature is Eco-Cruise. Unlike traditional cruise control, which keeps the car at a fixed speed regardless of conditions, Eco-Cruise adjusts speed within small margins to reduce energy consumption. The reasoning is straightforward: holding speed up a hill by applying full throttle uses more energy than allowing the car to slow slightly and regain speed later. Some systems go further by using map data, anticipating slopes and curves to plan ahead. These ideas are no longer experimental; several manufacturers already deploy predictive cruise systems based on navigation input.</p>
<p>The setup we will use is slightly idealized, but not unrealistic. It assumes that the driver provides a destination and an acceptable time target, something that most navigation systems already require. With that information, the controller can decide how fast to go and when to accelerate while ensuring the trip remains on schedule. Framing the problem in this way allows us to cast Eco-Cruise as a trajectory optimization exercise and to explore the structure of a discrete-time optimal control problem.</p>
<p>Consider a 1 km segment of road that must be completed in exactly 60 seconds. We divide this horizon into 60 steps of one second each. At step <span class="math notranslate nohighlight">\(t\)</span>, the state consists of the cumulative distance <span class="math notranslate nohighlight">\(s_t\)</span> and the speed <span class="math notranslate nohighlight">\(v_t\)</span>. The control input is the longitudinal acceleration <span class="math notranslate nohighlight">\(u_t\)</span>. With a time step of one second, the dynamics are written as</p>
<div class="math notranslate nohighlight">
\[
s_{t+1} = s_t + v_t, \qquad
v_{t+1} = v_t + u_t.
\]</div>
<p>The trip starts from rest, so <span class="math notranslate nohighlight">\(s_1 = 0\)</span> and <span class="math notranslate nohighlight">\(v_1 = 0\)</span>, and it must end at <span class="math notranslate nohighlight">\(s_{T+1} = 1000\)</span> m with <span class="math notranslate nohighlight">\(v_{T+1} = 0\)</span>.</p>
<p>Energy consumption depends on both acceleration and speed. Rather than model the details of rolling resistance, drivetrain losses, and aerodynamics, we adopt a simple quadratic approximation. Each stage incurs a cost</p>
<div class="math notranslate nohighlight">
\[
c_t(v_t, u_t) = \tfrac{1}{2}\beta u_t^2 + \tfrac{1}{2}\gamma v_t^2,
\]</div>
<p>where the first term penalizes strong accelerations and the second discourages high cruising speed. Reasonable values are <span class="math notranslate nohighlight">\(\beta = 1.0\)</span> and <span class="math notranslate nohighlight">\(\gamma = 0.1\)</span>. The objective is to minimize the sum of these stage costs across the horizon:</p>
<div class="math notranslate nohighlight">
\[
\min \sum_{t=1}^{T} \bigl( \tfrac{\beta}{2}u_t^2 + \tfrac{\gamma}{2}v_t^2 \bigr).
\]</div>
<p>The optimization must also respect physical limits. Speeds must remain between zero and <span class="math notranslate nohighlight">\(20\ \text{m/s}\)</span> (about 72 km/h), and accelerations are bounded by <span class="math notranslate nohighlight">\(|u_t| \le 3\ \text{m/s}^2\)</span> for comfort and safety.</p>
<p>The complete formulation is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{s_t,v_t,u_t\}} \ &amp; \sum_{t=1}^{T} \bigl( \tfrac{\beta}{2}u_t^2 + \tfrac{\gamma}{2}v_t^2 \bigr) \\
\text{subject to}\ &amp; s_{t+1}-s_t-v_t = 0,\ \ v_{t+1}-v_t-u_t = 0,\ t=1,\dots,T, \\
&amp; s_1 = 0,\ v_1 = 0,\ s_{T+1} = 1000,\ v_{T+1} = 0, \\
&amp; 0 \le v_t \le 20,\ \ |u_t|\le 3.
\end{aligned}
\end{split}\]</div>
<section id="solution">
<h4>Solution<a class="headerlink" href="#solution" title="Link to this heading">#</a></h4>
<p>Once the objective and constraints are expressed as Python functions, the problem can be passed to a generic optimizer with very little extra work. Here is a direct implementation using <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> with the SLSQP method:</p>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-0" name="sd-tab-set-0" type="radio">
<label class="sd-tab-label" for="sd-tab-item-0">
Visualization</label><div class="sd-tab-content docutils">
<script src="_static/iframe-modal.js"></script>
<div id="eco-cruise-container"></div>
<script>
createIframeModal({
  containerId: 'eco-cruise-container',
  iframeSrc: '_static/eco-cruise-demo.html',
  title: 'Eco-Cruise Optimization Visualization',
  aspectRatio: '200%',
  maxWidth: '1400px',
  maxHeight: '900px'
});
</script></div>
<input id="sd-tab-item-1" name="sd-tab-set-0" type="radio">
<label class="sd-tab-label" for="sd-tab-item-1">
Code</label><div class="sd-tab-content docutils">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">Bounds</span>

<span class="k">def</span> <span class="nf">solve_eco_cruise</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">v_max</span><span class="o">=</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">a_max</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve the eco-cruise optimization problem.&quot;&quot;&quot;</span>
    
    <span class="n">n_state</span><span class="p">,</span> <span class="n">n_control</span> <span class="o">=</span> <span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">T</span>
    
    <span class="k">def</span> <span class="nf">unpack</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="n">n_state</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">n_state</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">n_state</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n_state</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span>

    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dynamics</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="n">ceq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">T</span><span class="p">)</span>
        <span class="n">ceq</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># position dynamics</span>
        <span class="n">ceq</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">v</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span>        <span class="c1"># velocity dynamics</span>
        <span class="k">return</span> <span class="n">ceq</span>

    <span class="k">def</span> <span class="nf">boundary</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
        <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">distance</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># start/end conditions</span>

    <span class="c1"># Optimization setup</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">dynamics</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">boundary</span><span class="p">}]</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span>
        <span class="n">lb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_state</span><span class="p">,</span><span class="o">-</span><span class="mf">1e4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_state</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_control</span><span class="p">,</span><span class="o">-</span><span class="n">a_max</span><span class="p">)]),</span>
        <span class="n">ub</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_state</span><span class="p">,</span><span class="mf">1e4</span><span class="p">),</span> <span class="n">v_max</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_state</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_control</span><span class="p">,</span><span class="n">a_max</span><span class="p">)])</span>
    <span class="p">)</span>

    <span class="c1"># Initial guess: triangular velocity profile</span>
    <span class="n">accel_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">decel_time</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">T</span><span class="p">)</span>
    <span class="n">cruise_time</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">accel_time</span> <span class="o">-</span> <span class="n">decel_time</span>
    <span class="n">peak_v</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.2</span> <span class="o">*</span> <span class="n">distance</span><span class="o">/</span><span class="n">T</span><span class="p">,</span> <span class="mf">0.8</span> <span class="o">*</span> <span class="n">v_max</span><span class="p">)</span>
    
    <span class="n">v0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_state</span><span class="p">)</span>
    <span class="n">v0</span><span class="p">[:</span><span class="n">accel_time</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">peak_v</span><span class="p">,</span> <span class="n">accel_time</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">v0</span><span class="p">[</span><span class="n">accel_time</span><span class="p">:</span><span class="n">accel_time</span><span class="o">+</span><span class="n">cruise_time</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">peak_v</span>
    <span class="n">v0</span><span class="p">[</span><span class="n">accel_time</span><span class="o">+</span><span class="n">cruise_time</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">peak_v</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">decel_time</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">s0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]))</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">s0</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">s0</span><span class="p">,</span> <span class="n">v0</span> <span class="o">=</span> <span class="n">s0</span> <span class="o">*</span> <span class="n">scale</span><span class="p">,</span> <span class="n">v0</span> <span class="o">*</span> <span class="n">scale</span>
    <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">v0</span><span class="p">)</span>
    
    <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">s0</span><span class="p">,</span> <span class="n">v0</span><span class="p">,</span> <span class="n">u0</span><span class="p">])</span>
    
    <span class="c1"># Solve optimization</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solving eco-cruise optimization (β=</span><span class="si">{</span><span class="n">beta</span><span class="si">}</span><span class="s2">, γ=</span><span class="si">{</span><span class="n">gamma</span><span class="si">}</span><span class="s2">)...&quot;</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">z0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;SLSQP&quot;</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
                   <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;ftol&quot;</span><span class="p">:</span> <span class="mf">1e-9</span><span class="p">})</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">res</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization failed: </span><span class="si">{</span><span class="n">res</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
        
    <span class="n">s_opt</span><span class="p">,</span> <span class="n">v_opt</span><span class="p">,</span> <span class="n">u_opt</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
    
    <span class="c1"># Create trajectory data</span>
    <span class="n">eco_trajectory</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cumulative_energy</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">stage_cost</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">u_opt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">v_opt</span><span class="p">[</span><span class="n">t</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cumulative_energy</span> <span class="o">+=</span> <span class="n">stage_cost</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stage_cost</span> <span class="o">=</span> <span class="mi">0</span>
            
        <span class="n">eco_trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">s_opt</span><span class="p">[</span><span class="n">t</span><span class="p">]),</span> <span class="s2">&quot;velocity&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">v_opt</span><span class="p">[</span><span class="n">t</span><span class="p">]),</span>
            <span class="s2">&quot;acceleration&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">u_opt</span><span class="p">[</span><span class="n">t</span><span class="p">])</span> <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span> <span class="k">else</span> <span class="mf">0.0</span><span class="p">,</span>
            <span class="s2">&quot;stageCost&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">stage_cost</span><span class="p">),</span> <span class="s2">&quot;cumulativeEnergy&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cumulative_energy</span><span class="p">)</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s2">&quot;eco_trajectory&quot;</span><span class="p">:</span> <span class="n">eco_trajectory</span><span class="p">,</span>
        <span class="s2">&quot;total_energy&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cumulative_energy</span><span class="p">),</span>
        <span class="s2">&quot;optimization_success&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;beta&quot;</span><span class="p">:</span> <span class="n">beta</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">:</span> <span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="s2">&quot;v_max&quot;</span><span class="p">:</span> <span class="n">v_max</span><span class="p">,</span> <span class="s2">&quot;a_max&quot;</span><span class="p">:</span> <span class="n">a_max</span><span class="p">,</span> <span class="s2">&quot;distance&quot;</span><span class="p">:</span> <span class="n">distance</span><span class="p">}</span>
    <span class="p">}</span>

<span class="k">def</span> <span class="nf">generate_naive_trajectory</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate naive constant-speed trajectory for comparison.&quot;&quot;&quot;</span>
    
    <span class="c1"># Simple triangular profile: accelerate, cruise, decelerate</span>
    <span class="n">accel_time</span> <span class="o">=</span> <span class="n">decel_time</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">cruise_time</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">accel_time</span> <span class="o">-</span> <span class="n">decel_time</span>
    <span class="n">cruise_speed</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">accel_time</span> <span class="o">+</span> <span class="n">cruise_time</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">decel_time</span><span class="p">)</span>
    
    <span class="n">naive_trajectory</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">cumulative_energy</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">T</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">accel_time</span><span class="p">:</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="p">(</span><span class="n">cruise_speed</span> <span class="o">/</span> <span class="n">accel_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span>
            <span class="n">acceleration</span> <span class="o">=</span> <span class="n">cruise_speed</span> <span class="o">/</span> <span class="n">accel_time</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">accel_time</span> <span class="o">+</span> <span class="n">cruise_time</span><span class="p">:</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">cruise_speed</span>
            <span class="n">acceleration</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remaining_time</span> <span class="o">=</span> <span class="n">T</span> <span class="o">-</span> <span class="n">t</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="p">(</span><span class="n">cruise_speed</span> <span class="o">/</span> <span class="n">decel_time</span><span class="p">)</span> <span class="o">*</span> <span class="n">remaining_time</span>
            <span class="n">acceleration</span> <span class="o">=</span> <span class="o">-</span><span class="n">cruise_speed</span> <span class="o">/</span> <span class="n">decel_time</span>
        
        <span class="c1"># Calculate position by integration</span>
        <span class="n">position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">naive_trajectory</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;position&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">naive_trajectory</span><span class="p">[</span><span class="n">t</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;velocity&#39;</span><span class="p">]</span>
        
        <span class="c1"># Calculate costs</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">T</span><span class="p">:</span>
            <span class="n">stage_cost</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">acceleration</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">velocity</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">cumulative_energy</span> <span class="o">+=</span> <span class="n">stage_cost</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stage_cost</span> <span class="o">=</span> <span class="mf">0.0</span>
            
        <span class="n">naive_trajectory</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">position</span><span class="p">),</span> <span class="s2">&quot;velocity&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">velocity</span><span class="p">),</span>
            <span class="s2">&quot;acceleration&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">acceleration</span><span class="p">),</span> <span class="s2">&quot;stageCost&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">stage_cost</span><span class="p">),</span>
            <span class="s2">&quot;cumulativeEnergy&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cumulative_energy</span><span class="p">)</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;naive_trajectory&quot;</span><span class="p">:</span> <span class="n">naive_trajectory</span><span class="p">,</span> <span class="s2">&quot;total_energy&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">cumulative_energy</span><span class="p">)}</span>

<span class="k">def</span> <span class="nf">plot_comparison</span><span class="p">(</span><span class="n">eco_data</span><span class="p">,</span> <span class="n">naive_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create visualization plots comparing eco-cruise and naive trajectories.&quot;&quot;&quot;</span>
    
    <span class="n">eco_traj</span> <span class="o">=</span> <span class="n">eco_data</span><span class="p">[</span><span class="s1">&#39;eco_trajectory&#39;</span><span class="p">]</span>
    <span class="n">times</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    <span class="n">velocities</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;velocity&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    <span class="n">accelerations</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;acceleration&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    <span class="n">energy_costs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;stageCost&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    <span class="n">cumulative_energy</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;cumulativeEnergy&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">eco_traj</span><span class="p">]</span>
    
    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Eco-Cruise vs Naive Trajectory Comparison&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    
    <span class="c1"># Plot 1: Position vs Time</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naive_data</span><span class="p">:</span>
        <span class="n">naive_traj</span> <span class="o">=</span> <span class="n">naive_data</span><span class="p">[</span><span class="s1">&#39;naive_trajectory&#39;</span><span class="p">]</span>
        <span class="n">naive_times</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">]</span>
        <span class="n">naive_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">naive_times</span><span class="p">,</span> <span class="n">naive_positions</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Naive&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position (m)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Position vs Time&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 2: Velocity vs Time</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">velocities</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naive_data</span><span class="p">:</span>
        <span class="n">naive_velocities</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;velocity&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">naive_times</span><span class="p">,</span> <span class="n">naive_velocities</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Naive&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Velocity (m/s)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Velocity vs Time&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 3: Acceleration vs Time</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">accelerations</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Acceleration (m/s²)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Acceleration vs Time&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 4: Stage Cost vs Time</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">energy_costs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naive_data</span><span class="p">:</span>
        <span class="n">naive_costs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;stageCost&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">naive_times</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">naive_costs</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Naive&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Stage Cost&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stage Cost vs Time&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 5: Cumulative Energy vs Time</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">times</span><span class="p">,</span> <span class="n">cumulative_energy</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naive_data</span><span class="p">:</span>
        <span class="n">naive_cumulative</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;cumulativeEnergy&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">naive_times</span><span class="p">,</span> <span class="n">naive_cumulative</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Naive&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cumulative Energy&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Cumulative Energy vs Time&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="c1"># Plot 6: Phase Space (Velocity vs Position)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">velocities</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Eco-Cruise&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">naive_data</span><span class="p">:</span>
        <span class="n">naive_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;position&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">naive_traj</span><span class="p">]</span>
        <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">naive_positions</span><span class="p">,</span> <span class="n">naive_velocities</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Naive&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Position (m)&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Velocity (m/s)&#39;</span><span class="p">)</span>
    <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Phase Space: Velocity vs Position&#39;</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">save_plot</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;_static/eco_cruise_visualization.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Plot saved to _static/eco_cruise_visualization.png&quot;</span><span class="p">)</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">fig</span>

<span class="k">def</span> <span class="nf">demo</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run complete eco-cruise demonstration with visualization.&quot;&quot;&quot;</span>
    
    <span class="c1"># Solve optimization</span>
    <span class="n">eco_data</span> <span class="o">=</span> <span class="n">solve_eco_cruise</span><span class="p">(</span><span class="n">beta</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">eco_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Use Jupyter Book&#39;s gluing feature for error message</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">myst_nb</span> <span class="kn">import</span> <span class="n">glue</span>
            <span class="n">glue</span><span class="p">(</span><span class="s2">&quot;eco_cruise_output&quot;</span><span class="p">,</span> <span class="s2">&quot;❌ Optimization failed!&quot;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimization failed!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>
    
    <span class="c1"># Generate naive trajectory</span>
    <span class="n">naive_data</span> <span class="o">=</span> <span class="n">generate_naive_trajectory</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">1000.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
    
    <span class="c1"># Create visualization</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plot_comparison</span><span class="p">(</span><span class="n">eco_data</span><span class="p">,</span> <span class="n">naive_data</span><span class="p">,</span> <span class="n">save_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Use Jupyter Book&#39;s gluing feature to display the figure</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">myst_nb</span> <span class="kn">import</span> <span class="n">glue</span>
        <span class="n">glue</span><span class="p">(</span><span class="s2">&quot;eco_cruise_figure&quot;</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1"># Fallback for when not running in Jupyter Book context</span>
        <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">eco_data</span><span class="p">,</span> <span class="n">naive_data</span><span class="p">,</span> <span class="n">fig</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>The function <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> expect three things: an objective function that returns a scalar cost, a set of constraints grouped as equality or inequality functions, and bounds on individual variables. Everything else is about bookkeeping.</p>
<p>The first step is to gather all decision variables—positions, speeds, and accelerations—into a single vector <span class="math notranslate nohighlight">\(\mathbf{z}\)</span>. Helper routines like <code class="docutils literal notranslate"><span class="pre">unpack</span></code> then slice this vector back into its components so that the rest of the code reads naturally. The objective function mirrors the analytical form of the cost: it sums quadratic penalties on speeds and accelerations across the horizon.</p>
<p>Dynamics and boundary conditions appear as equality constraints. Each entry in <code class="docutils literal notranslate"><span class="pre">dynamics</span></code> enforces one of the discrete-time equations</p>
<div class="math notranslate nohighlight">
\[
s_{t+1} - s_t - v_t = 0,\qquad
v_{t+1} - v_t - u_t = 0,
\]</div>
<p>while <code class="docutils literal notranslate"><span class="pre">boundary</span></code> pins down the start and end conditions. Together, these ensure that any candidate solution corresponds to a physically consistent trajectory.</p>
<p>Bounds serve two purposes: they impose physical limits on speed and acceleration and keep the otherwise unbounded position variables within a large but finite range. This prevents the optimizer from exploring meaningless regions of the search space during intermediate iterations.</p>
<p>Finally, an initial guess is constructed by interpolating a straight line for the position, assigning a constant speed, and setting accelerations to zero. This is not intended to be optimal; it simply gives the solver a feasible starting point close enough to the constraint manifold to converge quickly.</p>
<p>Once these components are in place, the call to <code class="docutils literal notranslate"><span class="pre">minimize</span></code> does the rest. Internally, SLSQP linearizes the constraints, builds a quadratic subproblem, and iterates until both the Karush–Kuhn–Tucker conditions and the stopping tolerances are met. From the user’s perspective, the heavy lifting reduces to providing functions that compute costs and residuals—everything else is handled by the solver.</p>
</section>
</section>
</section>
<section id="sequential-methods">
<h2>Sequential Methods<a class="headerlink" href="#sequential-methods" title="Link to this heading">#</a></h2>
<p>The previous section showed how a discrete-time optimal control problem can be solved by treating all states and controls as decision variables and enforcing the dynamics as equality constraints. This produces a nonlinear program that can be passed to solvers such as <code class="docutils literal notranslate"><span class="pre">scipy.optimize.minimize</span></code> with the SLSQP method. For short horizons, this approach is straightforward and works well; the code stays close to the mathematical formulation.</p>
<p>It also has a real advantage: by keeping the states explicit and imposing the dynamics through constraints, we anchor the trajectory at multiple points. This extra structure helps stabilize the optimization, especially for long horizons where small deviations in early steps can otherwise propagate and cause the optimizer to drift or diverge. In that sense, this formulation is better conditioned and more robust than approaches that treat the dynamics implicitly.</p>
<p>The drawback is scale. As the horizon grows, the number of variables and constraints grows with it, and all are coupled by the dynamics. Each iteration of a sequential quadratic programming (SQP) or interior-point method requires building and factorizing large Jacobians and Hessians. These methods have been embedded in reinforcement learning and differentiable programming pipelines—through implicit layers or differentiable convex solvers—but the cost is significant. They remain serial, rely on repeated linear algebra factorizations, and are difficult to parallelize efficiently. When thousands of such problems must be solved inside a learning loop, the overhead becomes prohibitive.</p>
<p>This motivates an alternative that aligns better with the computational model of machine learning. If the dynamics are deterministic and state constraints are absent (or reducible to simple bounds on controls), we can eliminate the equality constraints altogether by making the states implicit. Instead of solving for both states and controls, we fix the initial state and roll the system forward under a candidate control sequence. This is the essence of <strong>single shooting</strong>.</p>
<p>The term “shooting” comes from the idea of <em>aiming and firing</em> a trajectory from the initial state: you pick a control sequence, integrate (or step) the system forward, and see where it lands. If the final state misses the target, you adjust the controls and try again—like adjusting the angle of a shot until it hits the mark. It is called <strong>single</strong> shooting because we compute the entire trajectory in one pass from the starting point, without breaking it into segments. Later, we will contrast this with <strong>multiple shooting</strong>, where the horizon is divided into smaller arcs that are optimized jointly to improve stability and conditioning.</p>
<p>The analogy with deep learning is also immediate: the control sequence plays the role of parameters, the rollout is a forward pass, and the cost is a scalar loss. Gradients can be obtained with reverse-mode automatic differentiation. In the single shooting formulation of the DOCP, the constrained program</p>
<div class="math notranslate nohighlight">
\[
\min_{\mathbf{x}_{1:T},\,\mathbf{u}_{1:T-1}} J(\mathbf{x}_{1:T},\mathbf{u}_{1:T-1})
\quad\text{s.t.}\quad 
\mathbf{x}_{t+1}=\mathbf{f}_t(\mathbf{x}_t,\mathbf{u}_t)
\]</div>
<p>collapses to</p>
<div class="math notranslate nohighlight">
\[
\min_{\mathbf{u}_{1:T-1}}\;
c_T\!\bigl(\boldsymbol{\phi}_{T}(\mathbf{u}, \mathbf{x}_1)\bigr)
+\sum_{t=1}^{T-1} c_t\!\bigl(\boldsymbol{\phi}_{t}(\mathbf{u}, \mathbf{x}_1), \mathbf{u}_t\bigr),
\qquad
\mathbf{u}_{\mathrm{lb}}\le\mathbf{u}_{t}\le\mathbf{u}_{\mathrm{ub}}.
\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_t\)</span> denotes the state reached at time <span class="math notranslate nohighlight">\(t\)</span> by recursively applying the dynamics to the previous state and current control. This recursion can be written as</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\phi}_{t+1}(\mathbf{u},\mathbf{x}_1)=
\mathbf{f}_{t}\!\bigl(\boldsymbol{\phi}_{t}(\mathbf{u},\mathbf{x}_1),\mathbf{u}_t\bigr),\qquad
\boldsymbol{\phi}_{1}=\mathbf{x}_1.
\]</div>
<p>Concretely, implementing this amounts to running a <strong>for loop</strong>—or, in frameworks like JAX or TensorFlow, using a <code class="docutils literal notranslate"><span class="pre">scan</span></code> operator. The pattern mirrors an RNN unroll: starting from an initial state ($\mathbf{x}<em>1$) and a sequence of controls ($\mathbf{u}</em>{1:T-1}$), we propagate forward through the dynamics, updating the state at each step and accumulating cost along the way. This structural similarity is why single shooting often feels natural to practitioners with a deep learning background: the rollout is a forward pass, and gradients propagate backward through time exactly as in backpropagation through an RNN.</p>
<p>Algorithmically:</p>
<div class="proof algorithm admonition" id="single-shooting-forward-unroll">
<p class="admonition-title"><span class="caption-number">Algorithm 1 </span> (Single Shooting: Forward Unroll)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Inputs</strong>: Initial state <span class="math notranslate nohighlight">\(\mathbf{x}_1\)</span>, horizon <span class="math notranslate nohighlight">\(T\)</span>, control bounds <span class="math notranslate nohighlight">\(\mathbf{u}_{\mathrm{lb}}, \mathbf{u}_{\mathrm{ub}}\)</span>, dynamics <span class="math notranslate nohighlight">\(\mathbf{f}_t\)</span>, costs <span class="math notranslate nohighlight">\(c_t\)</span></p>
<p><strong>Output</strong>: Optimal control sequence <span class="math notranslate nohighlight">\(\mathbf{u}^*_{1:T-1}\)</span></p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(\mathbf{u}_{1:T-1}\)</span> within bounds</p></li>
<li><p>Define <code class="docutils literal notranslate"><span class="pre">ComputeTrajectoryAndCost($\mathbf{u},</span> <span class="pre">\mathbf{x}_1$)</span></code>:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{x} \leftarrow \mathbf{x}_1\)</span>, <span class="math notranslate nohighlight">\(J \leftarrow 0\)</span></p></li>
<li><p>For <span class="math notranslate nohighlight">\(t = 1\)</span> to <span class="math notranslate nohighlight">\(T-1\)</span>:</p>
<ul>
<li><p><span class="math notranslate nohighlight">\(J \leftarrow J + c_t(\mathbf{x}, \mathbf{u}_t)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x} \leftarrow \mathbf{f}_t(\mathbf{x}, \mathbf{u}_t)\)</span></p></li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(J \leftarrow J + c_T(\mathbf{x})\)</span></p></li>
<li><p>Return <span class="math notranslate nohighlight">\(J\)</span></p></li>
</ul>
</li>
<li><p>Solve <span class="math notranslate nohighlight">\(\min_{\mathbf{u}} J(\mathbf{u})\)</span> subject to <span class="math notranslate nohighlight">\(\mathbf{u}_{\mathrm{lb}} \le \mathbf{u}_t \le \mathbf{u}_{\mathrm{ub}}\)</span></p></li>
<li><p>Return <span class="math notranslate nohighlight">\(\mathbf{u}^*_{1:T-1}\)</span></p></li>
</ol>
</section>
</div><p>In JAX or PyTorch, this loop can be JIT-compiled and differentiated automatically. Any gradient-based optimizer—L-BFGS, Adam, even SGD—can be applied, making the pipeline look very much like training a neural network. In effect, we are “backpropagating through the world model” when computing $\nabla J(\mathbf{u})$.</p>
<p>Single shooting is attractive for its simplicity and compatibility with differentiable programming, but it has limitations. The absence of intermediate constraints makes it sensitive to initialization and prone to numerical instability over long horizons. When state constraints or robustness matter, formulations that keep states explicit—such as multiple shooting or collocation—become preferable. These trade-offs are the focus of the next section.</p>
<!-- 
```{code-cell} ipython3
:tags: [hide-cell]
:mystnb:
:  code_prompt_show: "Show code demonstration"
:  code_prompt_hide: "Hide code demonstration"
:load: code/single_shooting_unrolled.py
``` -->
</section>
<section id="in-between-sequential-and-simultaneous">
<h2>In Between Sequential and Simultaneous<a class="headerlink" href="#in-between-sequential-and-simultaneous" title="Link to this heading">#</a></h2>
<p>The two formulations we have seen so far lie at opposite ends. The <strong>direct NLP approach</strong> keeps every state explicit and enforces the dynamics through equality constraints, which makes the structure clear but leads to a large optimization problem. At the other end, <strong>single shooting</strong> removes these constraints by simulating forward from the initial state, leaving only the controls as decision variables. That makes the problem smaller, but it also introduces a long and highly nonlinear dependency from the first control to the last state.</p>
<p><strong>Multiple shooting</strong> sits in between. Instead of simulating the entire horizon in one shot, we divide it into smaller segments. For each segment, we keep its starting state as a decision variable and propagate forward using the dynamics for that segment. At the end, we enforce continuity by requiring that the simulated end state of one segment matches the decision variable for the next.</p>
<p>Formally, suppose the horizon of <span class="math notranslate nohighlight">\(T\)</span> steps is divided into <span class="math notranslate nohighlight">\(K\)</span> segments of length <span class="math notranslate nohighlight">\(L\)</span> (with <span class="math notranslate nohighlight">\(T = K \cdot L\)</span> for simplicity). We introduce:</p>
<ul class="simple">
<li><p>The controls for each step: <span class="math notranslate nohighlight">\(\mathbf{u}_{1:T-1}\)</span>.</p></li>
<li><p>The state at the start of each segment: <span class="math notranslate nohighlight">\(\mathbf{x}_1,\dots,\mathbf{x}_K\)</span>.</p></li>
</ul>
<p>Given <span class="math notranslate nohighlight">\(\mathbf{x}_k\)</span> and the controls in its segment, we compute the predicted terminal state by simulating forward:</p>
<div class="math notranslate nohighlight">
\[
\hat{\mathbf{x}}_{k+1} = \Phi(\mathbf{x}_k,\mathbf{u}_{\text{segment }k}),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Phi\)</span> represents <span class="math notranslate nohighlight">\(L\)</span> applications of the dynamics. Continuity constraints enforce:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1} - \hat{\mathbf{x}}_{k+1} = 0, \qquad k=1,\dots,K-1.
\]</div>
<p>The resulting nonlinear program looks like this:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{\mathbf{x}_k,\mathbf{u}_t\}} \quad &amp;
c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t,\mathbf{u}_t) \\
\text{subject to} \quad &amp;
\mathbf{x}_{k+1} - \Phi(\mathbf{x}_k,\mathbf{u}_{\text{segment }k}) = 0,\quad k = 1,\dots,K-1, \\
&amp; \mathbf{u}_{\mathrm{lb}} \le \mathbf{u}_t \le \mathbf{u}_{\mathrm{ub}}, \\
&amp; \text{boundary conditions on } \mathbf{x}_1 \text{ and } \mathbf{x}_K.
\end{aligned}
\end{split}\]</div>
<p>Compared to the full NLP, we no longer introduce every intermediate state as a variable—only the anchors at segment boundaries. Inside each segment, states are reconstructed by simulation. Compared to single shooting, these anchors break the long dependency chain that makes optimization unstable: gradients only have to travel across <span class="math notranslate nohighlight">\(L\)</span> steps before they hit a decision variable, rather than the entire horizon. This is the same reason why exploding or vanishing gradients appear in deep recurrent networks: when the chain is too long, information either dies out or blows up. Multiple shooting shortens the chain and improves conditioning.</p>
<p>By adjusting the number of segments <span class="math notranslate nohighlight">\(K\)</span>, we can interpolate between the two extremes: <span class="math notranslate nohighlight">\(K = 1\)</span> gives single shooting, while <span class="math notranslate nohighlight">\(K = T\)</span> recovers the full direct NLP. In practice, a moderate number of segments often strikes a good balance between robustness and complexity.</p>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;✓ Generated trajectory data for K = 1,2,3,4,5,6,7,8 segments\n✓ Output written to: multiple_shooting_data.json\n✓ File size: 1467.5 KB&#39;
</pre></div>
</div>
<div class="sd-tab-set docutils">
<input checked="checked" id="sd-tab-item-2" name="sd-tab-set-1" type="radio">
<label class="sd-tab-label" for="sd-tab-item-2">
Visualization</label><div class="sd-tab-content docutils">
<script src="_static/iframe-modal.js"></script>
<div id="multiple-shooting-container"></div>
<script>
createIframeModal({
  containerId: 'multiple-shooting-container',
  iframeSrc: '_static/multiple-shooting-demo.html',
  title: 'Multiple Shooting Visualization',
  aspectRatio: '150%',
  maxWidth: '1400px',
  maxHeight: '900px'
});
</script></div>
<input id="sd-tab-item-3" name="sd-tab-set-1" type="radio">
<label class="sd-tab-label" for="sd-tab-item-3">
Code</label><div class="sd-tab-content docutils">
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">argparse</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">opt</span>

<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Helpers</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">population_dynamics_trajectory</span><span class="p">(</span><span class="n">num_points</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
                                   <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span>
                                   <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span>
                                   <span class="n">margin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a population trajectory using logistic growth with harvesting.</span>
<span class="sd">    </span>
<span class="sd">    Uses discrete-time population dynamics:</span>
<span class="sd">    pop[t+1] = pop[t] + growth_rate * pop[t] * (1 - pop[t]/carrying_capacity) - harvest[t]</span>
<span class="sd">    </span>
<span class="sd">    This creates a realistic trajectory where population grows then declines due to harvesting,</span>
<span class="sd">    demonstrating true discrete-time dynamics rather than just a mathematical spline.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Time grid</span>
    <span class="n">t_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="n">margin</span> <span class="o">+</span> <span class="n">t_grid</span> <span class="o">*</span> <span class="p">(</span><span class="n">width</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span><span class="p">)</span>
    
    <span class="c1"># Population dynamics parameters</span>
    <span class="n">carrying_capacity</span> <span class="o">=</span> <span class="mf">1000.0</span>  <span class="c1"># Maximum sustainable population</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="mf">0.15</span>          <span class="c1"># Intrinsic growth rate</span>
    <span class="n">initial_pop</span> <span class="o">=</span> <span class="mf">50.0</span>          <span class="c1"># Starting population</span>
    
    <span class="c1"># Create a varying harvest strategy that initially allows growth, then increases</span>
    <span class="n">harvest_rates</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">40</span> <span class="o">*</span> <span class="n">t_grid</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t_grid</span><span class="p">)</span> <span class="o">*</span> <span class="n">t_grid</span>
    
    <span class="c1"># Simulate population dynamics</span>
    <span class="n">populations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_points</span><span class="p">)</span>
    <span class="n">populations</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_pop</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_points</span><span class="p">):</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">populations</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">harvest</span> <span class="o">=</span> <span class="n">harvest_rates</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># Logistic growth with harvesting</span>
        <span class="n">growth</span> <span class="o">=</span> <span class="n">growth_rate</span> <span class="o">*</span> <span class="n">pop</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pop</span> <span class="o">/</span> <span class="n">carrying_capacity</span><span class="p">)</span>
        <span class="n">new_pop</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">growth</span> <span class="o">-</span> <span class="n">harvest</span>
        
        <span class="c1"># Ensure population doesn&#39;t go negative</span>
        <span class="n">populations</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">new_pop</span><span class="p">)</span>
    
    <span class="c1"># Convert to screen coordinates (flip y-axis, scale to fit)</span>
    <span class="n">max_pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">populations</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">carrying_capacity</span> <span class="o">*</span> <span class="mf">0.8</span><span class="p">)</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">50</span> <span class="o">-</span> <span class="p">(</span><span class="n">populations</span> <span class="o">/</span> <span class="n">max_pop</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">100</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xs</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">ys</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">solve_optimal_harvest_problem</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Solve the optimal harvesting problem once to get the TRUE optimal solution.</span>
<span class="sd">    </span>
<span class="sd">    Problem: Maximize total harvest while ensuring population doesn&#39;t go extinct.</span>
<span class="sd">    This gives us the reference solution that multiple shooting should converge to.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
    
    <span class="c1"># Population dynamics parameters</span>
    <span class="n">carrying_capacity</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="mf">0.12</span>
    <span class="n">initial_population</span> <span class="o">=</span> <span class="mf">100.0</span>
    <span class="n">extinction_threshold</span> <span class="o">=</span> <span class="mf">10.0</span>
    
    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">harvest_rates</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimize negative total harvest (i.e., maximize harvest)&quot;&quot;&quot;</span>
        <span class="n">populations</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_population</span><span class="p">]</span>
        <span class="n">total_harvest</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">harvest</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">harvest_rates</span><span class="p">):</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="n">populations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">growth</span> <span class="o">=</span> <span class="n">growth_rate</span> <span class="o">*</span> <span class="n">pop</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pop</span> <span class="o">/</span> <span class="n">carrying_capacity</span><span class="p">)</span>
            <span class="n">new_pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">growth</span> <span class="o">-</span> <span class="n">harvest</span><span class="p">)</span>
            <span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span>
            <span class="n">total_harvest</span> <span class="o">+=</span> <span class="n">harvest</span>
        
        <span class="c1"># Heavy penalty if population goes extinct</span>
        <span class="n">final_pop</span> <span class="o">=</span> <span class="n">populations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">extinction_penalty</span> <span class="o">=</span> <span class="mi">1000</span> <span class="k">if</span> <span class="n">final_pop</span> <span class="o">&lt;</span> <span class="n">extinction_threshold</span> <span class="k">else</span> <span class="mi">0</span>
        
        <span class="k">return</span> <span class="o">-</span><span class="n">total_harvest</span> <span class="o">+</span> <span class="n">extinction_penalty</span>  <span class="c1"># Minimize negative harvest</span>
    
    <span class="c1"># Optimize harvest rates</span>
    <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">)</span>  <span class="c1"># Conservative initial harvest</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">total_time_steps</span><span class="p">)]</span>  <span class="c1"># Harvest between 0-100</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;L-BFGS-B&#39;</span><span class="p">)</span>
    <span class="n">optimal_harvests</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span>
    
    <span class="c1"># Simulate with optimal harvest rates</span>
    <span class="n">populations</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_population</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">harvest</span> <span class="ow">in</span> <span class="n">optimal_harvests</span><span class="p">:</span>
        <span class="n">pop</span> <span class="o">=</span> <span class="n">populations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">growth</span> <span class="o">=</span> <span class="n">growth_rate</span> <span class="o">*</span> <span class="n">pop</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pop</span> <span class="o">/</span> <span class="n">carrying_capacity</span><span class="p">)</span>
        <span class="n">new_pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">growth</span> <span class="o">-</span> <span class="n">harvest</span><span class="p">)</span>
        <span class="n">populations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_pop</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">populations</span><span class="p">,</span> <span class="n">optimal_harvests</span>


<span class="k">def</span> <span class="nf">generate_population_segments</span><span class="p">(</span><span class="n">num_segments</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> 
                                <span class="n">width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">800</span><span class="p">,</span> 
                                <span class="n">height</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span> 
                                <span class="n">margin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
                                <span class="n">steps_per_segment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate segments that approximate the optimal harvest solution.</span>
<span class="sd">    </span>
<span class="sd">    This creates the TRUE multiple shooting problem: different K values should</span>
<span class="sd">    converge to the same optimal solution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">total_steps</span> <span class="o">=</span> <span class="n">num_segments</span> <span class="o">*</span> <span class="n">steps_per_segment</span>
    
    <span class="c1"># Get the optimal solution</span>
    <span class="n">optimal_populations</span><span class="p">,</span> <span class="n">optimal_harvests</span> <span class="o">=</span> <span class="n">solve_optimal_harvest_problem</span><span class="p">(</span><span class="n">total_steps</span><span class="p">)</span>
    
    <span class="c1"># Screen layout</span>
    <span class="n">total_width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span>
    <span class="n">segment_width</span> <span class="o">=</span> <span class="n">total_width</span> <span class="o">/</span> <span class="n">num_segments</span>
    
    <span class="n">segments</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Create segments from the optimal solution</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_segments</span><span class="p">):</span>
        <span class="n">segment_points</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Time coordinates for this segment</span>
        <span class="n">start_x</span> <span class="o">=</span> <span class="n">margin</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">segment_width</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start_x</span><span class="p">,</span> <span class="n">start_x</span> <span class="o">+</span> <span class="n">segment_width</span><span class="p">,</span> <span class="n">steps_per_segment</span><span class="p">)</span>
        
        <span class="c1"># Extract populations for this segment from optimal solution</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">steps_per_segment</span>
        <span class="n">end_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">steps_per_segment</span>
        <span class="n">segment_populations</span> <span class="o">=</span> <span class="n">optimal_populations</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
        
        <span class="c1"># Ensure we have enough points</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_populations</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">steps_per_segment</span><span class="p">:</span>
            <span class="c1"># Pad with the last population if needed</span>
            <span class="n">last_pop</span> <span class="o">=</span> <span class="n">segment_populations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">segment_populations</span> <span class="k">else</span> <span class="n">optimal_populations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">segment_populations</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">last_pop</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">steps_per_segment</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">segment_populations</span><span class="p">)))</span>
        
        <span class="c1"># Convert to screen coordinates with better bounds</span>
        <span class="n">min_pop</span><span class="p">,</span> <span class="n">max_pop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">optimal_populations</span><span class="p">))</span>
        <span class="n">pop_range</span> <span class="o">=</span> <span class="n">max_pop</span> <span class="o">-</span> <span class="n">min_pop</span>
        
        <span class="n">ys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pop</span> <span class="ow">in</span> <span class="n">segment_populations</span><span class="p">:</span>
            <span class="c1"># Map population to screen coordinates (ensuring visibility)</span>
            <span class="n">y_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">pop</span> <span class="o">-</span> <span class="n">min_pop</span><span class="p">)</span> <span class="o">/</span> <span class="n">pop_range</span> <span class="k">if</span> <span class="n">pop_range</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">y_frac</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span>
            <span class="n">ys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># Create segment points</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="n">segment_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        
        <span class="n">segments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment_points</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">segments</span>


<span class="k">def</span> <span class="nf">segment_points</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">num_segments</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Legacy function - now calls the new population dynamics generator.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">generate_population_segments</span><span class="p">(</span><span class="n">num_segments</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">add_population_perturbations</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="n">max_offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">60.0</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns a deep copy of *segments* where each segment k&gt;0 has its initial </span>
<span class="sd">    population (multiple shooting variable) perturbed, but the dynamics within </span>
<span class="sd">    each segment are re-simulated from that new starting point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">perturbed</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Population dynamics parameters (same as in optimization)</span>
    <span class="n">carrying_capacity</span> <span class="o">=</span> <span class="mf">1000.0</span>
    <span class="n">growth_rate</span> <span class="o">=</span> <span class="mf">0.12</span>
    
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">seg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Keep first segment unchanged</span>
            <span class="n">perturbed</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">y</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">originalY</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seg</span>
            <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Perturb the initial population for this segment</span>
            <span class="n">original_start_y</span> <span class="o">=</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">rng</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="n">max_offset</span><span class="p">,</span> <span class="n">max_offset</span><span class="p">)</span>
            <span class="n">new_start_y</span> <span class="o">=</span> <span class="n">original_start_y</span> <span class="o">+</span> <span class="n">offset</span>
            
            <span class="c1"># Convert back to population space to simulate dynamics</span>
            <span class="c1"># Reverse the screen coordinate transformation</span>
            <span class="n">height</span><span class="p">,</span> <span class="n">margin</span> <span class="o">=</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">50</span>
            <span class="n">y_frac</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">new_start_y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span>
            <span class="n">max_pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">800</span><span class="p">,</span> <span class="n">carrying_capacity</span><span class="p">)</span>
            <span class="n">perturbed_population</span> <span class="o">=</span> <span class="n">y_frac</span> <span class="o">*</span> <span class="n">max_pop</span>
            
            <span class="c1"># Re-simulate this segment with the perturbed initial population</span>
            <span class="n">perturbed_segment</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">perturbed_population</span><span class="p">)</span>  <span class="c1"># Ensure non-negative</span>
            
            <span class="c1"># Get harvest rate for this segment (simplified)</span>
            <span class="n">base_harvest</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">+</span> <span class="mi">10</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">segments</span><span class="p">))</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seg</span><span class="p">):</span>
                <span class="c1"># Use original x-coordinate</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">point</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
                
                <span class="c1"># Simulate one step if not the first point</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">harvest</span> <span class="o">=</span> <span class="n">base_harvest</span> <span class="o">+</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">i</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">seg</span><span class="p">))</span>
                    <span class="n">growth</span> <span class="o">=</span> <span class="n">growth_rate</span> <span class="o">*</span> <span class="n">pop</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pop</span> <span class="o">/</span> <span class="n">carrying_capacity</span><span class="p">)</span>
                    <span class="n">pop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pop</span> <span class="o">+</span> <span class="n">growth</span> <span class="o">-</span> <span class="n">harvest</span><span class="p">)</span>
                
                <span class="c1"># Convert back to screen coordinates</span>
                <span class="n">y_frac</span> <span class="o">=</span> <span class="n">pop</span> <span class="o">/</span> <span class="n">max_pop</span> <span class="k">if</span> <span class="n">max_pop</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">height</span> <span class="o">-</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">20</span> <span class="o">-</span> <span class="n">y_frac</span> <span class="o">*</span> <span class="p">(</span><span class="n">height</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">margin</span> <span class="o">-</span> <span class="mi">40</span><span class="p">)</span>
                
                <span class="n">perturbed_segment</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">originalY</span><span class="o">=</span><span class="n">point</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]))</span>
            
            <span class="n">perturbed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perturbed_segment</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">perturbed</span>


<span class="k">def</span> <span class="nf">optimize_offsets</span><span class="p">(</span><span class="n">true_segments</span><span class="p">,</span> <span class="n">initial_offsets</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run BFGS on the vertical offsets so that segment endpoints connect.</span>

<span class="sd">    Returns (opt_offsets, history) where *history* is a list of offset arrays</span>
<span class="sd">    captured at every solver iteration (including the initial guess and the</span>
<span class="sd">    final solution).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">K</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">true_segments</span><span class="p">)</span>

    <span class="c1"># Degenerate case: K == 1 (single shooting) – no defects to optimise.</span>
    <span class="k">if</span> <span class="n">K</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_offsets</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Simply return the initial offsets (normally all zeros) and a history</span>
        <span class="c1"># containing that single state so that the front-end animation logic</span>
        <span class="c1"># still works.</span>
        <span class="k">return</span> <span class="n">initial_offsets</span><span class="p">,</span> <span class="p">[</span><span class="n">initial_offsets</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

    <span class="c1"># Build arrays of the first + last y-coordinates for convenience</span>
    <span class="n">start_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">true_segments</span><span class="p">])</span>
    <span class="n">end_ys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">seg</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">true_segments</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">objective</span><span class="p">(</span><span class="n">vars_</span><span class="p">):</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">vars_</span><span class="p">))</span>  <span class="c1"># offset[0] fixed to 0</span>
        <span class="n">defects</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_ys</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="n">start_ys</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">defects</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Store history for visualisation</span>
    <span class="n">history</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">callback</span><span class="p">(</span><span class="n">vars_</span><span class="p">):</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">vars_</span><span class="p">))</span>
        <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offsets</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="c1"># Kick-start history with initial guess</span>
    <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">initial_offsets</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="n">res</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
        <span class="n">objective</span><span class="p">,</span>
        <span class="n">x0</span><span class="o">=</span><span class="n">initial_offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
        <span class="n">method</span><span class="o">=</span><span class="s2">&quot;BFGS&quot;</span><span class="p">,</span>
        <span class="n">callback</span><span class="o">=</span><span class="n">callback</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;gtol&quot;</span><span class="p">:</span> <span class="mf">1e-8</span><span class="p">,</span> <span class="s2">&quot;maxiter&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">}</span>
    <span class="p">)</span>

    <span class="n">opt_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">))</span>
    <span class="n">history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opt_offsets</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">opt_offsets</span><span class="p">,</span> <span class="n">history</span>

<span class="c1"># -----------------------------------------------------------------------------</span>
<span class="c1"># Main entry-point</span>
<span class="c1"># -----------------------------------------------------------------------------</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Handle Jupyter notebook context where sys.argv may contain kernel arguments</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    
    <span class="c1"># Check if we&#39;re in Jupyter by looking for various indicators</span>
    <span class="n">in_jupyter</span> <span class="o">=</span> <span class="p">(</span>
        <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;-f&#39;</span> <span class="ow">in</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="ow">or</span>  <span class="c1"># -f flag with temp file</span>
        <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;ipykernel_launcher&#39;</span> <span class="ow">in</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="ow">or</span>  <span class="c1"># launcher script</span>
        <span class="nb">any</span><span class="p">(</span><span class="s1">&#39;HistoryManager&#39;</span> <span class="ow">in</span> <span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="ow">or</span>  <span class="c1"># IPython args</span>
        <span class="s1">&#39;ipykernel_launcher.py&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Script name indicates Jupyter</span>
    <span class="p">)</span>
    
    <span class="k">if</span> <span class="n">in_jupyter</span><span class="p">:</span>
        <span class="c1"># Use default values when running in Jupyter</span>
        <span class="k">class</span> <span class="nc">DefaultArgs</span><span class="p">:</span>
            <span class="n">k_values</span> <span class="o">=</span> <span class="s2">&quot;1,2,3,4,5,6,7,8&quot;</span>
            <span class="n">num_points</span> <span class="o">=</span> <span class="mi">101</span>
            <span class="n">output</span> <span class="o">=</span> <span class="s2">&quot;_static/multiple_shooting_data.json&quot;</span>
            <span class="n">seed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">DefaultArgs</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Normal command-line parsing</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Generate multiple-shooting &quot;</span>
                                                     <span class="s2">&quot;trajectory data for the demo.&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--k_values&quot;</span><span class="p">,</span> <span class="s2">&quot;-K&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;1,2,3,4,5,6,7,8&quot;</span><span class="p">,</span>
                            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Comma-separated list of segment counts to precompute.&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--num_points&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span>
                            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Total number of points along the trajectory.&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--output&quot;</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;_static/multiple_shooting_data.json&quot;</span><span class="p">,</span>
                            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Path where the JSON file will be written.&quot;</span><span class="p">)</span>
        <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s2">&quot;--seed&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;RNG seed for the initial guess offsets.&quot;</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="c1"># Global continuous reference trajectory for comparison</span>
    <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">population_dynamics_trajectory</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">num_points</span><span class="p">)</span>
    <span class="n">continuous_trajectory</span> <span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)]</span>

    <span class="n">cases</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">k_str</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">k_values</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">k_str</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Generate segments with true population dynamics (not chopped from global trajectory)</span>
        <span class="n">true_segments</span> <span class="o">=</span> <span class="n">generate_population_segments</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">initial_guess_segments</span> <span class="o">=</span> <span class="n">add_population_perturbations</span><span class="p">(</span><span class="n">true_segments</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">seed</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>

        <span class="n">initial_offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">seg</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s2">&quot;originalY&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">initial_guess_segments</span><span class="p">])</span>
        <span class="n">opt_offsets</span><span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="n">optimize_offsets</span><span class="p">(</span><span class="n">true_segments</span><span class="p">,</span> <span class="n">initial_offsets</span><span class="p">)</span>

        <span class="n">optimization_steps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">offsets</span> <span class="ow">in</span> <span class="n">history</span><span class="p">:</span>
            <span class="n">iter_segments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">off</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">true_segments</span><span class="p">,</span> <span class="n">offsets</span><span class="p">):</span>
                <span class="n">iter_segments</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                    <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">,</span> <span class="s2">&quot;originalY&quot;</span><span class="p">:</span> <span class="n">p</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]}</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">seg</span>
                <span class="p">])</span>
            <span class="n">optimization_steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iter_segments</span><span class="p">)</span>

        <span class="n">cases</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;initial_guess&quot;</span><span class="p">:</span> <span class="n">initial_guess_segments</span><span class="p">,</span>
            <span class="s2">&quot;optimization_steps&quot;</span><span class="p">:</span> <span class="n">optimization_steps</span><span class="p">,</span>
            <span class="s2">&quot;solver_success&quot;</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="n">opt_offsets</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">}</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;continuous_trajectory&quot;</span><span class="p">:</span> <span class="n">continuous_trajectory</span><span class="p">,</span>  <span class="c1"># smooth reference trajectory</span>
        <span class="s2">&quot;cases&quot;</span><span class="p">:</span> <span class="n">cases</span>
    <span class="p">}</span>

    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">output</span><span class="p">)</span>
    <span class="n">output_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">with</span> <span class="n">output_path</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Use Jupyter Book&#39;s gluing feature to display output instead of print</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">myst_nb</span> <span class="kn">import</span> <span class="n">glue</span>
        <span class="n">glue</span><span class="p">(</span><span class="s2">&quot;multiple_shooting_output&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;✓ Generated trajectory data for K = </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">k_values</span><span class="si">}</span><span class="s2"> segments</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;✓ Output written to: </span><span class="si">{</span><span class="n">output_path</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
                                        <span class="sa">f</span><span class="s2">&quot;✓ File size: </span><span class="si">{</span><span class="n">output_path</span><span class="o">.</span><span class="n">stat</span><span class="p">()</span><span class="o">.</span><span class="n">st_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1024</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> KB&quot;</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="c1"># Fallback for when not running in Jupyter Book context</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;⟹ Wrote aggregated trajectory data to </span><span class="si">{</span><span class="n">output_path</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span> 
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="simulation.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Programs as Models</p>
      </div>
    </a>
    <a class="right-next"
       href="cocp.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Continuous-Time Trajectory Optimization</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Discrete-Time Trajectory Optimization</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discrete-time-optimal-control-problems-docps">Discrete-Time Optimal Control Problems (DOCPs)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#examples-of-docps">Examples of DOCPs</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#periodic-inventory-control">Periodic Inventory Control</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#end-of-day-portfolio-rebalancing">End-of-Day Portfolio Rebalancing</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#daily-ad-budget-allocation-with-carryover">Daily Ad-Budget Allocation with Carryover</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#docps-arising-from-the-discretization-of-continuous-time-ocps">DOCPs Arising from the Discretization of Continuous-Time OCPs</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#programs-as-docps-and-differentiable-programming">Programs as DOCPs and Differentiable Programming</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#example-http-retrier-optimization">Example: HTTP Retrier Optimization</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#example-gradient-descent-with-momentum-as-docp">Example: Gradient Descent with Momentum as DOCP</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#variants-lagrange-and-mayer-problems">Variants: Lagrange and Mayer Problems</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#reducing-to-mayer-form-by-state-augmentation">Reducing to Mayer Form by State Augmentation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#numerical-methods-for-solving-docps">Numerical Methods for Solving DOCPs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#simultaneous-methods">Simultaneous Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-direct-solution-to-the-eco-cruise-problem">Example: Direct Solution to the Eco-cruise Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#solution">Solution</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sequential-methods">Sequential Methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#in-between-sequential-and-simultaneous">In Between Sequential and Simultaneous</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pierre-Luc Bacon
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>