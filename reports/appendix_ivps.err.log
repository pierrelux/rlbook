Traceback (most recent call last):
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/pierre-luc.bacon/.local/share/uv/python/cpython-3.11.11-macos-aarch64-none/lib/python3.11/asyncio/base_events.py", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/Users/pierre-luc.bacon/Documents/rlbook/.venv/lib/python3.11/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
from scipy.optimize import root
import matplotlib.pyplot as plt

def ode_function(y, t):
    """Define the ODE: dy/dt = -y"""
    return -y

def solve_ode_collocation(ode_func, t_span, y0, order):
    t0, tf = t_span
    n_points = order + 1  # number of collocation points
    t_points = np.linspace(t0, tf, n_points)
    
    def collocation_residuals(coeffs):
        residuals = []
        # Initial condition residual
        y_init = sum(c * t_points[0]**i for i, c in enumerate(coeffs))
        residuals.append(y_init - y0)
        # Collocation point residuals
        for t in t_points[1:]:  # Skip the first point as it's used for initial condition
            y = sum(c * t**i for i, c in enumerate(coeffs))
            dy_dt = sum(c * i * t**(i-1) for i, c in enumerate(coeffs) if i > 0)
            residuals.append(dy_dt - ode_func(y, t))
        return residuals

    # Initial guess for coefficients
    initial_coeffs = [y0] + [0] * order

    # Solve the system of equations
    solution = root(collocation_residuals, initial_coeffs)
    
    if not solution.success:
        raise ValueError("Failed to converge to a solution.")

    coeffs = solution.x

    # Generate solution
    t_fine = np.linspace(t0, tf, 100)
    y_solution = sum(c * t_fine**i for i, c in enumerate(coeffs))

    return t_fine, y_solution, t_points, coeffs

# Example usage
t_span = (0, 2)
y0 = 1
orders = [1, 2, 3, 4, 5]  # Different polynomial orders to try

plt.figure(figsize=(12, 8))

for order in orders:
    t, y, t_collocation, coeffs = solve_ode_collocation(ode_function, t_span, y0, order)
    
    # Calculate y values at collocation points
    y_collocation = sum(c * t_collocation**i for i, c in enumerate(coeffs))
    
    # Plot the results
    plt.plot(t, y, label=f'Order {order}')
    plt.scatter(t_collocation, y_collocation, s=50, zorder=5)

# Plot the analytical solution
t_analytical = np.linspace(t_span[0], t_span[1], 100)
y_analytical = y0 * np.exp(-t_analytical)
plt.plot(t_analytical, y_analytical, 'k--', label='Analytical')

plt.xlabel('t')
plt.ylabel('y')
plt.title('ODE Solutions: dy/dt = -y, y(0) = 1')
plt.legend()
plt.grid(True)
plt.show()

# Print error for each order
print("Maximum absolute errors:")
for order in orders:
    t, y, _, _ = solve_ode_collocation(ode_function, t_span, y0, order)
    y_true = y0 * np.exp(-t)
    max_error = np.max(np.abs(y - y_true))
    print(f"Order {order}: {max_error:.6f}")
------------------


[31m---------------------------------------------------------------------------[39m
[31mValueError[39m                                Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[8][39m[32m, line 51[39m
[32m     48[39m plt.figure(figsize=([32m12[39m, [32m8[39m))
[32m     50[39m [38;5;28;01mfor[39;00m order [38;5;129;01min[39;00m orders:
[32m---> [39m[32m51[39m     t, y, t_collocation, coeffs = [43msolve_ode_collocation[49m[43m([49m[43mode_function[49m[43m,[49m[43m [49m[43mt_span[49m[43m,[49m[43m [49m[43my0[49m[43m,[49m[43m [49m[43morder[49m[43m)[49m
[32m     53[39m     [38;5;66;03m# Calculate y values at collocation points[39;00m
[32m     54[39m     y_collocation = [38;5;28msum[39m(c * t_collocation**i [38;5;28;01mfor[39;00m i, c [38;5;129;01min[39;00m [38;5;28menumerate[39m(coeffs))

[36mCell[39m[36m [39m[32mIn[8][39m[32m, line 33[39m, in [36msolve_ode_collocation[39m[34m(ode_func, t_span, y0, order)[39m
[32m     30[39m solution = root(collocation_residuals, initial_coeffs)
[32m     32[39m [38;5;28;01mif[39;00m [38;5;129;01mnot[39;00m solution.success:
[32m---> [39m[32m33[39m     [38;5;28;01mraise[39;00m [38;5;167;01mValueError[39;00m([33m"[39m[33mFailed to converge to a solution.[39m[33m"[39m)
[32m     35[39m coeffs = solution.x
[32m     37[39m [38;5;66;03m# Generate solution[39;00m

[31mValueError[39m: Failed to converge to a solution.

