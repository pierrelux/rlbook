<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Watershed Optimization Demo</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <script crossorigin src="https://unpkg.com/@react-three/fiber@8.9.1/dist/index.umd.js"></script>
    <script crossorigin src="https://unpkg.com/@react-three/drei@9.50.0/dist/index.umd.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
        /* Lucide icons replacement with simple CSS */
        .icon-play::before { content: "‚ñ∂"; }
        .icon-pause::before { content: "‚è∏"; }
        .icon-refresh::before { content: "‚Üª"; }
        .icon-leaf::before { content: "üåø"; }
        .icon-fish::before { content: "üêü"; }
        .icon-zap::before { content: "‚ö°"; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        const { Canvas, useFrame } = window.ReactThreeFiber;
        const { OrbitControls, Text, Html } = window.ReactThreeDrei;
        
        // Icon components (simplified)
        const Play = () => React.createElement('span', { className: 'icon-play' });
        const Pause = () => React.createElement('span', { className: 'icon-pause' });
        const RotateCcw = () => React.createElement('span', { className: 'icon-refresh' });
        const Leaf = ({ size = 24 }) => React.createElement('span', { className: 'icon-leaf', style: { fontSize: size } });
        const FishIcon = ({ size = 24 }) => React.createElement('span', { className: 'icon-fish', style: { fontSize: size } });
        const Zap = () => React.createElement('span', { className: 'icon-zap' });

        // Terrain component with height displacement
        const Terrain = () => {
          const meshRef = useRef();
          
          const { geometry, material } = useMemo(() => {
            const geo = new THREE.PlaneGeometry(20, 20, 64, 64);
            
            // Generate height displacement for mountainous terrain
            const positions = geo.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
              const x = positions[i];
              const y = positions[i + 1];
              
              // Create mountain ridges and valleys
              const height = Math.sin(x * 0.3) * Math.cos(y * 0.2) * 2 + 
                            Math.sin(x * 0.1) * 1.5 + 
                            Math.random() * 0.3;
              positions[i + 2] = height;
            }
            geo.computeVertexNormals();
            
            const mat = new THREE.MeshLambertMaterial({
              color: '#10b981',
              transparent: true,
              opacity: 0.8
            });
            
            return { geometry: geo, material: mat };
          }, []);

          return React.createElement('mesh', {
            ref: meshRef,
            geometry: geometry,
            material: material,
            'rotation-x': -Math.PI / 2,
            position: [0, -1, 0]
          });
        };

        // Water component with animated waves
        const Water = ({ level = 0 }) => {
          const meshRef = useRef();
          
          useFrame((state) => {
            if (meshRef.current) {
              meshRef.current.material.normalScale.set(
                0.1 + Math.sin(state.clock.elapsedTime) * 0.05,
                0.1 + Math.cos(state.clock.elapsedTime * 0.7) * 0.05
              );
            }
          });

          const material = useMemo(() => {
            const mat = new THREE.MeshPhongMaterial({
              color: '#3b82f6',
              transparent: true,
              opacity: 0.7,
            });
            mat.normalScale = new THREE.Vector2(0.1, 0.1);
            return mat;
          }, []);

          return React.createElement('mesh', {
            ref: meshRef,
            material: material,
            'rotation-x': -Math.PI / 2,
            position: [0, level, 0]
          }, React.createElement('planeGeometry', { args: [18, 18, 32, 32] }));
        };

        // Dam component
        const Dam = ({ position, name, ecologicalImpact, volume, maxVolume, power, onClick }) => {
          const meshRef = useRef();
          const [hovered, setHovered] = useState(false);
          
          const impactColor = ecologicalImpact === 'high' ? '#ef4444' : 
                             ecologicalImpact === 'moderate' ? '#f59e0b' : '#10b981';
          
          const fillLevel = volume / maxVolume;
          
          useFrame((state) => {
            if (meshRef.current) {
              meshRef.current.scale.y = 1 + (hovered ? 0.1 : 0);
            }
          });

          return React.createElement('group', { position },
            // Dam structure
            React.createElement('mesh', {
              ref: meshRef,
              onClick: onClick,
              onPointerOver: () => setHovered(true),
              onPointerOut: () => setHovered(false)
            },
              React.createElement('boxGeometry', { args: [1, 2, 0.3] }),
              React.createElement('meshLambertMaterial', { color: "#6b7280" })
            ),
            
            // Ecological status indicator
            React.createElement('mesh', { position: [0, 1.2, 0] },
              React.createElement('sphereGeometry', { args: [0.2] }),
              React.createElement('meshEmissiveMaterial', { color: impactColor })
            ),
            
            // Reservoir water
            React.createElement('mesh', { 
              position: [-2, 0, 0], 
              'rotation-x': -Math.PI / 2 
            },
              React.createElement('planeGeometry', { args: [3, 2] }),
              React.createElement('meshPhongMaterial', { 
                color: "#3b82f6", 
                transparent: true, 
                opacity: 0.3 + fillLevel * 0.4
              })
            ),
            
            // Power generation indicator
            power > 10 && React.createElement('mesh', { position: [0.8, 1, 0] },
              React.createElement('sphereGeometry', { args: [0.15] }),
              React.createElement('meshEmissiveMaterial', { color: "#fbbf24" })
            ),
            
            // Dam label
            React.createElement(Html, { position: [0, 2.5, 0], center: true },
              React.createElement('div', { 
                className: "bg-white/90 px-2 py-1 rounded text-xs font-semibold text-gray-800 shadow-lg" 
              }, name)
            ),
            
            hovered && React.createElement(Html, { position: [0, -1, 0], center: true },
              React.createElement('div', { 
                className: "bg-black/80 text-white px-3 py-2 rounded-lg text-sm" 
              },
                React.createElement('div', null, `Volume: ${volume.toFixed(1)}/${maxVolume} hm¬≥`),
                React.createElement('div', null, `Power: ${power.toFixed(0)} MW`),
                React.createElement('div', null, `Impact: ${ecologicalImpact}`)
              )
            )
          );
        };

        // Fish component
        const Fish = ({ position, health, moving, blocked }) => {
          const meshRef = useRef();
          const [swimOffset] = useState(() => Math.random() * Math.PI * 2);
          
          const healthColor = health > 0.7 ? '#10b981' : 
                             health > 0.4 ? '#f59e0b' : '#ef4444';
          
          useFrame((state) => {
            if (meshRef.current && moving) {
              const time = state.clock.elapsedTime;
              meshRef.current.position.x = position[0] + Math.sin(time + swimOffset) * 0.5;
              meshRef.current.position.z = position[2] + Math.cos(time * 0.7 + swimOffset) * 0.3;
              meshRef.current.rotation.y = Math.sin(time + swimOffset) * 0.3;
            }
          });

          return React.createElement('group', null,
            React.createElement('mesh', {
              ref: meshRef,
              position: position,
              scale: blocked ? [0.7, 0.7, 0.7] : [1, 1, 1]
            },
              React.createElement('sphereGeometry', { args: [0.15, 8, 6] }),
              React.createElement('meshLambertMaterial', { 
                color: healthColor, 
                opacity: health, 
                transparent: true 
              })
            ),
            
            blocked && React.createElement('mesh', { 
              position: [position[0], position[1] + 0.5, position[2]] 
            },
              React.createElement('sphereGeometry', { args: [0.1] }),
              React.createElement('meshEmissiveMaterial', { color: "#ef4444" })
            )
          );
        };

        // Vegetation component
        const Vegetation = ({ position, health, waterAccess }) => {
          const meshRef = useRef();
          
          const healthColor = health > 0.7 ? '#22c55e' : 
                             health > 0.4 ? '#eab308' : '#dc2626';
          
          useFrame((state) => {
            if (meshRef.current) {
              meshRef.current.rotation.z = Math.sin(state.clock.elapsedTime + position[0]) * 0.1;
            }
          });

          return React.createElement('group', { position },
            React.createElement('mesh', { ref: meshRef },
              React.createElement('coneGeometry', { args: [0.2, 0.8, 6] }),
              React.createElement('meshLambertMaterial', { 
                color: healthColor, 
                opacity: health, 
                transparent: true 
              })
            ),
            
            !waterAccess && React.createElement('mesh', { position: [0, 0.5, 0] },
              React.createElement('ringGeometry', { args: [0.3, 0.4] }),
              React.createElement('meshBasicMaterial', { 
                color: "#dc2626", 
                transparent: true, 
                opacity: 0.5 
              })
            )
          );
        };

        // Flow particles between dams
        const FlowParticles = ({ from, to, intensity }) => {
          const particlesRef = useRef();
          const particleCount = Math.ceil(intensity / 10);
          
          const positions = useMemo(() => {
            const pos = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
              const t = i / particleCount;
              pos[i * 3] = from[0] + (to[0] - from[0]) * t;
              pos[i * 3 + 1] = from[1] + (to[1] - from[1]) * t + Math.sin(t * Math.PI) * 0.5;
              pos[i * 3 + 2] = from[2] + (to[2] - from[2]) * t;
            }
            return pos;
          }, [from, to, particleCount]);
          
          useFrame((state) => {
            if (particlesRef.current) {
              const time = state.clock.elapsedTime;
              const positions = particlesRef.current.geometry.attributes.position.array;
              
              for (let i = 0; i < particleCount; i++) {
                const offset = (time + i * 0.1) % 1;
                positions[i * 3] = from[0] + (to[0] - from[0]) * offset;
                positions[i * 3 + 1] = from[1] + Math.sin(offset * Math.PI) * 0.3;
                positions[i * 3 + 2] = from[2] + (to[2] - from[2]) * offset;
              }
              particlesRef.current.geometry.attributes.position.needsUpdate = true;
            }
          });

          return React.createElement('points', { ref: particlesRef },
            React.createElement('bufferGeometry', null,
              React.createElement('bufferAttribute', {
                attach: "attributes-position",
                count: particleCount,
                array: positions,
                itemSize: 3
              })
            ),
            React.createElement('pointsMaterial', { color: "#60a5fa", size: 0.1 })
          );
        };

        // Main 3D scene component
        const HydroScene = ({ dams, ecosystemElements, selectedPolicy, showEcological }) => {
          return React.createElement(React.Fragment, null,
            // Lighting
            React.createElement('ambientLight', { intensity: 0.4 }),
            React.createElement('directionalLight', { 
              position: [10, 10, 5], 
              intensity: 0.8, 
              castShadow: true 
            }),
            React.createElement('directionalLight', { 
              position: [-10, 5, -5], 
              intensity: 0.3 
            }),
            
            // Terrain
            React.createElement(Terrain),
            
            // Water
            React.createElement(Water, { level: -0.5 }),
            
            // Dams
            ...dams.map((dam, idx) => 
              React.createElement(Dam, {
                key: dam.id,
                position: [(dam.x - 350) / 50, 0, (dam.y - 200) / 50],
                name: dam.name,
                ecologicalImpact: dam.ecologicalImpact,
                volume: dam.volume,
                maxVolume: dam.maxVolume,
                power: dam.power,
                onClick: () => console.log(`Clicked ${dam.name}`)
              })
            ),
            
            // Flow particles between dams
            ...dams.map((dam, idx) => {
              if (idx < dams.length - 1) {
                const nextDam = dams[idx + 1];
                return React.createElement(FlowParticles, {
                  key: `flow-${idx}`,
                  from: [(dam.x - 350) / 50, 0.5, (dam.y - 200) / 50],
                  to: [(nextDam.x - 350) / 50, 0.5, (nextDam.y - 200) / 50],
                  intensity: dam.outflow
                });
              }
              return null;
            }).filter(Boolean),
            
            // Ecosystem elements
            showEcological && ecosystemElements.map(element => {
              const pos = [(element.x - 350) / 50, 0.2, (element.y - 200) / 50];
              
              if (element.type === 'fish') {
                return React.createElement(Fish, {
                  key: element.id,
                  position: pos,
                  health: element.health,
                  moving: element.moving,
                  blocked: element.blocked
                });
              }
              
              if (element.type === 'vegetation') {
                return React.createElement(Vegetation, {
                  key: element.id,
                  position: pos,
                  health: element.health,
                  waterAccess: element.waterAccess
                });
              }
              
              return null;
            }).filter(Boolean),
            
            // Policy indicator
            React.createElement(Html, { position: [8, 3, 0], center: true },
              React.createElement('div', { 
                className: "bg-white/90 px-4 py-2 rounded-lg shadow-lg" 
              },
                React.createElement('div', { 
                  className: "text-sm font-semibold text-gray-800" 
                }, `Active Policy: ${selectedPolicy}`)
              )
            )
          );
        };

        // Main component
        const HydroPowerDemo = () => {
          const [isPlaying, setIsPlaying] = useState(false);
          const [currentTime, setCurrentTime] = useState(0);
          const [selectedPolicy, setSelectedPolicy] = useState('balanced');
          const [showEcological, setShowEcological] = useState(true);
          
          // Dam system state
          const [dams, setDams] = useState([
            {
              id: 'upstream',
              name: 'Lac Saint-Jean',
              x: 200, y: 150,
              volume: 75, maxVolume: 100, minVolume: 20,
              naturalInflow: 45,
              outflow: 30,
              power: 0,
              ecologicalImpact: 'moderate',
              fishPassage: true,
              sedimentTrap: 60
            },
            {
              id: 'middle',
              name: 'P√©ribonka Dam', 
              x: 380, y: 220,
              volume: 60, maxVolume: 85, minVolume: 15,
              naturalInflow: 25,
              outflow: 25,
              power: 0,
              ecologicalImpact: 'high',
              fishPassage: false,
              sedimentTrap: 80
            },
            {
              id: 'downstream',
              name: 'Saguenay Outlet',
              x: 520, y: 180,
              volume: 45, maxVolume: 70, minVolume: 10,
              naturalInflow: 20,
              outflow: 20,
              power: 0,
              ecologicalImpact: 'low',
              fishPassage: true,
              sedimentTrap: 30
            }
          ]);

          // Ecosystem elements
          const [ecosystemElements, setEcosystemElements] = useState([
            // Fish populations
            { id: 'fish1', type: 'fish', x: 150, y: 200, health: 0.9, moving: true, blocked: false },
            { id: 'fish2', type: 'fish', x: 250, y: 180, health: 0.7, moving: true, blocked: false },
            { id: 'fish3', type: 'fish', x: 350, y: 240, health: 0.6, moving: false, blocked: true },
            { id: 'fish4', type: 'fish', x: 450, y: 190, health: 0.8, moving: true, blocked: false },
            
            // Vegetation
            { id: 'veg1', type: 'vegetation', x: 120, y: 160, health: 0.9, waterAccess: true },
            { id: 'veg2', type: 'vegetation', x: 180, y: 140, health: 0.8, waterAccess: true },
            { id: 'veg3', type: 'vegetation', x: 320, y: 200, health: 0.4, waterAccess: false },
            { id: 'veg4', type: 'vegetation', x: 480, y: 170, health: 0.7, waterAccess: true }
          ]);

          const [ecosystemHealth, setEcosystemHealth] = useState({
            fishPopulation: 85,
            riparianVegetation: 90,
            waterQuality: 80,
            sedimentFlow: 70,
            floodplainConnectivity: 75
          });

          const policies = {
            economic: {
              name: "Pure Economic Optimization",
              color: "bg-red-600",
              description: "Maximize revenue, ignore ecological impact",
              ecologicalScore: 30,
              strategy: (dam, price) => dam.volume * 0.8
            },
            balanced: {
              name: "Balanced Policy", 
              color: "bg-green-600",
              description: "Balance profit with environmental constraints",
              ecologicalScore: 75,
              strategy: (dam, price, season) => dam.volume * (0.3 + 0.3 * (price / 100))
            },
            ecological: {
              name: "Eco-First Policy",
              color: "bg-blue-600", 
              description: "Prioritize natural flow patterns",
              ecologicalScore: 90,
              strategy: (dam, price, season) => Math.max(10, dam.naturalInflow * 0.8)
            }
          };

          // Animation loop
          useEffect(() => {
            if (!isPlaying) return;

            const interval = setInterval(() => {
              setCurrentTime(prev => prev + 1);
              
              // Update dam operations based on selected policy
              setDams(prevDams => {
                return prevDams.map(dam => {
                  const policy = policies[selectedPolicy];
                  const electricityPrice = 60 + Math.sin(currentTime * 0.1) * 30;
                  const season = Math.sin(currentTime * 0.05);
                  
                  const newOutflow = policy.strategy(dam, electricityPrice, season);
                  const powerOutput = newOutflow * (dam.volume / dam.maxVolume) * 3;
                  
                  // Calculate ecological impact
                  let impact = 'low';
                  if (newOutflow > dam.naturalInflow * 1.5) impact = 'high';
                  else if (newOutflow > dam.naturalInflow * 1.2) impact = 'moderate';
                  
                  return {
                    ...dam,
                    outflow: newOutflow,
                    power: powerOutput,
                    ecologicalImpact: impact,
                    volume: Math.max(dam.minVolume, 
                      Math.min(dam.maxVolume, 
                        dam.volume + (dam.naturalInflow - newOutflow) * 0.02 + (Math.random() - 0.5)
                      )
                    )
                  };
                });
              });

              // Update ecosystem health
              setEcosystemHealth(prev => {
                const policy = policies[selectedPolicy];
                const targetHealth = policy.ecologicalScore;
                
                return {
                  fishPopulation: prev.fishPopulation + (targetHealth - prev.fishPopulation) * 0.02,
                  riparianVegetation: prev.riparianVegetation + (targetHealth - prev.riparianVegetation) * 0.01,
                  waterQuality: prev.waterQuality + (targetHealth - prev.waterQuality) * 0.015,
                  sedimentFlow: prev.sedimentFlow + (targetHealth - prev.sedimentFlow) * 0.01,
                  floodplainConnectivity: prev.floodplainConnectivity + (targetHealth - prev.floodplainConnectivity) * 0.01
                };
              });

              // Update ecosystem elements
              setEcosystemElements(prev => prev.map(element => {
                if (element.type === 'fish') {
                  const nearbyDam = dams.find(dam => 
                    Math.abs(dam.x - element.x) < 100 && Math.abs(dam.y - element.y) < 50
                  );
                  
                  let blocked = false;
                  let healthDelta = 0;
                  
                  if (nearbyDam) {
                    blocked = !nearbyDam.fishPassage && nearbyDam.ecologicalImpact === 'high';
                    healthDelta = nearbyDam.ecologicalImpact === 'high' ? -0.002 : 
                                 nearbyDam.ecologicalImpact === 'moderate' ? -0.001 : 0.001;
                  }
                  
                  return {
                    ...element,
                    blocked,
                    health: Math.max(0.1, Math.min(1, element.health + healthDelta)),
                    moving: !blocked && element.health > 0.3
                  };
                }
                
                if (element.type === 'vegetation') {
                  const nearbyDam = dams.find(dam => 
                    Math.abs(dam.x - element.x) < 80 && Math.abs(dam.y - element.y) < 60
                  );
                  
                  let waterAccess = true;
                  let healthDelta = 0;
                  
                  if (nearbyDam && nearbyDam.volume < nearbyDam.minVolume + 10) {
                    waterAccess = false;
                    healthDelta = -0.003;
                  } else {
                    healthDelta = 0.001;
                  }
                  
                  return {
                    ...element,
                    waterAccess,
                    health: Math.max(0.1, Math.min(1, element.health + healthDelta))
                  };
                }
                
                return element;
              }));
              
            }, 100);

            return () => clearInterval(interval);
          }, [isPlaying, selectedPolicy, currentTime]);

          const reset = () => {
            setCurrentTime(0);
            setIsPlaying(false);
          };

          return React.createElement('div', {
            className: "w-full max-w-7xl mx-auto p-6 bg-gradient-to-br from-green-50 via-blue-50 to-green-100 min-h-screen"
          },
            // Header
            React.createElement('div', { className: "text-center mb-6" },
              React.createElement('h1', {
                className: "text-4xl font-bold text-gray-800 mb-2"
              }, "3D Watershed Optimization"),
              React.createElement('p', {
                className: "text-gray-600 text-lg max-w-3xl mx-auto"
              }, "Interactive 3D visualization of hydro-power operations and their ecological impact")
            ),

            // Controls
            React.createElement('div', {
              className: "bg-white/80 backdrop-blur rounded-2xl p-6 mb-6 shadow-lg border border-green-200"
            },
              React.createElement('div', {
                className: "flex justify-between items-center mb-6"
              },
                React.createElement('div', {
                  className: "flex items-center space-x-4"
                },
                  React.createElement('button', {
                    onClick: () => setIsPlaying(!isPlaying),
                    className: "flex items-center space-x-2 bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-xl transition-all duration-200 shadow-lg"
                  },
                    isPlaying ? React.createElement(Pause) : React.createElement(Play),
                    React.createElement('span', {
                      className: "font-semibold"
                    }, `${isPlaying ? 'Pause' : 'Start'} Simulation`)
                  ),
                  
                  React.createElement('button', {
                    onClick: reset,
                    className: "flex items-center space-x-2 bg-gray-600 hover:bg-gray-700 text-white px-4 py-3 rounded-xl transition-all duration-200"
                  },
                    React.createElement(RotateCcw),
                    React.createElement('span', null, "Reset")
                  ),

                  React.createElement('label', {
                    className: "flex items-center space-x-2 text-gray-700"
                  },
                    React.createElement('input', {
                      type: "checkbox",
                      checked: showEcological,
                      onChange: (e) => setShowEcological(e.target.checked),
                      className: "w-4 h-4 rounded"
                    }),
                    React.createElement('span', null, "Show Ecosystem")
                  )
                ),

                React.createElement('div', { className: "text-right" },
                  React.createElement('div', {
                    className: "text-sm text-gray-600"
                  }, "Simulation Time"),
                  React.createElement('div', {
                    className: "text-2xl font-bold text-gray-800"
                  }, `${Math.floor(currentTime / 10)} days`)
                )
              ),

              // Policy Selection
              React.createElement('div', { className: "grid grid-cols-3 gap-4" },
                Object.entries(policies).map(([key, policy]) =>
                  React.createElement('button', {
                    key: key,
                    onClick: () => setSelectedPolicy(key),
                    className: `p-4 rounded-xl border-2 transition-all duration-300 ${
                      selectedPolicy === key 
                        ? `${policy.color} text-white border-white shadow-lg scale-105` 
                        : 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:shadow-md'
                    }`
                  },
                    React.createElement('div', {
                      className: "font-bold text-lg"
                    }, policy.name),
                    React.createElement('div', {
                      className: "text-sm opacity-90 mt-1"
                    }, policy.description),
                    React.createElement('div', {
                      className: "text-xs mt-2 font-medium"
                    }, `Ecological Score: ${policy.ecologicalScore}/100`)
                  )
                )
              )
            ),

            // 3D Scene
            React.createElement('div', {
              className: "bg-white/60 backdrop-blur rounded-2xl shadow-xl border border-blue-200 h-96 mb-6"
            },
              React.createElement(Canvas, {
                camera: {
                  position: [10, 10, 10],
                  zoom: 50,
                  near: 0.1,
                  far: 1000
                }
              },
                React.createElement(OrbitControls, {
                  enablePan: true,
                  enableZoom: true,
                  enableRotate: true,
                  maxPolarAngle: Math.PI / 2,
                  minPolarAngle: 0
                }),
                
                React.createElement(HydroScene, {
                  dams: dams,
                  ecosystemElements: ecosystemElements,
                  selectedPolicy: selectedPolicy,
                  showEcological: showEcological
                })
              )
            ),

            // Ecosystem Health Dashboard
            showEcological && React.createElement('div', {
              className: "bg-white/80 backdrop-blur rounded-2xl p-6 shadow-lg border border-green-200"
            },
              React.createElement('h2', {
                className: "text-2xl font-bold mb-6 text-gray-800 flex items-center"
              },
                React.createElement(Leaf, { size: 28, className: "mr-3 text-green-600" }),
                "Ecosystem Health Indicators"
              ),
              
              React.createElement('div', { className: "grid grid-cols-5 gap-6" },
                Object.entries(ecosystemHealth).map(([key, value]) => {
                  const getColor = (val) => val > 70 ? 'text-green-600' : val > 40 ? 'text-yellow-600' : 'text-red-600';
                  const getBgColor = (val) => val > 70 ? 'bg-green-100' : val > 40 ? 'bg-yellow-100' : 'bg-red-100';
                  
                  const icons = {
                    fishPopulation: React.createElement(FishIcon, { size: 24 }),
                    riparianVegetation: React.createElement('div', { className: "w-6 h-6 bg-green-600 rounded-full" }),
                    waterQuality: React.createElement('div', { className: "w-6 h-6 bg-blue-600 rounded" }),
                    sedimentFlow: React.createElement('div', { className: "w-6 h-6 rounded-full bg-amber-600" }),
                    floodplainConnectivity: React.createElement('div', { className: "w-6 h-6 border-2 border-blue-600 rounded" })
                  };
                  
                  return React.createElement('div', {
                    key: key,
                    className: `p-4 rounded-xl ${getBgColor(value)} border border-gray-200`
                  },
                    React.createElement('div', {
                      className: `flex items-center justify-center mb-2 ${getColor(value)}`
                    }, icons[key]),
                    React.createElement('div', { className: "text-center" },
                      React.createElement('div', {
                        className: "text-sm text-gray-600 capitalize mb-1"
                      }, key.replace(/([A-Z])/g, ' $1').trim()),
                      React.createElement('div', {
                        className: `text-2xl font-bold ${getColor(value)}`
                      }, Math.round(value) + '%')
                    ),
                    
                    // Health bar
                    React.createElement('div', {
                      className: "w-full bg-gray-200 rounded-full h-2 mt-2"
                    },
                      React.createElement('div', {
                        className: `h-2 rounded-full transition-all duration-1000 ${
                          value > 70 ? 'bg-green-500' : value > 40 ? 'bg-yellow-500' : 'bg-red-500'
                        }`,
                        style: { width: `${value}%` }
                      })
                    )
                  );
                })
              )
            )
          );
        };

        // Render the app
        ReactDOM.render(React.createElement(HydroPowerDemo), document.getElementById('root'));
    </script>
</body>
</html> 