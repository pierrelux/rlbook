<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Watershed Optimization</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.150.0/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
        }
        .icon-play::before { content: "‚ñ∂"; }
        .icon-pause::before { content: "‚è∏"; }
        .icon-refresh::before { content: "‚Üª"; }
        .icon-leaf::before { content: "üåø"; }
        .icon-fish::before { content: "üêü"; }
        .icon-zap::before { content: "‚ö°"; }
        .three-container {
            width: 100%;
            height: 500px;
            border-radius: 16px;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;
        
        // Icon components
        const Play = () => React.createElement('span', { className: 'icon-play' });
        const Pause = () => React.createElement('span', { className: 'icon-pause' });
        const RotateCcw = () => React.createElement('span', { className: 'icon-refresh' });
        const Leaf = ({ size = 24 }) => React.createElement('span', { className: 'icon-leaf', style: { fontSize: size } });
        const FishIcon = ({ size = 24 }) => React.createElement('span', { className: 'icon-fish', style: { fontSize: size } });

        // Enhanced terrain generation utilities
        const NoiseGenerator = {
            // Simple implementation of improved noise
            noise2D: (x, y) => {
                let n = Math.sin(x * 12.9898 + y * 78.233) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            },
            
            // Smooth noise using interpolation
            smoothNoise: (x, y) => {
                const intX = Math.floor(x);
                const intY = Math.floor(y);
                const fracX = x - intX;
                const fracY = y - intY;
                
                const a = NoiseGenerator.noise2D(intX, intY);
                const b = NoiseGenerator.noise2D(intX + 1, intY);
                const c = NoiseGenerator.noise2D(intX, intY + 1);
                const d = NoiseGenerator.noise2D(intX + 1, intY + 1);
                
                const i1 = NoiseGenerator.lerp(a, b, fracX);
                const i2 = NoiseGenerator.lerp(c, d, fracX);
                
                return NoiseGenerator.lerp(i1, i2, fracY);
            },
            
            lerp: (a, b, t) => a + t * (b - a),
            
            // Multi-octave noise for realistic terrain
            fractalNoise: (x, y, octaves = 6) => {
                let value = 0;
                let amplitude = 1;
                let frequency = 0.01;
                let maxValue = 0;
                
                for (let i = 0; i < octaves; i++) {
                    value += NoiseGenerator.smoothNoise(x * frequency, y * frequency) * amplitude;
                    maxValue += amplitude;
                    amplitude *= 0.5;
                    frequency *= 2;
                }
                
                return value / maxValue;
            }
        };

        // Three.js scene component with enhanced terrain
        const EnhancedThreeScene = ({ dams, ecosystemElements, selectedPolicy, showEcological }) => {
          const mountRef = useRef(null);
          const sceneRef = useRef(null);
          const rendererRef = useRef(null);
          const cameraRef = useRef(null);
          const terrainMeshRef = useRef(null);
          const waterMeshRef = useRef(null);
          const damMeshesRef = useRef([]);
          const animationIdRef = useRef(null);
          
          useEffect(() => {
            if (!mountRef.current) return;

            // Scene setup
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 200);
            sceneRef.current = scene;

            // Camera setup - isometric-like view
            const camera = new THREE.PerspectiveCamera(45, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
            camera.position.set(25, 20, 25);
            camera.lookAt(0, 0, 0);
            cameraRef.current = camera;

            // Renderer setup
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x87CEEB, 1);
            rendererRef.current = renderer;
            mountRef.current.appendChild(renderer.domElement);

            // Enhanced lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(50, 50, 25);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;
            directionalLight.shadow.camera.left = -50;
            directionalLight.shadow.camera.right = 50;
            directionalLight.shadow.camera.top = 50;
            directionalLight.shadow.camera.bottom = -50;
            scene.add(directionalLight);

            // Add hemisphere light for more realistic lighting
            const hemisphereLight = new THREE.HemisphereLight(0x87CEEB, 0x654321, 0.6);
            scene.add(hemisphereLight);

            // Create enhanced terrain with multiple materials
            const createEnhancedTerrain = () => {
              const size = 100;
              const segments = 128;
              const geometry = new THREE.PlaneGeometry(size, size, segments, segments);
              
              // Generate height data using fractal noise
              const positions = geometry.attributes.position.array;
              const colors = [];
              
              for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                
                // Create multiple noise layers for realistic terrain
                const elevation = NoiseGenerator.fractalNoise(x, z, 6) * 8;
                const ridgeNoise = NoiseGenerator.fractalNoise(x * 0.5, z * 0.5, 4) * 2;
                const detailNoise = NoiseGenerator.fractalNoise(x * 2, z * 2, 3) * 0.5;
                
                let height = elevation + ridgeNoise + detailNoise;
                
                // Create valley system for rivers
                const distanceFromCenter = Math.sqrt(x * x + z * z);
                const valleyEffect = Math.max(0, 1 - distanceFromCenter / 30) * -3;
                height += valleyEffect;
                
                // River carving
                const riverPath1 = Math.abs((x + z * 0.3) % 20 - 10);
                const riverPath2 = Math.abs((x * 0.8 - z) % 25 - 12);
                if (riverPath1 < 2) height -= 2;
                if (riverPath2 < 1.5) height -= 1.5;
                
                positions[i + 2] = height;
                
                // Determine material based on height and conditions
                let color = new THREE.Color();
                if (height < -1) {
                  // Deep water
                  color.setHex(0x1e40af);
                } else if (height < 0) {
                  // Shallow water
                  color.setHex(0x3b82f6);
                } else if (height < 0.5) {
                  // Beach/sand
                  color.setHex(0xfbbf24);
                } else if (height < 3) {
                  // Grass
                  color.setHex(0x16a34a);
                } else if (height < 6) {
                  // Rock
                  color.setHex(0x78716c);
                } else {
                  // Snow
                  color.setHex(0xf8fafc);
                }
                
                colors.push(color.r, color.g, color.b);
              }
              
              geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
              geometry.computeVertexNormals();
              
              const material = new THREE.MeshLambertMaterial({ 
                vertexColors: true,
                side: THREE.DoubleSide 
              });
              
              const mesh = new THREE.Mesh(geometry, material);
              mesh.rotation.x = -Math.PI / 2;
              mesh.receiveShadow = true;
              mesh.castShadow = true;
              
              return mesh;
            };

            // Create water system with animated flow
            const createWaterSystem = () => {
              const waterGeometry = new THREE.PlaneGeometry(80, 80, 64, 64);
              const positions = waterGeometry.attributes.position.array;
              
              // Create flowing water height variations
              for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 1];
                positions[i + 2] = -0.2 + Math.sin(x * 0.1) * 0.1 + Math.cos(z * 0.1) * 0.1;
              }
              
              const waterMaterial = new THREE.MeshPhongMaterial({
                color: 0x006994,
                transparent: true,
                opacity: 0.8,
                shininess: 100,
                specular: 0x004466
              });
              
              const waterMesh = new THREE.Mesh(waterGeometry, waterMaterial);
              waterMesh.rotation.x = -Math.PI / 2;
              waterMesh.position.y = 0.1;
              
              return waterMesh;
            };

            // Create terrain and water
            const terrain = createEnhancedTerrain();
            terrainMeshRef.current = terrain;
            scene.add(terrain);
            
            const water = createWaterSystem();
            waterMeshRef.current = water;
            scene.add(water);

            // Enhanced mouse controls
            let mouseX = 0, mouseY = 0;
            let isMouseDown = false;
            let targetRotationY = 0;
            let currentRotationY = 0;
            
            const onMouseMove = (event) => {
              if (!isMouseDown) return;
              
              const deltaX = event.clientX - mouseX;
              targetRotationY += deltaX * 0.01;
              
              mouseX = event.clientX;
              mouseY = event.clientY;
            };
            
            const onMouseDown = (event) => {
              isMouseDown = true;
              mouseX = event.clientX;
              mouseY = event.clientY;
            };
            
            const onMouseUp = () => {
              isMouseDown = false;
            };
            
            const onWheel = (event) => {
              const delta = event.deltaY * 0.001;
              camera.position.multiplyScalar(1 + delta);
              camera.lookAt(0, 0, 0);
            };
            
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('mousedown', onMouseDown);
            renderer.domElement.addEventListener('mouseup', onMouseUp);
            renderer.domElement.addEventListener('wheel', onWheel);

            // Enhanced animation loop
            const animate = () => {
              animationIdRef.current = requestAnimationFrame(animate);
              
              const time = Date.now() * 0.001;
              
              // Smooth camera rotation
              currentRotationY += (targetRotationY - currentRotationY) * 0.05;
              
              // Animate water
              if (waterMeshRef.current) {
                const positions = waterMeshRef.current.geometry.attributes.position.array;
                for (let i = 0; i < positions.length; i += 3) {
                  const x = positions[i];
                  const z = positions[i + 1];
                  positions[i + 2] = -0.2 + 
                    Math.sin(x * 0.1 + time * 0.5) * 0.1 + 
                    Math.cos(z * 0.1 + time * 0.3) * 0.1;
                }
                waterMeshRef.current.geometry.attributes.position.needsUpdate = true;
                waterMeshRef.current.material.opacity = 0.7 + Math.sin(time * 0.5) * 0.1;
              }
              
              // Rotate entire scene
              scene.rotation.y = currentRotationY;
              
              renderer.render(scene, camera);
            };
            
            animate();

            // Handle resize
            const handleResize = () => {
              if (!mountRef.current) return;
              const width = mountRef.current.clientWidth;
              const height = mountRef.current.clientHeight;
              camera.aspect = width / height;
              camera.updateProjectionMatrix();
              renderer.setSize(width, height);
            };
            
            window.addEventListener('resize', handleResize);

            // Cleanup
            return () => {
              if (animationIdRef.current) {
                cancelAnimationFrame(animationIdRef.current);
              }
              if (mountRef.current && renderer.domElement) {
                mountRef.current.removeChild(renderer.domElement);
              }
              window.removeEventListener('resize', handleResize);
              renderer.dispose();
            };
          }, []);

          // Update dams and ecosystem elements
          useEffect(() => {
            if (!sceneRef.current) return;

            // Clear existing objects
            damMeshesRef.current.forEach(mesh => {
              sceneRef.current.remove(mesh);
            });
            damMeshesRef.current = [];

            // Add enhanced dams
            dams.forEach((dam, index) => {
              const group = new THREE.Group();
              
              // Dam structure - more detailed
              const damGeometry = new THREE.BoxGeometry(2, 4, 0.5);
              const damMaterial = new THREE.MeshLambertMaterial({ color: 0x6b7280 });
              const damMesh = new THREE.Mesh(damGeometry, damMaterial);
              damMesh.castShadow = true;
              damMesh.receiveShadow = true;
              group.add(damMesh);
              
              // Reservoir
              const reservoirGeometry = new THREE.CylinderGeometry(3, 3, 0.5, 16);
              const reservoirMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x3b82f6, 
                transparent: true, 
                opacity: 0.6 
              });
              const reservoirMesh = new THREE.Mesh(reservoirGeometry, reservoirMaterial);
              reservoirMesh.position.set(-4, -1, 0);
              reservoirMesh.rotation.x = Math.PI / 2;
              group.add(reservoirMesh);
              
              // Power house
              const powerhouseGeometry = new THREE.BoxGeometry(1.5, 2, 1.5);
              const powerhouseMaterial = new THREE.MeshLambertMaterial({ color: 0x92400e });
              const powerhouseMesh = new THREE.Mesh(powerhouseGeometry, powerhouseMaterial);
              powerhouseMesh.position.set(3, 0, 0);
              powerhouseMesh.castShadow = true;
              group.add(powerhouseMesh);
              
              // Ecological status indicator
              const impactColor = dam.ecologicalImpact === 'high' ? 0xff0000 : 
                                 dam.ecologicalImpact === 'moderate' ? 0xffa500 : 0x00ff00;
              const statusGeometry = new THREE.SphereGeometry(0.3);
              const statusMaterial = new THREE.MeshBasicMaterial({ color: impactColor });
              const statusMesh = new THREE.Mesh(statusGeometry, statusMaterial);
              statusMesh.position.y = 2.5;
              group.add(statusMesh);
              
              // Position the dam
              group.position.set(
                (dam.x - 350) / 25,
                2,
                (dam.y - 200) / 25
              );
              group.rotation.y = Math.random() * Math.PI * 2;
              
              sceneRef.current.add(group);
              damMeshesRef.current.push(group);
            });

            // Add enhanced ecosystem elements
            if (showEcological) {
              ecosystemElements.forEach(element => {
                const pos = [(element.x - 350) / 25, 1, (element.y - 200) / 25];
                
                if (element.type === 'fish') {
                  const fishGeometry = new THREE.ConeGeometry(0.2, 0.6, 6);
                  const healthColor = element.health > 0.7 ? 0x00ff00 : 
                                     element.health > 0.4 ? 0xffa500 : 0xff0000;
                  const fishMaterial = new THREE.MeshLambertMaterial({ 
                    color: healthColor, 
                    transparent: true, 
                    opacity: element.health 
                  });
                  const fishMesh = new THREE.Mesh(fishGeometry, fishMaterial);
                  fishMesh.position.set(...pos);
                  fishMesh.rotation.x = -Math.PI / 2;
                  sceneRef.current.add(fishMesh);
                  damMeshesRef.current.push(fishMesh);
                }
                
                if (element.type === 'vegetation') {
                  // Create small trees
                  const treeGroup = new THREE.Group();
                  
                  // Trunk
                  const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.1, 0.5);
                  const trunkMaterial = new THREE.MeshLambertMaterial({ color: 0x8b4513 });
                  const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                  trunk.position.y = 0.25;
                  treeGroup.add(trunk);
                  
                  // Foliage
                  const foliageGeometry = new THREE.SphereGeometry(0.3, 8, 6);
                  const healthColor = element.health > 0.7 ? 0x228b22 : 
                                     element.health > 0.4 ? 0x9acd32 : 0x8b4513;
                  const foliageMaterial = new THREE.MeshLambertMaterial({ 
                    color: healthColor,
                    transparent: true, 
                    opacity: element.health 
                  });
                  const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                  foliage.position.y = 0.7;
                  treeGroup.add(foliage);
                  
                  treeGroup.position.set(...pos);
                  treeGroup.scale.setScalar(element.health * 1.5 + 0.5);
                  sceneRef.current.add(treeGroup);
                  damMeshesRef.current.push(treeGroup);
                }
              });
            }
          }, [dams, ecosystemElements, showEcological]);

          return React.createElement('div', {
            ref: mountRef,
            className: 'three-container'
          });
        };

        // Main component
        const HydroPowerDemo = () => {
          const [isPlaying, setIsPlaying] = useState(false);
          const [currentTime, setCurrentTime] = useState(0);
          const [selectedPolicy, setSelectedPolicy] = useState('balanced');
          const [showEcological, setShowEcological] = useState(true);
          
          // Dam system state
          const [dams, setDams] = useState([
            {
              id: 'upstream',
              name: 'Lac Saint-Jean',
              x: 200, y: 150,
              volume: 75, maxVolume: 100, minVolume: 20,
              naturalInflow: 45,
              outflow: 30,
              power: 0,
              ecologicalImpact: 'moderate',
              fishPassage: true,
              sedimentTrap: 60
            },
            {
              id: 'middle',
              name: 'P√©ribonka Dam', 
              x: 380, y: 220,
              volume: 60, maxVolume: 85, minVolume: 15,
              naturalInflow: 25,
              outflow: 25,
              power: 0,
              ecologicalImpact: 'high',
              fishPassage: false,
              sedimentTrap: 80
            },
            {
              id: 'downstream',
              name: 'Saguenay Outlet',
              x: 520, y: 180,
              volume: 45, maxVolume: 70, minVolume: 10,
              naturalInflow: 20,
              outflow: 20,
              power: 0,
              ecologicalImpact: 'low',
              fishPassage: true,
              sedimentTrap: 30
            }
          ]);

          // Ecosystem elements
          const [ecosystemElements, setEcosystemElements] = useState([
            // Fish populations
            { id: 'fish1', type: 'fish', x: 150, y: 200, health: 0.9, moving: true, blocked: false },
            { id: 'fish2', type: 'fish', x: 250, y: 180, health: 0.7, moving: true, blocked: false },
            { id: 'fish3', type: 'fish', x: 350, y: 240, health: 0.6, moving: false, blocked: true },
            { id: 'fish4', type: 'fish', x: 450, y: 190, health: 0.8, moving: true, blocked: false },
            
            // Vegetation - trees
            { id: 'tree1', type: 'vegetation', x: 120, y: 160, health: 0.9, waterAccess: true },
            { id: 'tree2', type: 'vegetation', x: 180, y: 140, health: 0.8, waterAccess: true },
            { id: 'tree3', type: 'vegetation', x: 320, y: 200, health: 0.4, waterAccess: false },
            { id: 'tree4', type: 'vegetation', x: 480, y: 170, health: 0.7, waterAccess: true },
            { id: 'tree5', type: 'vegetation', x: 200, y: 300, health: 0.85, waterAccess: true },
            { id: 'tree6', type: 'vegetation', x: 400, y: 120, health: 0.6, waterAccess: true }
          ]);

          const [ecosystemHealth, setEcosystemHealth] = useState({
            fishPopulation: 85,
            riparianVegetation: 90,
            waterQuality: 80,
            sedimentFlow: 70,
            floodplainConnectivity: 75
          });

          const policies = {
            economic: {
              name: "Pure Economic Optimization",
              color: "bg-red-600",
              description: "Maximize revenue, ignore ecological impact",
              ecologicalScore: 30,
              strategy: (dam, price) => dam.volume * 0.8
            },
            balanced: {
              name: "Balanced Policy", 
              color: "bg-green-600",
              description: "Balance profit with environmental constraints",
              ecologicalScore: 75,
              strategy: (dam, price, season) => dam.volume * (0.3 + 0.3 * (price / 100))
            },
            ecological: {
              name: "Eco-First Policy",
              color: "bg-blue-600", 
              description: "Prioritize natural flow patterns",
              ecologicalScore: 90,
              strategy: (dam, price, season) => Math.max(10, dam.naturalInflow * 0.8)
            }
          };

          // Animation loop
          useEffect(() => {
            if (!isPlaying) return;

            const interval = setInterval(() => {
              setCurrentTime(prev => prev + 1);
              
              // Update dam operations
              setDams(prevDams => {
                return prevDams.map(dam => {
                  const policy = policies[selectedPolicy];
                  const electricityPrice = 60 + Math.sin(currentTime * 0.1) * 30;
                  const season = Math.sin(currentTime * 0.05);
                  
                  const newOutflow = policy.strategy(dam, electricityPrice, season);
                  const powerOutput = newOutflow * (dam.volume / dam.maxVolume) * 3;
                  
                  let impact = 'low';
                  if (newOutflow > dam.naturalInflow * 1.5) impact = 'high';
                  else if (newOutflow > dam.naturalInflow * 1.2) impact = 'moderate';
                  
                  return {
                    ...dam,
                    outflow: newOutflow,
                    power: powerOutput,
                    ecologicalImpact: impact,
                    volume: Math.max(dam.minVolume, 
                      Math.min(dam.maxVolume, 
                        dam.volume + (dam.naturalInflow - newOutflow) * 0.02 + (Math.random() - 0.5)
                      )
                    )
                  };
                });
              });

              // Update ecosystem health
              setEcosystemHealth(prev => {
                const policy = policies[selectedPolicy];
                const targetHealth = policy.ecologicalScore;
                
                return {
                  fishPopulation: prev.fishPopulation + (targetHealth - prev.fishPopulation) * 0.02,
                  riparianVegetation: prev.riparianVegetation + (targetHealth - prev.riparianVegetation) * 0.01,
                  waterQuality: prev.waterQuality + (targetHealth - prev.waterQuality) * 0.015,
                  sedimentFlow: prev.sedimentFlow + (targetHealth - prev.sedimentFlow) * 0.01,
                  floodplainConnectivity: prev.floodplainConnectivity + (targetHealth - prev.floodplainConnectivity) * 0.01
                };
              });

              // Update ecosystem elements
              setEcosystemElements(prev => prev.map(element => {
                if (element.type === 'fish') {
                  const nearbyDam = dams.find(dam => 
                    Math.abs(dam.x - element.x) < 100 && Math.abs(dam.y - element.y) < 50
                  );
                  
                  let blocked = false;
                  let healthDelta = 0;
                  
                  if (nearbyDam) {
                    blocked = !nearbyDam.fishPassage && nearbyDam.ecologicalImpact === 'high';
                    healthDelta = nearbyDam.ecologicalImpact === 'high' ? -0.002 : 
                                 nearbyDam.ecologicalImpact === 'moderate' ? -0.001 : 0.001;
                  }
                  
                  return {
                    ...element,
                    blocked,
                    health: Math.max(0.1, Math.min(1, element.health + healthDelta)),
                    moving: !blocked && element.health > 0.3
                  };
                }
                
                if (element.type === 'vegetation') {
                  const nearbyDam = dams.find(dam => 
                    Math.abs(dam.x - element.x) < 80 && Math.abs(dam.y - element.y) < 60
                  );
                  
                  let waterAccess = true;
                  let healthDelta = 0;
                  
                  if (nearbyDam && nearbyDam.volume < nearbyDam.minVolume + 10) {
                    waterAccess = false;
                    healthDelta = -0.003;
                  } else {
                    healthDelta = 0.001;
                  }
                  
                  return {
                    ...element,
                    waterAccess,
                    health: Math.max(0.1, Math.min(1, element.health + healthDelta))
                  };
                }
                
                return element;
              }));
              
            }, 100);

            return () => clearInterval(interval);
          }, [isPlaying, selectedPolicy, currentTime]);

          const reset = () => {
            setCurrentTime(0);
            setIsPlaying(false);
          };

          return React.createElement('div', {
            className: "w-full max-w-7xl mx-auto p-6 bg-gradient-to-br from-green-50 via-blue-50 to-green-100 min-h-screen"
          },
            // Header
            React.createElement('div', { className: "text-center mb-6" },
              React.createElement('h1', {
                className: "text-4xl font-bold text-gray-800 mb-2"
              }, "Enhanced 3D Watershed Optimization"),
              React.createElement('p', {
                className: "text-gray-600 text-lg max-w-3xl mx-auto"
              }, "Realistic mountainous terrain with multi-layer noise generation, flowing water systems, and dynamic ecosystems")
            ),

            // Controls
            React.createElement('div', {
              className: "bg-white/80 backdrop-blur rounded-2xl p-6 mb-6 shadow-lg border border-green-200"
            },
              React.createElement('div', {
                className: "flex justify-between items-center mb-6"
              },
                React.createElement('div', {
                  className: "flex items-center space-x-4"
                },
                  React.createElement('button', {
                    onClick: () => setIsPlaying(!isPlaying),
                    className: "flex items-center space-x-2 bg-green-600 hover:bg-green-700 text-white px-6 py-3 rounded-xl transition-all duration-200 shadow-lg"
                  },
                    isPlaying ? React.createElement(Pause) : React.createElement(Play),
                    React.createElement('span', {
                      className: "font-semibold"
                    }, `${isPlaying ? 'Pause' : 'Start'} Simulation`)
                  ),
                  
                  React.createElement('button', {
                    onClick: reset,
                    className: "flex items-center space-x-2 bg-gray-600 hover:bg-gray-700 text-white px-4 py-3 rounded-xl transition-all duration-200"
                  },
                    React.createElement(RotateCcw),
                    React.createElement('span', null, "Reset")
                  ),

                  React.createElement('label', {
                    className: "flex items-center space-x-2 text-gray-700"
                  },
                    React.createElement('input', {
                      type: "checkbox",
                      checked: showEcological,
                      onChange: (e) => setShowEcological(e.target.checked),
                      className: "w-4 h-4 rounded"
                    }),
                    React.createElement('span', null, "Show Ecosystem")
                  )
                ),

                React.createElement('div', { className: "text-right" },
                  React.createElement('div', {
                    className: "text-sm text-gray-600"
                  }, "Simulation Time"),
                  React.createElement('div', {
                    className: "text-2xl font-bold text-gray-800"
                  }, `${Math.floor(currentTime / 10)} days`)
                )
              ),

              // Policy Selection
              React.createElement('div', { className: "grid grid-cols-3 gap-4" },
                Object.entries(policies).map(([key, policy]) =>
                  React.createElement('button', {
                    key: key,
                    onClick: () => setSelectedPolicy(key),
                    className: `p-4 rounded-xl border-2 transition-all duration-300 ${
                      selectedPolicy === key 
                        ? `${policy.color} text-white border-white shadow-lg scale-105` 
                        : 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:shadow-md'
                    }`
                  },
                    React.createElement('div', {
                      className: "font-bold text-lg"
                    }, policy.name),
                    React.createElement('div', {
                      className: "text-sm opacity-90 mt-1"
                    }, policy.description),
                    React.createElement('div', {
                      className: "text-xs mt-2 font-medium"
                    }, `Ecological Score: ${policy.ecologicalScore}/100`)
                  )
                )
              )
            ),

            // 3D Scene
            React.createElement('div', {
              className: "bg-white/60 backdrop-blur rounded-2xl shadow-xl border border-blue-200 mb-6"
            },
              React.createElement(EnhancedThreeScene, {
                dams: dams,
                ecosystemElements: ecosystemElements,
                selectedPolicy: selectedPolicy,
                showEcological: showEcological
              })
            ),

            // Info panel
            React.createElement('div', {
              className: "bg-white/80 backdrop-blur rounded-2xl p-6 mb-6 shadow-lg border border-green-200"
            },
              React.createElement('h3', {
                className: "text-xl font-bold mb-4 text-gray-800"
              }, "Current Status"),
              React.createElement('div', { className: "grid grid-cols-3 gap-4" },
                dams.map(dam => 
                  React.createElement('div', {
                    key: dam.id,
                    className: "p-4 bg-gray-50 rounded-lg"
                  },
                    React.createElement('h4', {
                      className: "font-semibold text-gray-800"
                    }, dam.name),
                    React.createElement('div', {
                      className: "text-sm text-gray-600 mt-2"
                    },
                      React.createElement('div', null, `Volume: ${dam.volume.toFixed(1)}/${dam.maxVolume} hm¬≥`),
                      React.createElement('div', null, `Power: ${dam.power.toFixed(0)} MW`),
                      React.createElement('div', null, `Impact: ${dam.ecologicalImpact}`)
                    )
                  )
                )
              )
            ),

            // Ecosystem Health Dashboard
            showEcological && React.createElement('div', {
              className: "bg-white/80 backdrop-blur rounded-2xl p-6 shadow-lg border border-green-200"
            },
              React.createElement('h2', {
                className: "text-2xl font-bold mb-6 text-gray-800 flex items-center"
              },
                React.createElement(Leaf, { size: 28, className: "mr-3 text-green-600" }),
                "Ecosystem Health Indicators"
              ),
              
              React.createElement('div', { className: "grid grid-cols-5 gap-6" },
                Object.entries(ecosystemHealth).map(([key, value]) => {
                  const getColor = (val) => val > 70 ? 'text-green-600' : val > 40 ? 'text-yellow-600' : 'text-red-600';
                  const getBgColor = (val) => val > 70 ? 'bg-green-100' : val > 40 ? 'bg-yellow-100' : 'bg-red-100';
                  
                  const icons = {
                    fishPopulation: React.createElement(FishIcon, { size: 24 }),
                    riparianVegetation: React.createElement('div', { className: "w-6 h-6 bg-green-600 rounded-full" }),
                    waterQuality: React.createElement('div', { className: "w-6 h-6 bg-blue-600 rounded" }),
                    sedimentFlow: React.createElement('div', { className: "w-6 h-6 rounded-full bg-amber-600" }),
                    floodplainConnectivity: React.createElement('div', { className: "w-6 h-6 border-2 border-blue-600 rounded" })
                  };
                  
                  return React.createElement('div', {
                    key: key,
                    className: `p-4 rounded-xl ${getBgColor(value)} border border-gray-200`
                  },
                    React.createElement('div', {
                      className: `flex items-center justify-center mb-2 ${getColor(value)}`
                    }, icons[key]),
                    React.createElement('div', { className: "text-center" },
                      React.createElement('div', {
                        className: "text-sm text-gray-600 capitalize mb-1"
                      }, key.replace(/([A-Z])/g, ' $1').trim()),
                      React.createElement('div', {
                        className: `text-2xl font-bold ${getColor(value)}`
                      }, Math.round(value) + '%')
                    ),
                    
                    // Health bar
                    React.createElement('div', {
                      className: "w-full bg-gray-200 rounded-full h-2 mt-2"
                    },
                      React.createElement('div', {
                        className: `h-2 rounded-full transition-all duration-1000 ${
                          value > 70 ? 'bg-green-500' : value > 40 ? 'bg-yellow-500' : 'bg-red-500'
                        }`,
                        style: { width: `${value}%` }
                      })
                    )
                  );
                })
              )
            )
          );
        };

        // Render the app
        ReactDOM.render(React.createElement(HydroPowerDemo), document.getElementById('root'));
    </script>
</body>
</html> 