<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiple Shooting: A Middle Ground</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 24px;
            background: #fafafa;
            color: #111827;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2.25rem;
            font-weight: 700;
            margin-bottom: 12px;
            color: #111827;
        }

        .subtitle {
            font-size: 1.125rem;
            color: #6b7280;
            font-weight: 400;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr;
            gap: 24px;
            margin-bottom: 32px;
        }

        .explanation {
            /* removed for streamlined look */
        }

        .highlight {
            background: linear-gradient(120deg, #a8e6cf 0%, #dcedc1 100%);
            padding: 2px 4px;
            border-radius: 3px;
        }

        .visualization-container {
            background: white;
            border-radius: 16px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 32px;
            border: 1px solid #e5e7eb;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 24px;
            margin-bottom: 32px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label {
            font-weight: 600;
            color: #374151;
            font-size: 0.875rem;
        }

        input[type="range"] {
            width: 120px;
            accent-color: #0ea5e9;
        }

        button {
            background: #0ea5e9;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            box-shadow: none;
        }

        button:hover {
            background: #0284c7;
        }

        button:disabled {
            background: #d1d5db;
            color: #9ca3af;
            cursor: not-allowed;
        }

        .svg-container {
            display: flex;
            justify-content: center;
            margin-top: 24px;
        }

        svg {
            border-radius: 12px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .method-comparison {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 40px;
        }

        .method-card {
            background: white;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            border-left: 4px solid #3498db;
            transition: transform 0.3s ease;
        }

        .method-card:hover {
            transform: translateY(-5px);
        }

        .method-card h3 {
            margin-top: 0;
            color: #2c3e50;
            font-size: 1.3em;
        }

        .method-card.active {
            border-left-color: #e74c3c;
            box-shadow: 0 6px 25px rgba(231, 76, 60, 0.2);
        }

        .trajectory-path {
            fill: none;
            stroke: #0ea5e9;
            stroke-width: 3;
            transition: all 0.5s ease;
        }

        .shooting-point {
            fill: #dc2626;
            transition: all 0.5s ease;
            cursor: pointer;
        }

        .shooting-point:hover {
            transform: scale(1.1);
        }

        .defect-line {
            stroke: #dc2626;
            stroke-width: 3;
            stroke-dasharray: 8,4;
            transition: all 0.5s ease;
        }

        .segment-label {
            font-size: 12px;
            font-weight: 600;
            fill: #6b7280;
            transition: all 0.5s ease;
        }

        .math-equation {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        .progress-indicator {
            width: 100%;
            height: 8px;
            background: #e5e7eb;
            border-radius: 4px;
            margin: 24px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: #0ea5e9;
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .method-comparison {
                grid-template-columns: 1fr;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            body {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Multiple Shooting: A Middle Ground</h1>
        <div class="subtitle">Interactive Visualization of Trajectory Optimization Methods</div>
    </div>

    <div class="main-content">
        <div class="explanation">
            <!-- Introductory explanatory text removed as per request -->
        </div>

        <div class="visualization-container">
            <div class="controls">
                <div class="control-group">
                    <label for="segments">Segments (K):</label>
                    <input type="range" id="segments" min="1" max="8" value="4" step="1">
                    <span id="segmentValue">4</span>
                </div>
                
                <button id="animateBtn">Animate Defects</button>
            </div>

            <div class="progress-indicator">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            <div id="iterationLabel" style="text-align:center;font-weight:600;color:#2c3e50;margin-top:6px;">
                Iteration 0
            </div>

            <div class="svg-container">
                <svg id="mainSvg" width="800" height="400" viewBox="0 0 800 400">
                    <!-- Background -->
                    <rect width="800" height="400" fill="#fdfdfd"/>
                    
                    <!-- Time axis -->
                    <line x1="50" y1="350" x2="750" y2="350" stroke="#2c3e50" stroke-width="2"/>
                    <text x="400" y="385" text-anchor="middle" font-size="16" fill="#2c3e50">Time</text>
                    
                    <!-- State axis -->
                    <line x1="50" y1="50" x2="50" y2="350" stroke="#2c3e50" stroke-width="2"/>
                    <text x="30" y="200" text-anchor="middle" font-size="16" fill="#2c3e50" transform="rotate(-90 30 200)">State</text>
                    
                    <!-- Grid lines -->
                    <defs>
                        <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
                            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#ecf0f1" stroke-width="1"/>
                        </pattern>
                    </defs>
                    <rect x="50" y="50" width="700" height="300" fill="url(#grid)"/>
                    
                    <!-- Container for dynamic elements -->
                    <g id="dynamicElements"></g>
                </svg>
            </div>
        </div>
    </div>

    <!-- Method comparison cards removed -->

    <script>
        class MultipleShootingViz {
            constructor() {
                this.svg = document.getElementById('dynamicElements');
                this.segmentSlider = document.getElementById('segments');
                this.segmentValue = document.getElementById('segmentValue');
                this.animateBtn = document.getElementById('animateBtn');
                this.progressBar = document.getElementById('progressBar');
                this.iterLabel = document.getElementById('iterationLabel');
                
                // NEW: aggregated data file with trajectories for several K values
                this.dataPathCandidates = ['multiple_shooting_data.json', '_static/multiple_shooting_data.json'];
                
                // Defaults until data loads
                this.numSegments = 0;
                this.width = 800;
                this.height = 400;
                this.margin = 50;
                this.isAnimating = false;
                
                this.setupEventListeners();

                // Instead of generating a fake trajectory, fetch the true one
                this.loadTrajectory();
            }
            
            setupEventListeners() {
                this.segmentSlider.addEventListener('input', (e) => {
                    const k = parseInt(e.target.value);
                    this.segmentValue.textContent = k;
                    this.applyCase(k);
                });
                
                this.animateBtn.addEventListener('click', () => {
                    if (!this.isAnimating) {
                        this.animateDefects();
                    }
                });
            }
            
            updateMethodCards() {
                const cards = document.querySelectorAll('.method-card');
                if (cards.length === 0) return; // cards removed

                cards.forEach(card => card.classList.remove('active'));

                if (this.numSegments === 1) {
                    const el = document.getElementById('singleCard');
                    if (el) el.classList.add('active');
                } else if (this.numSegments >= 8) {
                    const el = document.getElementById('directCard');
                    if (el) el.classList.add('active');
                } else {
                    const multipleCard = document.getElementById('multipleCard');
                    if (multipleCard) {
                        multipleCard.classList.add('active');
                        const header = multipleCard.querySelector('h3');
                        if (header) header.textContent = `Multiple Shooting (K=${this.numSegments})`;
                    }
                }
            }
            
            /**
             * Fetch trajectory JSON generated by the Python script and initialise
             * the internal data structures expected by the renderer / animator.
             */
            async loadTrajectory() {
                try {
                    let response;
                    for (const path of this.dataPathCandidates) {
                        try {
                            response = await fetch(path);
                            if (response.ok) {
                                break;
                            }
                        } catch(err) {
                            /* ignore and try next */ }
                    }
                    if (!response || !response.ok) {
                        throw new Error('Could not load trajectory data file');
                    }
                    const data = await response.json();

                    if (data.cases) {
                        this.dataByK = data.cases;
                        // configure slider bounds
                        const ks = Object.keys(this.dataByK).map(Number).sort((a,b)=>a-b);
                        this.segmentSlider.min = ks[0];
                        this.segmentSlider.max = ks[ks.length-1];
                        this.segmentSlider.disabled = false;
                        this.applyCase(parseInt(this.segmentSlider.value));
                        return; // applyCase handles rendering
                    }

                    // Fallback to single-K legacy format
                    this.numSegments = data.num_segments;
                    const wrap = (segArray) => segArray.map((segPts, idx) => {
                        const startX = segPts[0].x;
                        const endX = segPts[segPts.length - 1].x;
                        const verticalOffset = segPts[0].y - segPts[0].originalY;
                        return { index: idx, startX, endX, points: segPts, verticalOffset };
                    });

                    this.optimizationSteps = data.optimization_steps ?
                        data.optimization_steps.map(wrap) : null;

                    // Flatten continuous trajectory for possible future use
                    this.trajectoryPoints = data.continuous_trajectory.flat();

                    // Build discontinuousPoints structure expected by render()/animateDefects
                    this.discontinuousPoints = data.initial_guess.map((segPts, idx) => {
                        const startX = segPts[0].x;
                        const endX = segPts[segPts.length - 1].x;
                        const verticalOffset = segPts[0].y - segPts[0].originalY;
                        return {
                            index: idx,
                            startX,
                            endX,
                            points: segPts,
                            verticalOffset
                        };
                    });

                    // Keep a pristine copy so we can reset deterministically between runs
                    this.initialGuessSegments = JSON.parse(JSON.stringify(this.discontinuousPoints));

                    // Update UI elements
                    this.segmentSlider.value = this.numSegments;
                    this.segmentSlider.disabled = true; // fixed K for now
                    this.segmentValue.textContent = this.numSegments;
                    this.updateMethodCards();

                    // Finally draw
                    this.render();
                } catch (err) {
                    console.error(err);
                    alert('Failed to load trajectory data. See console for details.');
                }
            }
            
            generateTrajectory() {
                // Generate a smooth ballistic-like trajectory
                this.trajectoryPoints = [];
                this.discontinuousPoints = [];
                const totalSteps = 100;
                
                for (let i = 0; i <= totalSteps; i++) {
                    const t = i / totalSteps;
                    const x = this.margin + t * (this.width - 2 * this.margin);
                    
                    // Ballistic trajectory with some oscillations
                    const y = this.height - this.margin - 50 - 
                             200 * Math.sin(Math.PI * t) * (1 - t) - 
                             30 * Math.sin(4 * Math.PI * t) * Math.exp(-2 * t);
                    
                    this.trajectoryPoints.push({x, y, t});
                }
                
                // Generate discontinuous version with gaps at segment boundaries
                this.generateDiscontinuousTrajectory();
            }
            
            generateDiscontinuousTrajectory() {
                this.discontinuousPoints = [];
                const segmentLength = (this.width - 2 * this.margin) / this.numSegments;
                
                for (let k = 0; k < this.numSegments; k++) {
                    const startX = this.margin + k * segmentLength;
                    const endX = this.margin + (k + 1) * segmentLength;
                    
                    // Find trajectory points for this segment
                    const segmentPoints = this.trajectoryPoints.filter(p => 
                        p.x >= startX && p.x <= endX
                    );
                    
                    if (segmentPoints.length > 0) {
                        // Add some random vertical offset to create discontinuities
                        const verticalOffset = (Math.random() - 0.5) * 60 * (k > 0 ? 1 : 0);
                        
                        const offsetPoints = segmentPoints.map(p => ({
                            ...p,
                            y: p.y + verticalOffset,
                            originalY: p.y
                        }));
                        
                        this.discontinuousPoints.push({
                            index: k,
                            startX: startX,
                            endX: endX,
                            points: offsetPoints,
                            verticalOffset: verticalOffset
                        });
                    }
                }
            }
            
            render() {
                this.svg.innerHTML = '';
                
                const segmentLength = (this.width - 2 * this.margin) / this.numSegments;
                
                // Draw vertical separators
                for (let k = 0; k <= this.numSegments; k++) {
                    const x = this.margin + k * segmentLength;
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', this.margin);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', this.height - this.margin);
                    line.setAttribute('stroke', '#bdc3c7');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '5,5');
                    line.setAttribute('opacity', '0.7');
                    this.svg.appendChild(line);
                    
                    // Time labels
                    const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    label.setAttribute('x', x);
                    label.setAttribute('y', 35);
                    label.setAttribute('text-anchor', 'middle');
                    label.setAttribute('font-size', '14');
                    label.setAttribute('fill', '#2c3e50');
                    label.setAttribute('font-weight', '600');
                    label.textContent = `t${k}`;
                    this.svg.appendChild(label);
                }
                
                // Draw trajectory segments with discontinuities
                this.discontinuousPoints.forEach((segment, i) => {
                    // Create path for this segment
                    const pathData = segment.points.map((p, j) => 
                        (j === 0 ? 'M' : 'L') + ` ${p.x} ${p.y}`
                    ).join(' ');
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', pathData);
                    path.setAttribute('class', 'trajectory-path');
                    path.setAttribute('stroke', '#3498db');
                    path.setAttribute('stroke-width', '3');
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke-linecap', 'round');
                    this.svg.appendChild(path);
                    
                    // Segment label
                    const midX = (segment.startX + segment.endX) / 2;
                    const segmentLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    segmentLabel.setAttribute('x', midX);
                    segmentLabel.setAttribute('y', 65);
                    segmentLabel.setAttribute('text-anchor', 'middle');
                    segmentLabel.setAttribute('class', 'segment-label');
                    segmentLabel.setAttribute('fill', '#7f8c8d');
                    segmentLabel.textContent = `Segment ${i + 1}`;
                    this.svg.appendChild(segmentLabel);
                });
                
                // Draw shooting points and defect constraints
                this.discontinuousPoints.forEach((segment, i) => {
                    const startPoint = segment.points[0];
                    const endPoint = segment.points[segment.points.length - 1];
                    
                    // Initial point (decision variable)
                    const startCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    startCircle.setAttribute('cx', startPoint.x);
                    startCircle.setAttribute('cy', startPoint.y);
                    startCircle.setAttribute('r', '8');
                    startCircle.setAttribute('fill', '#e74c3c');
                    startCircle.setAttribute('class', 'shooting-point');
                    startCircle.setAttribute('stroke', 'white');
                    startCircle.setAttribute('stroke-width', '2');
                    this.svg.appendChild(startCircle);
                    
                    // State label
                    const stateLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    stateLabel.setAttribute('x', startPoint.x + 15);
                    stateLabel.setAttribute('y', startPoint.y - 10);
                    stateLabel.setAttribute('font-size', '12');
                    stateLabel.setAttribute('fill', '#e74c3c');
                    stateLabel.setAttribute('font-weight', '600');
                    stateLabel.textContent = `x${i}`;
                    this.svg.appendChild(stateLabel);
                    
                    // Predicted end point (hollow circle)
                    const endCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    endCircle.setAttribute('cx', endPoint.x);
                    endCircle.setAttribute('cy', endPoint.y);
                    endCircle.setAttribute('r', '8');
                    endCircle.setAttribute('fill', 'none');
                    endCircle.setAttribute('stroke', '#e74c3c');
                    endCircle.setAttribute('stroke-width', '3');
                    endCircle.setAttribute('class', 'shooting-point');
                    this.svg.appendChild(endCircle);
                    
                    // Draw defect constraint (gap) if not the last segment
                    if (i < this.discontinuousPoints.length - 1) {
                        const nextSegment = this.discontinuousPoints[i + 1];
                        const nextStartPoint = nextSegment.points[0];
                        
                        // Defect constraint line showing the gap
                        const defectLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        defectLine.setAttribute('x1', endPoint.x);
                        defectLine.setAttribute('y1', endPoint.y);
                        defectLine.setAttribute('x2', nextStartPoint.x);
                        defectLine.setAttribute('y2', nextStartPoint.y);
                        defectLine.setAttribute('stroke', '#e74c3c');
                        defectLine.setAttribute('class', 'defect-line');
                        defectLine.setAttribute('stroke-width', '4');
                        defectLine.setAttribute('stroke-linecap', 'round');
                        defectLine.setAttribute('stroke-dasharray', '8,4');
                        defectLine.setAttribute('id', `defect-${i}`);
                        this.svg.appendChild(defectLine);
                        
                        // Add defect magnitude indicator
                        const gapSize = Math.abs(endPoint.y - nextStartPoint.y);
                        if (gapSize > 10) {
                            const midX = (endPoint.x + nextStartPoint.x) / 2;
                            const midY = (endPoint.y + nextStartPoint.y) / 2;
                            
                            // Gap indicator with size text
                            const gapText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            gapText.setAttribute('x', midX + 20);
                            gapText.setAttribute('y', midY);
                            gapText.setAttribute('text-anchor', 'start');
                            gapText.setAttribute('font-size', '10');
                            gapText.setAttribute('fill', '#e74c3c');
                            gapText.setAttribute('font-weight', '600');
                            gapText.setAttribute('id', `gap-text-${i}`);
                            gapText.textContent = `Gap: ${gapSize.toFixed(0)}px`;
                            this.svg.appendChild(gapText);
                        }
                        
                        // Defect constraint label (only for first gap and when segments <= 4)
                        if (i === 0 && this.numSegments <= 4) {
                            const midX = (endPoint.x + nextStartPoint.x) / 2;
                            const midY = (endPoint.y + nextStartPoint.y) / 2;
                            
                            const defectLabel1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            defectLabel1.setAttribute('x', midX);
                            defectLabel1.setAttribute('y', midY - 25);
                            defectLabel1.setAttribute('text-anchor', 'middle');
                            defectLabel1.setAttribute('font-size', '12');
                            defectLabel1.setAttribute('fill', '#e74c3c');
                            defectLabel1.setAttribute('font-weight', '600');
                            defectLabel1.textContent = 'Defect';
                            this.svg.appendChild(defectLabel1);
                            
                            const defectLabel2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            defectLabel2.setAttribute('x', midX);
                            defectLabel2.setAttribute('y', midY - 10);
                            defectLabel2.setAttribute('text-anchor', 'middle');
                            defectLabel2.setAttribute('font-size', '12');
                            defectLabel2.setAttribute('fill', '#e74c3c');
                            defectLabel2.setAttribute('font-weight', '600');
                            defectLabel2.textContent = 'Constraint';
                            this.svg.appendChild(defectLabel2);
                        }
                    }
                });
                
                // Final point label
                if (this.discontinuousPoints.length > 0) {
                    const lastSegment = this.discontinuousPoints[this.discontinuousPoints.length - 1];
                    const lastPoint = lastSegment.points[lastSegment.points.length - 1];
                    
                    const finalLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    finalLabel.setAttribute('x', lastPoint.x + 15);
                    finalLabel.setAttribute('y', lastPoint.y - 10);
                    finalLabel.setAttribute('font-size', '12');
                    finalLabel.setAttribute('fill', '#e74c3c');
                    finalLabel.setAttribute('font-weight', '600');
                    finalLabel.textContent = `x${this.numSegments}`;
                    this.svg.appendChild(finalLabel);
                }
            }
            
            async animateDefects() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                this.animateBtn.textContent = 'Optimizing...';
                this.animateBtn.disabled = true;

                if (this.optimizationSteps) {
                    // --- Play through recorded solver iterations ---
                    const totalFrames = this.optimizationSteps.length;
                    for (let i = 1; i < totalFrames; i++) {
                        const stepSegments = this.optimizationSteps[i];
                        this.discontinuousPoints = stepSegments;
                        this.render();
                        this.progressBar.style.width = `${(i / (totalFrames - 1)) * 100}%`;
                        this.iterLabel.textContent = `Iteration ${i}`;
                        await new Promise(r => setTimeout(r, 500)); // 0.5 s per iteration
                    }
                    this.iterLabel.textContent = `Done (${totalFrames - 1} iterations)`;
                } else {
                    // Fallback: old easing animation
                    await this.animateFallback();
                }

                // Finalize UI
                this.animateBtn.textContent = 'Animate Again';
                this.animateBtn.disabled = false;
                this.isAnimating = false;

                // Reset to initial guess after short pause
                setTimeout(() => {
                    this.discontinuousPoints = JSON.parse(JSON.stringify(this.initialGuessSegments));
                    this.render();
                    this.animateBtn.textContent = 'Animate Defects';
                    this.progressBar.style.width = '0%';
                    this.iterLabel.textContent = 'Iteration 0';
                }, 2000);
            }

            // Fallback method (legacy smooth animation)
            async animateFallback() {
                const defectLines = this.svg.querySelectorAll('.defect-line');
                const duration = 3000; // 3 seconds
                const steps = 90;
                const originalGaps = [];
                this.discontinuousPoints.forEach((segment, i) => {
                    if (i < this.discontinuousPoints.length - 1) {
                        const nextSegment = this.discontinuousPoints[i + 1];
                        const endPoint = segment.points[segment.points.length - 1];
                        const nextStartPoint = nextSegment.points[0];
                        originalGaps.push({
                            startY: endPoint.y,
                            endY: nextStartPoint.y,
                            targetY: endPoint.originalY || endPoint.y
                        });
                    }
                });
                for (let step = 0; step <= steps; step++) {
                    const progress = step / steps;
                    const easedProgress = 1 - Math.pow(1 - progress, 2);
                    this.progressBar.style.width = `${progress * 100}%`;
                    defectLines.forEach((line, i) => {
                        if (i < originalGaps.length) {
                            const gap = originalGaps[i];
                            const currentEndY = gap.endY + (gap.targetY - gap.endY) * easedProgress;
                            line.setAttribute('y2', currentEndY);
                        }
                    });
                    await new Promise(r => setTimeout(r, duration / steps));
                }
            }

            applyCase(k) {
                if (!this.dataByK || !this.dataByK[k]) return;

                this.numSegments = k;
                const caseData = this.dataByK[k];

                const wrap = (segArray) => segArray.map((segPts, idx) => {
                    const startX = segPts[0].x;
                    const endX = segPts[segPts.length - 1].x;
                    const verticalOffset = segPts[0].y - segPts[0].originalY;
                    return { index: idx, startX, endX, points: segPts, verticalOffset };
                });

                this.discontinuousPoints = wrap(caseData.initial_guess);
                this.initialGuessSegments = JSON.parse(JSON.stringify(this.discontinuousPoints));
                this.optimizationSteps = caseData.optimization_steps ? caseData.optimization_steps.map(wrap) : null;

                this.updateMethodCards();
                this.render();
            }
        }
        
        // Initialize visualization when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new MultipleShootingViz();
        });
    </script>
</body>
</html>