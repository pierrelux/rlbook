<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydro-Power Network Dynamics</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .animate-pulse-fast {
            animation: pulse 1s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const HydroPowerNetworkDemo = () => {
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [electricityPrice, setElectricityPrice] = useState(60);
            const [waterParticles, setWaterParticles] = useState([]);
            const particleIdRef = useRef(0);
            
            // Dam system state - positioned along elevation profile
            const [dams, setDams] = useState([
                {
                    id: 'upstream',
                    name: 'Lac Saint-Jean',
                    x: 150, 
                    groundLevel: 320,
                    damHeight: 40,
                    waterLevel: 300,
                    volume: 75, 
                    maxVolume: 100, 
                    minVolume: 20,
                    softMinVolume: 30,
                    softMaxVolume: 90,
                    naturalInflow: 45,
                    outflow: 30,
                    power: 0,
                    head: 35,
                    costs: { power: 0, penalty: 0 }
                },
                {
                    id: 'middle',
                    name: 'P√©ribonka Dam', 
                    x: 350,
                    groundLevel: 280,
                    damHeight: 50,
                    waterLevel: 260,
                    volume: 60, 
                    maxVolume: 85, 
                    minVolume: 15,
                    softMinVolume: 25,
                    softMaxVolume: 75,
                    naturalInflow: 25,
                    outflow: 25,
                    power: 0,
                    head: 40,
                    costs: { power: 0, penalty: 0 }
                },
                {
                    id: 'downstream',
                    name: 'Saguenay Outlet',
                    x: 550,
                    groundLevel: 240,
                    damHeight: 30,
                    waterLevel: 230,
                    volume: 45, 
                    maxVolume: 70, 
                    minVolume: 10,
                    softMinVolume: 20,
                    softMaxVolume: 60,
                    naturalInflow: 20,
                    outflow: 20,
                    power: 0,
                    head: 25,
                    costs: { power: 0, penalty: 0 }
                }
            ]);

            // System metrics
            const [systemMetrics, setSystemMetrics] = useState({
                totalPower: 0,
                totalCost: 0,
                cumulativeReward: 0,
                violations: 0,
                totalInflow: 0,
                totalOutflow: 0,
                waterBalance: 0
            });

            // Simple operational strategy - balance volume targets with power generation
            const operationalStrategy = (dam, price, time, damIndex) => {
                const volumeRatio = dam.volume / dam.maxVolume;
                const targetRatio = 0.6; // Target 60% capacity
                
                // Base flow to maintain target volume
                let baseFlow = dam.naturalInflow;
                
                // Adjust based on volume level
                if (volumeRatio > targetRatio + 0.1) {
                    // Above target - increase outflow
                    baseFlow += (volumeRatio - targetRatio) * 30;
                } else if (volumeRatio < targetRatio - 0.1) {
                    // Below target - decrease outflow
                    baseFlow -= (targetRatio - volumeRatio) * 20;
                }
                
                // Price influence (higher prices encourage more generation)
                const priceMultiplier = 1 + (price - 60) / 100;
                baseFlow *= priceMultiplier;
                
                // Seasonal variation
                const seasonalFactor = 1 + 0.2 * Math.sin(time * 0.02);
                baseFlow *= seasonalFactor;
                
                // Network considerations - downstream dams need water from upstream
                if (damIndex > 0) {
                    // Ensure we don't starve downstream
                    baseFlow = Math.max(baseFlow, dam.naturalInflow * 0.5);
                }
                
                // Safety constraints
                return Math.max(8, Math.min(80, baseFlow));
            };

            // Power calculation using head-flow relationship
            const calculatePower = (head, flow) => {
                const efficiency = 0.9;
                const gravity = 9.81;
                const density = 1000;
                return (efficiency * density * gravity * head * flow) / 1000000; // MW
            };

            // Cost calculation
            const calculateCosts = (dams, totalPower) => {
                const demand = 200; // MW baseline demand
                let powerCost = 0;
                let totalPenaltyCost = 0;
                
                // Power generation economics
                if (totalPower >= demand) {
                    powerCost = -(totalPower - demand) * electricityPrice * 0.85;
                } else {
                    const deficit = demand - totalPower;
                    powerCost = deficit * electricityPrice * 1.25;
                }
                
                // Volume constraint penalties
                dams.forEach(dam => {
                    let penaltyCost = 0;
                    if (dam.volume < dam.softMinVolume) {
                        penaltyCost += (dam.softMinVolume - dam.volume) * 150;
                    }
                    if (dam.volume > dam.softMaxVolume) {
                        penaltyCost += (dam.volume - dam.softMaxVolume) * 100;
                    }
                    dam.costs = { power: powerCost / 3, penalty: penaltyCost };
                    totalPenaltyCost += penaltyCost;
                });
                
                return { powerCost, penaltyCost: totalPenaltyCost, totalCost: powerCost + totalPenaltyCost };
            };

            // Create water particles for flow visualization
            const createWaterParticles = (dam, nextDam) => {
                if (!nextDam || dam.outflow < 10) return [];
                
                const particles = [];
                const numParticles = Math.ceil(dam.outflow / 15);
                
                for (let i = 0; i < numParticles; i++) {
                    particles.push({
                        id: particleIdRef.current++,
                        startX: dam.x + 20,
                        startY: dam.waterLevel,
                        endX: nextDam.x - 20,
                        endY: nextDam.waterLevel + 20,
                        currentX: dam.x + 20,
                        currentY: dam.waterLevel,
                        progress: Math.random() * 0.1,
                        speed: 0.015 + Math.random() * 0.01,
                        size: 2 + dam.outflow / 25,
                        opacity: 0.6 + Math.random() * 0.3,
                        born: currentTime
                    });
                }
                
                return particles;
            };

            // Main system update
            const updateSystem = () => {
                setDams(prevDams => {
                    return prevDams.map((dam, index) => {
                        // Get operational decision for outflow (ACTION)
                        const newOutflow = operationalStrategy(dam, electricityPrice, currentTime, index);
                        
                        // Update water level based on volume (STATE)
                        const newWaterLevel = dam.groundLevel - (dam.volume / dam.maxVolume) * dam.damHeight;
                        
                        // Calculate head
                        const newHead = Math.max(10, dam.waterLevel - dam.groundLevel + dam.damHeight);
                        
                        // Calculate power generation
                        const newPower = calculatePower(newHead, newOutflow);
                        
                        // DYNAMICS: Update volume using water balance equation
                        const volumeFlowRatio = 0.0864; // Convert m¬≥/s to hm¬≥/day
                        const volumeChange = (dam.naturalInflow - newOutflow) * volumeFlowRatio;
                        let newVolume = dam.volume + volumeChange;
                        
                        // NETWORK EFFECT: Add inflow from upstream dam (water conservation)
                        if (index > 0) {
                            const upstreamInflow = prevDams[index - 1].outflow * 0.85; // 85% reaches next dam
                            newVolume += upstreamInflow * volumeFlowRatio;
                        }
                        
                        // Enforce hard volume constraints
                        newVolume = Math.max(dam.minVolume, Math.min(dam.maxVolume, newVolume));
                        
                        // Add natural variability to inflows
                        const inflowVariation = dam.naturalInflow + (Math.random() - 0.5) * 5;
                        
                        return {
                            ...dam,
                            outflow: newOutflow,
                            volume: newVolume,
                            waterLevel: newWaterLevel,
                            head: newHead,
                            power: newPower,
                            naturalInflow: Math.max(10, inflowVariation)
                        };
                    });
                });
            };

            // Animation loop
            useEffect(() => {
                if (!isPlaying) return;

                const interval = setInterval(() => {
                    setCurrentTime(prev => prev + 1);
                    updateSystem();
                    
                    // Update electricity price with market volatility
                    setElectricityPrice(prev => {
                        const basePrice = 60;
                        const dailyCycle = Math.sin((currentTime % 144) * 0.044) * 15;
                        const noise = (Math.random() - 0.5) * 8;
                        return Math.max(25, Math.min(120, basePrice + dailyCycle + noise));
                    });

                    // Update water particles
                    setWaterParticles(prevParticles => {
                        // Remove old particles
                        const activeParticles = prevParticles
                            .filter(p => p.progress < 1 && currentTime - p.born < 100)
                            .map(particle => ({
                                ...particle,
                                progress: Math.min(1, particle.progress + particle.speed),
                                currentX: particle.startX + (particle.endX - particle.startX) * particle.progress,
                                currentY: particle.startY + (particle.endY - particle.startY) * particle.progress
                            }));

                        // Add new particles
                        const newParticles = [];
                        for (let i = 0; i < dams.length - 1; i++) {
                            newParticles.push(...createWaterParticles(dams[i], dams[i + 1]));
                        }

                        return [...activeParticles, ...newParticles];
                    });

                    // Update system metrics
                    const totalPower = dams.reduce((sum, dam) => sum + dam.power, 0);
                    const totalInflow = dams.reduce((sum, dam) => sum + dam.naturalInflow, 0);
                    const totalOutflow = dams.reduce((sum, dam) => sum + dam.outflow, 0);
                    const costs = calculateCosts(dams, totalPower);
                    const violations = dams.filter(dam => 
                        dam.volume < dam.softMinVolume || dam.volume > dam.softMaxVolume
                    ).length;

                    setSystemMetrics(prev => ({
                        totalPower,
                        totalCost: costs.totalCost,
                        cumulativeReward: prev.cumulativeReward - costs.totalCost,
                        violations,
                        totalInflow,
                        totalOutflow,
                        waterBalance: totalInflow - totalOutflow
                    }));

                }, 150);

                return () => clearInterval(interval);
            }, [isPlaying, currentTime, dams, electricityPrice]);

            const reset = () => {
                setCurrentTime(0);
                setIsPlaying(false);
                setWaterParticles([]);
                setSystemMetrics({
                    totalPower: 0,
                    totalCost: 0,
                    cumulativeReward: 0,
                    violations: 0,
                    totalInflow: 0,
                    totalOutflow: 0,
                    waterBalance: 0
                });
                setDams([
                    {
                        id: 'upstream',
                        name: 'Lac Saint-Jean',
                        x: 150, 
                        groundLevel: 320,
                        damHeight: 40,
                        waterLevel: 300,
                        volume: 75, 
                        maxVolume: 100, 
                        minVolume: 20,
                        softMinVolume: 30,
                        softMaxVolume: 90,
                        naturalInflow: 45,
                        outflow: 30,
                        power: 0,
                        head: 35,
                        costs: { power: 0, penalty: 0 }
                    },
                    {
                        id: 'middle',
                        name: 'P√©ribonka Dam', 
                        x: 350,
                        groundLevel: 280,
                        damHeight: 50,
                        waterLevel: 260,
                        volume: 60, 
                        maxVolume: 85, 
                        minVolume: 15,
                        softMinVolume: 25,
                        softMaxVolume: 75,
                        naturalInflow: 25,
                        outflow: 25,
                        power: 0,
                        head: 40,
                        costs: { power: 0, penalty: 0 }
                    },
                    {
                        id: 'downstream',
                        name: 'Saguenay Outlet',
                        x: 550,
                        groundLevel: 240,
                        damHeight: 30,
                        waterLevel: 230,
                        volume: 45, 
                        maxVolume: 70, 
                        minVolume: 10,
                        softMinVolume: 20,
                        softMaxVolume: 60,
                        naturalInflow: 20,
                        outflow: 20,
                        power: 0,
                        head: 25,
                        costs: { power: 0, penalty: 0 }
                    }
                ]);
            };

            return (
                <div className="w-full max-w-7xl mx-auto p-6 bg-gradient-to-b from-slate-100 via-blue-50 to-indigo-50 min-h-screen">
                    {/* Header */}
                    <div className="text-center mb-6">
                        <h1 className="text-4xl font-bold text-gray-800 mb-2 flex items-center justify-center">
                            üèîÔ∏è Hydro-Power Network Dynamics
                        </h1>
                        <p className="text-gray-600 text-lg max-w-4xl mx-auto">
                            Interactive visualization of state evolution, operational decisions, and networked water conservation in a hydro-power system
                        </p>
                    </div>

                    {/* Controls */}
                    <div className="bg-white/90 backdrop-blur rounded-2xl p-6 mb-6 shadow-lg border border-blue-200">
                        <div className="flex justify-between items-center">
                            <div className="flex items-center space-x-4">
                                <button 
                                    onClick={() => setIsPlaying(!isPlaying)}
                                    className="flex items-center space-x-2 bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-xl transition-all duration-200 shadow-lg"
                                >
                                    <span className="font-semibold">{isPlaying ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Start'} Simulation</span>
                                </button>
                                
                                <button 
                                    onClick={reset}
                                    className="flex items-center space-x-2 bg-gray-600 hover:bg-gray-700 text-white px-4 py-3 rounded-xl transition-all duration-200"
                                >
                                    <span>üîÑ Reset</span>
                                </button>
                            </div>

                            <div className="text-right">
                                <div className="text-sm text-gray-600">Time Steps</div>
                                <div className="text-2xl font-bold text-gray-800">{currentTime}</div>
                                <div className="text-sm text-blue-600">Market Price: ${electricityPrice.toFixed(0)}/MWh</div>
                            </div>
                        </div>
                    </div>

                    {/* Main Cross-Section View */}
                    <div className="bg-white/80 backdrop-blur rounded-2xl p-8 mb-6 shadow-xl border border-green-200 relative overflow-hidden">
                        <h2 className="text-2xl font-bold mb-4 text-center text-gray-800">Watershed Network - State, Actions & Dynamics</h2>
                        
                        <svg 
                            className="w-full h-96" 
                            viewBox="0 0 700 400"
                        >
                            <defs>
                                {/* Gradients */}
                                <linearGradient id="skyGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stopColor="#87ceeb" />
                                    <stop offset="100%" stopColor="#e0f6ff" />
                                </linearGradient>
                                
                                <linearGradient id="groundGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stopColor="#8b4513" />
                                    <stop offset="50%" stopColor="#a0522d" />
                                    <stop offset="100%" stopColor="#654321" />
                                </linearGradient>

                                <linearGradient id="waterGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stopColor="#4682b4" />
                                    <stop offset="100%" stopColor="#1e3a8a" />
                                </linearGradient>

                                <filter id="waterGlow">
                                    <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                                    <feMerge> 
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>

                                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                    <polygon points="0 0, 10 3.5, 0 7" fill="#3b82f6" />
                                </marker>
                            </defs>

                            {/* Sky background */}
                            <rect x="0" y="0" width="700" height="200" fill="url(#skyGradient)" />

                            {/* Ground profile */}
                            <path
                                d="M 0 340 Q 100 330 150 320 Q 250 310 350 280 Q 450 260 550 240 Q 600 235 700 230 L 700 400 L 0 400 Z"
                                fill="url(#groundGradient)"
                            />

                            {/* Water bodies and reservoirs (STATE) */}
                            {dams.map(dam => {
                                const reservoirWidth = 80;
                                
                                return (
                                    <g key={`water-${dam.id}`}>
                                        {/* Reservoir */}
                                        <path
                                            d={`M ${dam.x - reservoirWidth} ${dam.waterLevel + 20} Q ${dam.x - reservoirWidth/2} ${dam.waterLevel} ${dam.x + 10} ${dam.waterLevel} L ${dam.x + 10} ${dam.groundLevel} Q ${dam.x - reservoirWidth/2} ${dam.groundLevel + 5} ${dam.x - reservoirWidth} ${dam.groundLevel + 10} Z`}
                                            fill="url(#waterGradient)"
                                            opacity="0.8"
                                            filter="url(#waterGlow)"
                                        />

                                        {/* Water surface animation */}
                                        <path
                                            d={`M ${dam.x - reservoirWidth} ${dam.waterLevel + 20} Q ${dam.x - reservoirWidth/2} ${dam.waterLevel} ${dam.x + 10} ${dam.waterLevel}`}
                                            stroke="#4682b4"
                                            strokeWidth="2"
                                            fill="none"
                                            opacity="0.9"
                                        >
                                            <animate
                                                attributeName="d"
                                                values={`M ${dam.x - reservoirWidth} ${dam.waterLevel + 20} Q ${dam.x - reservoirWidth/2} ${dam.waterLevel} ${dam.x + 10} ${dam.waterLevel};M ${dam.x - reservoirWidth} ${dam.waterLevel + 18} Q ${dam.x - reservoirWidth/2} ${dam.waterLevel - 2} ${dam.x + 10} ${dam.waterLevel + 2};M ${dam.x - reservoirWidth} ${dam.waterLevel + 20} Q ${dam.x - reservoirWidth/2} ${dam.waterLevel} ${dam.x + 10} ${dam.waterLevel}`}
                                                dur="3s"
                                                repeatCount="indefinite"
                                            />
                                        </path>
                                    </g>
                                );
                            })}

                            {/* Water flow particles (DYNAMICS - showing water conservation) */}
                            {waterParticles.map(particle => (
                                <circle
                                    key={particle.id}
                                    cx={particle.currentX}
                                    cy={particle.currentY}
                                    r={particle.size}
                                    fill="#60a5fa"
                                    opacity={particle.opacity}
                                    filter="url(#waterGlow)"
                                />
                            ))}

                            {/* Dam structures */}
                            {dams.map(dam => {
                                const isViolating = dam.volume < dam.softMinVolume || dam.volume > dam.softMaxVolume;
                                const impactColor = isViolating ? '#dc2626' : '#10b981';
                                
                                return (
                                    <g key={dam.id}>
                                        {/* Dam wall */}
                                        <rect
                                            x={dam.x}
                                            y={dam.waterLevel}
                                            width="8"
                                            height={dam.groundLevel - dam.waterLevel + dam.damHeight}
                                            fill="#6b7280"
                                            stroke={impactColor}
                                            strokeWidth="2"
                                        />

                                        {/* Turbine house */}
                                        <rect
                                            x={dam.x - 15}
                                            y={dam.groundLevel - 10}
                                            width="25"
                                            height="20"
                                            fill="#4b5563"
                                            rx="3"
                                        />

                                        {/* Power generation indicator */}
                                        {dam.power > 5 && (
                                            <g>
                                                <circle
                                                    cx={dam.x + 20}
                                                    cy={dam.groundLevel}
                                                    r="8"
                                                    fill="#fbbf24"
                                                >
                                                    <animate
                                                        attributeName="r"
                                                        values="6;10;6"
                                                        dur="1.5s"
                                                        repeatCount="indefinite"
                                                    />
                                                </circle>
                                                <text
                                                    x={dam.x + 20}
                                                    y={dam.groundLevel + 3}
                                                    textAnchor="middle"
                                                    className="fill-white text-xs font-bold"
                                                >
                                                    ‚ö°
                                                </text>
                                                <text
                                                    x={dam.x + 20}
                                                    y={dam.groundLevel - 20}
                                                    textAnchor="middle"
                                                    className="fill-yellow-600 text-xs font-semibold"
                                                >
                                                    {Math.round(dam.power)}MW
                                                </text>
                                            </g>
                                        )}

                                        {/* Dam label and STATE metrics */}
                                        <text
                                            x={dam.x + 4}
                                            y={dam.waterLevel - 30}
                                            textAnchor="middle"
                                            className="fill-gray-700 text-sm font-semibold"
                                        >
                                            {dam.name}
                                        </text>

                                        {/* STATE: Volume indicator */}
                                        <text
                                            x={dam.x - 70}
                                            y={dam.waterLevel + 5}
                                            className="fill-blue-700 text-xs font-medium"
                                        >
                                            Vol: {Math.round(dam.volume)} hm¬≥
                                        </text>

                                        {/* ACTION: Outflow indicator */}
                                        <text
                                            x={dam.x - 70}
                                            y={dam.waterLevel + 18}
                                            className="fill-purple-700 text-xs"
                                        >
                                            Action: {Math.round(dam.outflow)} m¬≥/s
                                        </text>

                                        {/* Constraint violation warning */}
                                        {isViolating && (
                                            <g>
                                                <circle
                                                    cx={dam.x - 10}
                                                    cy={dam.waterLevel - 15}
                                                    r="8"
                                                    fill="#dc2626"
                                                    opacity="0.9"
                                                />
                                                <text
                                                    x={dam.x - 10}
                                                    y={dam.waterLevel - 12}
                                                    textAnchor="middle"
                                                    className="fill-white text-xs font-bold"
                                                >
                                                    !
                                                </text>
                                            </g>
                                        )}
                                    </g>
                                );
                            })}

                            {/* Flow direction arrows (NETWORK CONNECTIONS) */}
                            {dams.slice(0, -1).map((dam, idx) => {
                                const nextDam = dams[idx + 1];
                                const flowIntensity = Math.min(1, dam.outflow / 50);
                                
                                return (
                                    <path
                                        key={`flow-${idx}`}
                                        d={`M ${dam.x + 15} ${dam.waterLevel + 10} Q ${(dam.x + nextDam.x) / 2} ${(dam.waterLevel + nextDam.waterLevel) / 2 + 20} ${nextDam.x - 20} ${nextDam.waterLevel + 15}`}
                                        stroke="#3b82f6"
                                        strokeWidth={2 + flowIntensity * 4}
                                        fill="none"
                                        opacity={0.4 + flowIntensity * 0.4}
                                        markerEnd="url(#arrowhead)"
                                        strokeDasharray={flowIntensity > 0.5 ? "none" : "5,5"}
                                    />
                                );
                            })}

                            {/* Network labels */}
                            <text x="30" y="30" className="fill-gray-600 text-sm font-medium">
                                ‚Ü≥ Water flows downstream (network conservation)
                            </text>
                            <text x="30" y="50" className="fill-blue-600 text-sm font-medium">
                                STATE: Volume levels change over time
                            </text>
                            <text x="30" y="70" className="fill-purple-600 text-sm font-medium">
                                ACTION: Outflow decisions based on conditions
                            </text>

                            {/* Elevation markers */}
                            <g className="elevation-markers">
                                <text x="20" y="330" className="fill-gray-600 text-xs">340m</text>
                                <text x="20" y="290" className="fill-gray-600 text-xs">280m</text>
                                <text x="20" y="250" className="fill-gray-600 text-xs">240m</text>
                            </g>
                        </svg>
                    </div>

                    {/* System Metrics Dashboard */}
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
                        <div className="bg-white/90 backdrop-blur rounded-xl p-4 shadow-lg border border-blue-200">
                            <div className="text-center">
                                <h3 className="text-sm font-medium text-gray-600">Total Power</h3>
                                <div className="text-xl font-bold text-blue-600">
                                    {Math.round(systemMetrics.totalPower)} MW
                                </div>
                                <div className="text-xs text-gray-500">Target: 200 MW</div>
                            </div>
                        </div>

                        <div className="bg-white/90 backdrop-blur rounded-xl p-4 shadow-lg border border-green-200">
                            <div className="text-center">
                                <h3 className="text-sm font-medium text-gray-600">Total Inflow</h3>
                                <div className="text-xl font-bold text-green-600">
                                    {Math.round(systemMetrics.totalInflow)} m¬≥/s
                                </div>
                                <div className="text-xs text-gray-500">Natural inputs</div>
                            </div>
                        </div>

                        <div className="bg-white/90 backdrop-blur rounded-xl p-4 shadow-lg border border-purple-200">
                            <div className="text-center">
                                <h3 className="text-sm font-medium text-gray-600">Total Outflow</h3>
                                <div className="text-xl font-bold text-purple-600">
                                    {Math.round(systemMetrics.totalOutflow)} m¬≥/s
                                </div>
                                <div className="text-xs text-gray-500">Decision variables</div>
                            </div>
                        </div>

                        <div className="bg-white/90 backdrop-blur rounded-xl p-4 shadow-lg border border-orange-200">
                            <div className="text-center">
                                <h3 className="text-sm font-medium text-gray-600">Water Balance</h3>
                                <div className={`text-xl font-bold ${systemMetrics.waterBalance >= 0 ? 'text-green-600' : 'text-red-600'}`}>
                                    {systemMetrics.waterBalance > 0 ? '+' : ''}{Math.round(systemMetrics.waterBalance)} m¬≥/s
                                </div>
                                <div className="text-xs text-gray-500">In - Out</div>
                            </div>
                        </div>

                        <div className="bg-white/90 backdrop-blur rounded-xl p-4 shadow-lg border border-red-200">
                            <div className="text-center">
                                <h3 className="text-sm font-medium text-gray-600">Violations</h3>
                                <div className="text-xl font-bold text-red-600">
                                    {systemMetrics.violations}
                                </div>
                                <div className="text-xs text-gray-500">Constraint breaks</div>
                            </div>
                        </div>
                    </div>

                    {/* Footer */}
                    <div className="mt-8 text-center text-gray-500 text-sm">
                        <p>Interactive visualization of state evolution, operational decisions, and water conservation dynamics</p>
                        <p className="mt-1">Watch how <strong>states</strong> (volumes) evolve based on <strong>actions</strong> (outflows) through networked <strong>dynamics</strong></p>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HydroPowerNetworkDemo />);
    </script>
</body>
</html> 