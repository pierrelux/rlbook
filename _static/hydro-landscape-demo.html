<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hydro Landscape and River Network</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const HydroLandscapeDemo = () => {
            // Landscape Scene Component
            const LandscapeScene = () => {
                const mountRef = useRef(null);
                const sceneRef = useRef(null);
                const rendererRef = useRef(null);
                const cameraRef = useRef(null);
                const animationIdRef = useRef(null);

                useEffect(() => {
                    if (!mountRef.current) return;

                    // Scene setup
                    const scene = new THREE.Scene();
                    scene.background = new THREE.Color(0x87ceeb); // Sky blue
                    sceneRef.current = scene;

                    // Camera setup - positioned like the reference image
                    const camera = new THREE.PerspectiveCamera(60, mountRef.current.clientWidth / mountRef.current.clientHeight, 0.1, 1000);
                    camera.position.set(200, 150, 200);
                    camera.lookAt(0, 0, 0);
                    cameraRef.current = camera;

                    // Renderer setup
                    const renderer = new THREE.WebGLRenderer({ antialias: true });
                    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
                    renderer.shadowMap.enabled = true;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    rendererRef.current = renderer;
                    mountRef.current.appendChild(renderer.domElement);

                    // Lighting
                    const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                    scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                    directionalLight.position.set(100, 100, 50);
                    directionalLight.castShadow = true;
                    scene.add(directionalLight);

                    // Create realistic mountainous terrain
                    const createTerrain = () => {
                        const width = 400;
                        const height = 300;
                        const segments = 256;
                        
                        const geometry = new THREE.PlaneGeometry(width, height, segments, segments);
                        const positions = geometry.attributes.position.array;
                        const colors = [];

                        // Terrain generation with multiple noise layers
                        for (let i = 0; i < positions.length; i += 3) {
                            const x = positions[i];
                            const y = positions[i + 1];

                            let elevation = 0;
                            let amplitude = 1;
                            let frequency = 0.01;

                            // Multi-octave fractal noise for realistic terrain
                            for (let octave = 0; octave < 8; octave++) {
                                // Base mountain ridges
                                elevation += Math.sin(x * frequency) * Math.cos(y * frequency) * amplitude;
                                elevation += Math.sin(x * frequency * 1.7 + 100) * Math.cos(y * frequency * 1.3 + 50) * amplitude * 0.5;
                                
                                // Ridge noise for mountain peaks
                                const ridgeNoise = Math.abs(Math.sin(x * frequency * 0.7)) * Math.abs(Math.cos(y * frequency * 0.8));
                                elevation += ridgeNoise * amplitude * 0.7;

                                amplitude *= 0.5; // Each octave is half the amplitude
                                frequency *= 2.1; // Each octave doubles the frequency
                            }

                            // Scale the elevation
                            elevation *= 15;

                            // Create main river valley - carve through the center
                            const riverCenterX = Math.sin(y * 0.01) * 30; // Meandering river
                            const distanceFromRiver = Math.abs(x - riverCenterX);
                            const riverEffect = Math.max(0, 1 - distanceFromRiver / 40);
                            elevation -= riverEffect * riverEffect * 25; // Carve river valley

                            // Add tributary valleys
                            const tributary1 = Math.abs(x + 80 - Math.sin(y * 0.015) * 20);
                            const trib1Effect = Math.max(0, 1 - tributary1 / 25);
                            elevation -= trib1Effect * trib1Effect * 15;

                            const tributary2 = Math.abs(x - 70 - Math.cos(y * 0.012) * 15);
                            const trib2Effect = Math.max(0, 1 - tributary2 / 20);
                            elevation -= trib2Effect * trib2Effect * 12;

                            // Ensure minimum elevation for water level
                            elevation = Math.max(elevation, -8);

                            positions[i + 2] = elevation;

                            // Color based on elevation and slope
                            const normalizedHeight = (elevation + 10) / 60;
                            
                            if (elevation < -2) {
                                // Water - deep blue
                                colors.push(0.1, 0.3, 0.8);
                            } else if (elevation < 2) {
                                // Shoreline/wet areas - green-blue
                                colors.push(0.2, 0.6, 0.4);
                            } else if (elevation < 8) {
                                // Valley floor - rich green
                                colors.push(0.2, 0.7, 0.2);
                            } else if (elevation < 20) {
                                // Hillsides - mixed green
                                colors.push(0.3, 0.6, 0.3);
                            } else if (elevation < 35) {
                                // Mountain slopes - brown/green
                                colors.push(0.4, 0.5, 0.3);
                            } else {
                                // High peaks - gray/white
                                colors.push(0.7, 0.7, 0.6);
                            }
                        }

                        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                        geometry.computeVertexNormals();

                        const material = new THREE.MeshLambertMaterial({ 
                            vertexColors: true,
                            transparent: false
                        });

                        const terrain = new THREE.Mesh(geometry, material);
                        terrain.rotation.x = -Math.PI / 2;
                        terrain.receiveShadow = true;
                        scene.add(terrain);
                    };

                    // Create river network
                    const createRiverNetwork = () => {
                        // Main river path
                        const mainRiverPoints = [];
                        for (let y = -120; y <= 120; y += 5) {
                            const x = Math.sin(y * 0.01) * 30;
                            const z = 1; // Slightly above terrain
                            mainRiverPoints.push(new THREE.Vector3(x, z, y));
                        }

                        const mainRiverGeometry = new THREE.BufferGeometry().setFromPoints(mainRiverPoints);
                        const mainRiverMaterial = new THREE.LineBasicMaterial({ 
                            color: 0x1e40af, 
                            linewidth: 3 
                        });
                        const mainRiver = new THREE.Line(mainRiverGeometry, mainRiverMaterial);
                        scene.add(mainRiver);

                        // Tributary 1
                        const trib1Points = [];
                        for (let y = -80; y <= 20; y += 5) {
                            const x = -80 + Math.sin(y * 0.015) * 20;
                            const z = 1;
                            trib1Points.push(new THREE.Vector3(x, z, y));
                        }
                        // Connect to main river
                        const mainRiverX = Math.sin(20 * 0.01) * 30;
                        trib1Points.push(new THREE.Vector3(mainRiverX, 1, 20));

                        const trib1Geometry = new THREE.BufferGeometry().setFromPoints(trib1Points);
                        const trib1Material = new THREE.LineBasicMaterial({ 
                            color: 0x3b82f6, 
                            linewidth: 2 
                        });
                        const tributary1 = new THREE.Line(trib1Geometry, trib1Material);
                        scene.add(tributary1);

                        // Tributary 2
                        const trib2Points = [];
                        for (let y = -60; y <= 10; y += 5) {
                            const x = 70 + Math.cos(y * 0.012) * 15;
                            const z = 1;
                            trib2Points.push(new THREE.Vector3(x, z, y));
                        }
                        // Connect to main river
                        const mainRiverX2 = Math.sin(10 * 0.01) * 30;
                        trib2Points.push(new THREE.Vector3(mainRiverX2, 1, 10));

                        const trib2Geometry = new THREE.BufferGeometry().setFromPoints(trib2Points);
                        const trib2Material = new THREE.LineBasicMaterial({ 
                            color: 0x3b82f6, 
                            linewidth: 2 
                        });
                        const tributary2 = new THREE.Line(trib2Geometry, trib2Material);
                        scene.add(tributary2);

                        // Add smaller tributaries
                        const createSmallTributary = (startX, startY, endX, endY, color = 0x60a5fa) => {
                            const points = [];
                            const steps = 10;
                            for (let i = 0; i <= steps; i++) {
                                const t = i / steps;
                                const x = startX + (endX - startX) * t + Math.sin(t * Math.PI * 2) * 5;
                                const y = startY + (endY - startY) * t;
                                points.push(new THREE.Vector3(x, 1, y));
                            }
                            
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const material = new THREE.LineBasicMaterial({ color, linewidth: 1 });
                            const tributary = new THREE.Line(geometry, material);
                            scene.add(tributary);
                        };

                        // Add several small tributaries
                        createSmallTributary(-120, -60, -80, -40);
                        createSmallTributary(-100, 40, -60, 60);
                        createSmallTributary(90, -30, 70, -10);
                        createSmallTributary(110, 30, 80, 50);
                        createSmallTributary(-50, -100, -30, -80);
                        createSmallTributary(30, -90, 50, -70);
                    };

                    // Build the scene
                    createTerrain();
                    createRiverNetwork();

                    // Camera controls
                    let phi = Math.PI / 4;
                    let theta = 0;
                    let radius = 350;
                    let mouseX = 0, mouseY = 0;
                    let isMouseDown = false;

                    const updateCameraPosition = () => {
                        phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, phi));
                        camera.position.x = radius * Math.sin(phi) * Math.cos(theta);
                        camera.position.y = radius * Math.cos(phi);
                        camera.position.z = radius * Math.sin(phi) * Math.sin(theta);
                        camera.lookAt(0, 0, 0);
                    };

                    const onMouseMove = (event) => {
                        if (!isMouseDown) return;
                        
                        const deltaX = event.clientX - mouseX;
                        const deltaY = event.clientY - mouseY;
                        
                        theta -= deltaX * 0.01;
                        phi += deltaY * 0.01;
                        
                        updateCameraPosition();
                        
                        mouseX = event.clientX;
                        mouseY = event.clientY;
                    };

                    const onMouseDown = (event) => {
                        isMouseDown = true;
                        mouseX = event.clientX;
                        mouseY = event.clientY;
                    };

                    const onMouseUp = () => {
                        isMouseDown = false;
                    };

                    const onWheel = (event) => {
                        event.preventDefault();
                        const delta = event.deltaY * 0.001;
                        radius = Math.max(100, Math.min(800, radius * (1 + delta)));
                        updateCameraPosition();
                    };

                    updateCameraPosition();

                    renderer.domElement.addEventListener('mousemove', onMouseMove);
                    renderer.domElement.addEventListener('mousedown', onMouseDown);
                    renderer.domElement.addEventListener('mouseup', onMouseUp);
                    renderer.domElement.addEventListener('wheel', onWheel, { passive: false });
                    renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

                    // Simple render loop (no animation)
                    const render = () => {
                        renderer.render(scene, camera);
                        animationIdRef.current = requestAnimationFrame(render);
                    };
                    render();

                    // Cleanup
                    return () => {
                        if (animationIdRef.current) {
                            cancelAnimationFrame(animationIdRef.current);
                        }
                        if (mountRef.current && renderer.domElement) {
                            mountRef.current.removeChild(renderer.domElement);
                        }
                        renderer.dispose();
                    };
                }, []);

                return <div ref={mountRef} style={{ width: '100%', height: '100%' }} />;
            };

            return (
                <div className="w-full max-w-7xl mx-auto p-6 bg-gradient-to-br from-blue-50 via-green-50 to-blue-100 min-h-screen">
                    {/* Header */}
                    <div className="text-center mb-6">
                        <h1 className="text-4xl font-bold text-gray-800 mb-2">
                            üèîÔ∏è Hydro Watershed Landscape
                        </h1>
                        <p className="text-gray-600 text-lg max-w-3xl mx-auto">
                            Realistic terrain generation with river network system
                        </p>
                    </div>

                    {/* Landscape Description */}
                    <div className="bg-white/80 backdrop-blur rounded-2xl p-6 mb-6 shadow-lg border border-blue-200">
                        <div className="grid grid-cols-3 gap-6">
                            <div className="text-center">
                                <div className="text-2xl font-bold text-blue-600">üåä River Network</div>
                                <div className="text-sm text-gray-600 mt-2">
                                    Main river with tributaries flowing through carved valleys
                                </div>
                            </div>
                            <div className="text-center">
                                <div className="text-2xl font-bold text-green-600">‚õ∞Ô∏è Mountain Terrain</div>
                                <div className="text-sm text-gray-600 mt-2">
                                    Multi-octave noise generation with realistic elevation changes
                                </div>
                            </div>
                            <div className="text-center">
                                <div className="text-2xl font-bold text-purple-600">üó∫Ô∏è Watershed System</div>
                                <div className="text-sm text-gray-600 mt-2">
                                    Natural flow patterns from high elevations to main waterway
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* 3D Landscape */}
                    <div className="bg-white/60 backdrop-blur rounded-2xl shadow-xl border border-blue-200 h-96 mb-6">
                        <LandscapeScene />
                    </div>

                    {/* Controls Info */}
                    <div className="bg-white/80 backdrop-blur rounded-2xl p-6 shadow-lg border border-green-200">
                        <h2 className="text-2xl font-bold mb-4 text-gray-800">üéÆ Navigation</h2>
                        <div className="grid grid-cols-3 gap-6 text-center">
                            <div className="p-4 bg-blue-100 rounded-lg">
                                <div className="font-bold text-blue-800">üñ±Ô∏è Mouse Drag</div>
                                <div className="text-sm text-blue-600">Rotate camera around terrain</div>
                            </div>
                            <div className="p-4 bg-green-100 rounded-lg">
                                <div className="font-bold text-green-800">üñ±Ô∏è Scroll Wheel</div>
                                <div className="text-sm text-green-600">Zoom in/out (100-800 units)</div>
                            </div>
                            <div className="p-4 bg-purple-100 rounded-lg">
                                <div className="font-bold text-purple-800">üëÅÔ∏è Perspective</div>
                                <div className="text-sm text-purple-600">Explore the watershed from any angle</div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<HydroLandscapeDemo />);
    </script>
</body>
</html> 