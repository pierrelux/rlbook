
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Example COCPs &#8212; Practical Reinforcement Learning: From Algorithms to Applications</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"bm": ["{\\boldsymbol #1}", 1]}, "processEscapes": true}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'appendix';</script>
    <script src="_static/hydro.js?v=67e01585"></script>
    <script src="_static/iframe-modal.js?v=f72a1242"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Bibliography" href="bibliography.html" />
    <link rel="prev" title="Policy Parametrization Methods" href="cadp.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Practical Reinforcement Learning: From Algorithms to Applications</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Why This Book?
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modeling</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Why Build a Model? For Whom?</a></li>

<li class="toctree-l1"><a class="reference internal" href="ssm.html">Dynamics Models for Decision Making</a></li>





<li class="toctree-l1"><a class="reference internal" href="simulation.html">Programs as Models</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Trajectory Optimization</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ocp.html">Discrete-Time Trajectory Optimization</a></li>

<li class="toctree-l1"><a class="reference internal" href="cocp.html">Trajectory Optimization in Continuous Time</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Trajectories to Policies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mpc.html">From Trajectories to Policies</a></li>



<li class="toctree-l1"><a class="reference internal" href="dp.html">Dynamic Programming</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Learning from Data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="adp.html">Approximate Dynamic Programming</a></li>





<li class="toctree-l1"><a class="reference internal" href="cadp.html">Policy Parametrization Methods</a></li>







</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1 current active"><a class="current reference internal" href="#">Example COCPs</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/edit/main/appendix.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/issues/new?title=Issue%20on%20page%20%2Fappendix.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/appendix.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Example COCPs</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Example COCPs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pendulum-in-the-gym-environment">Pendulum in the Gym Environment</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#heat-exchanger">Heat Exchanger</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nuclear-reactor">Nuclear Reactor</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chemotherapy">Chemotherapy</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#government-corruption">Government Corruption</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-initial-value-problems">Solving Initial Value Problems</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-s-method">Euler’s Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-euler-s-method">Implicit Euler’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#stiff-odes">Stiff ODEs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoid-method">Trapezoid Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-predictor-corrector">Trapezoidal Predictor-Corrector</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collocation-methods">Collocation Methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-primer-on-polynomials">Quick Primer on Polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#orthogonal-polynomials">Orthogonal Polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#legendre-polynomials">Legendre Polynomials</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#chebyshev-polynomials">Chebyshev Polynomials</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#hermite-polynomials">Hermite Polynomials</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collocation-conditions">Collocation Conditions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#common-numerical-integration-techniques-as-collocation-methods">Common Numerical Integration Techniques as Collocation Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-euler-method">Explicit Euler Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-euler-method">Implicit Euler Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-method">Trapezoidal Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-methods">Runge-Kutta Methods</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example-solving-a-simple-ode-by-collocation">Example: Solving a Simple ODE by Collocation</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-programming">Nonlinear Programming</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#karush-kuhn-tucker-kkt-conditions">Karush-Kuhn-Tucker (KKT) conditions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lagrange-multiplier-theorem">Lagrange Multiplier Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-s-method">Newton’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-implementation-of-newton-s-method">Efficient Implementation of Newton’s Method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-equality-constrained-programs-with-newton-s-method">Solving Equality Constrained Programs with Newton’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#demonstration">Demonstration</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-sqp-approach-taylor-expansion-and-quadratic-approximation">The SQP Approach: Taylor Expansion and Quadratic Approximation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#connection-to-newton-s-method-in-the-equality-constrained-case">Connection to Newton’s Method in the Equality-Constrained Case</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sqp-for-inequality-constrained-optimization">SQP for Inequality-Constrained Optimization</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#demonstration-with-jax-and-cvxpy">Demonstration with JAX and CVXPy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-arrow-hurwicz-uzawa-algorithm">The Arrow-Hurwicz-Uzawa algorithm</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#projected-gradient-descent">Projected Gradient Descent</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-discrete-time-pontryagin-maximum-principle">The Discrete-Time Pontryagin Maximum Principle</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">The Discrete-Time Pontryagin Maximum Principle</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pmp-for-mayer-problems">PMP for Mayer Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pmp-for-bolza-problems">PMP for Bolza Problems</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="example-cocps">
<h1>Example COCPs<a class="headerlink" href="#example-cocps" title="Link to this heading">#</a></h1>
<section id="pendulum-in-the-gym-environment">
<h2>Pendulum in the Gym Environment<a class="headerlink" href="#pendulum-in-the-gym-environment" title="Link to this heading">#</a></h2>
<!-- Gym is a widely used abstraction layer for defining discrete-time reinforcement learning problems. In reinforcement learning research, there's often a desire to develop general-purpose algorithms that are problem-agnostic. This research mindset leads us to voluntarily avoid considering the implementation details of a given environment. While this approach is understandable from a research perspective, it may not be optimal from a pragmatic, solution-driven standpoint where we care about solving specific problems efficiently. If we genuinely wanted to solve this problem without prior knowledge, why not look under the hood and embrace its nature as a trajectory optimization problem? -->
<p>Let’s examine the code and reverse-engineer the original continuous-time problem hidden behind the abstraction layer. Although the pendulum problem may have limited practical relevance as a real-world application, it serves as an excellent example for our analysis. In the current version of <a class="reference external" href="https://github.com/openai/gym/blob/dcd185843a62953e27c2d54dc8c2d647d604b635/gym/envs/classic_control/pendulum.py">Pendulum</a>, we find that the Gym implementation uses a simplified model. Like our implementation, it assumes a fixed base and doesn’t model cart movement. The state is also represented by the pendulum angle and angular velocity.
However, the equations of motion implemented in the Gym environment are different and correspond to the following ODE:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{\theta} &amp;= \theta_{dot} \\
\dot{\theta}_{dot} &amp;= \frac{3g}{2l} \sin(\theta) + \frac{3}{ml^2} u
\end{align*}\]</div>
<p>Compared to our simplified model, the Gym implementation makes the following additional assumptions:</p>
<ol class="arabic simple">
<li><p>It omits the term <span class="math notranslate nohighlight">\(\frac{\gamma}{J_t} \dot{\theta}(t)\)</span>, which represents damping or air resistance. This means that it assumes an idealized pendulum that doesn’t naturally slow down over time.</p></li>
<li><p>It uses <span class="math notranslate nohighlight">\(ml^2\)</span> instead of <span class="math notranslate nohighlight">\(J_t = J + ml^2\)</span>, which assumes that all mass is concentrated at the pendulum’s end (like a point mass on a massless rod), rather than accounting for mass distribution along the pendulum.</p></li>
<li><p>The control input <span class="math notranslate nohighlight">\(u\)</span> is applied directly, without a <span class="math notranslate nohighlight">\(\cos \theta(t)\)</span> term, which means that the applied torque has the same effect regardless of the pendulum’s position, rather than varying with angle. For example, imagine trying to push a door open. When the door is almost closed (pendulum near vertical), a small push perpendicular to the door (analogous to our control input) can easily start it moving. However, when the door is already wide open (pendulum horizontal), the same push has little effect on the door’s angle. In a more detailed model, this would be captured by the <span class="math notranslate nohighlight">\(\cos \theta(t)\)</span> term, which is maximum when the pendulum is vertical (<span class="math notranslate nohighlight">\(\cos 0° = 1\)</span>) and zero when horizontal (<span class="math notranslate nohighlight">\(\cos 90° = 0\)</span>).</p></li>
</ol>
<p>The goal remains to stabilize the rod upright, but the way in which this encoded is through the following instantenous cost function:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
c(\theta, \dot{\theta}, u) &amp;= (\text{normalize}(\theta))^2 + 0.1\dot{\theta}^2 + 0.001u^2\\
\text{normalize}(\theta) &amp;= ((\theta + \pi) \bmod 2\pi) - \pi
\end{align*}\]</div>
<p>This cost function penalizes deviations from the upright position (first term), discouraging rapid motion (second term), and limiting control effort (third term). The relative weights has been manually chosen to balance the primary goal of upright stabilization with the secondary aims of smooth motion and energy efficiency. The normalization ensures that the angle is always in the range <span class="math notranslate nohighlight">\([-\pi, \pi]\)</span> so that the pendulum positions (e.g., <span class="math notranslate nohighlight">\(0\)</span> and <span class="math notranslate nohighlight">\(2\pi\)</span>) are treated identically, which could otherwise confuse learning algorithms.</p>
<p>Studying the code further, we find that it imposes bound constraints on both the control input and the angular velocity through clipping operations:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
u &amp;= \max(\min(u, u_{max}), -u_{max}) \\
\dot{\theta} &amp;= \max(\min(\dot{\theta}, \dot{\theta}_{max}), -\dot{\theta}_{max})
\end{align*}\]</div>
<p>Where <span class="math notranslate nohighlight">\(u_{max} = 2.0\)</span> and <span class="math notranslate nohighlight">\(\dot{\theta}_{max} = 8.0\)</span>.  Finally, when inspecting the <a class="reference external" href="https://github.com/openai/gym/blob/dcd185843a62953e27c2d54dc8c2d647d604b635/gym/envs/classic_control/pendulum.py#L133"><code class="docutils literal notranslate"><span class="pre">step</span></code></a> function, we find that the dynamics are discretized using forward Euler under a fixed step size of <span class="math notranslate nohighlight">\(h=0.0.5\)</span>. Overall, the discrete-time trajectory optimization problem implemented in Gym is the following:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\min_{u_k} \quad &amp; J = \sum_{k=0}^{N-1} c(\theta_k, \dot{\theta}_k, u_k) \\
\text{subject to:} \quad &amp; \theta_{k+1} = \theta_k + \dot{\theta}_k \cdot h \\
&amp; \dot{\theta}_{k+1} = \dot{\theta}_k + \left(\frac{3g}{2l}\sin(\theta_k) + \frac{3}{ml^2}u_k\right) \cdot h \\
&amp; -u_{\max} \leq u_k \leq u_{\max} \\
&amp; -\dot{\theta}_{\max} \leq \dot{\theta}_k \leq \dot{\theta}_{\max}, \quad k = 0, 1, ..., N-1 \\
\text{given:} \quad      &amp; \theta_0 = \theta_{\text{initial}}, \quad \dot{\theta}_0 = \dot{\theta}_{\text{initial}}, \quad N = 200
\end{align*}\]</div>
<p>with <span class="math notranslate nohighlight">\(g = 10.0\)</span>, <span class="math notranslate nohighlight">\(l = 1.0\)</span>, <span class="math notranslate nohighlight">\(m = 1.0\)</span>, <span class="math notranslate nohighlight">\(u_{max} = 2.0\)</span>, and <span class="math notranslate nohighlight">\(\dot{\theta}_{max} = 8.0\)</span>. This discrete-time problem corresponds to the following continuous-time optimal control problem:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\min_{u(t)} \quad &amp; J = \int_{0}^{T} c(\theta(t), \dot{\theta}(t), u(t)) dt \\
\text{subject to:} \quad &amp; \dot{\theta}(t) = \dot{\theta}(t) \\
&amp; \ddot{\theta}(t) = \frac{3g}{2l}\sin(\theta(t)) + \frac{3}{ml^2}u(t) \\
&amp; -u_{\max} \leq u(t) \leq u_{\max} \\
&amp; -\dot{\theta}_{\max} \leq \dot{\theta}(t) \leq \dot{\theta}_{\max} \\
\text{given:} \quad      &amp; \theta(0) = \theta_0, \quad \dot{\theta}(0) = \dot{\theta}_0, \quad T = 10 \text{ seconds}
\end{align*}\]</div>
</section>
<section id="heat-exchanger">
<h2>Heat Exchanger<a class="headerlink" href="#heat-exchanger" title="Link to this heading">#</a></h2>
<p><img alt="Heat Exchanger" src="_images/heat_exchanger.svg" /></p>
<p>We are considering a system where fluid flows through a tube, and the goal is to control the temperature of the fluid by adjusting the temperature of the tube’s wall over time. The wall temperature, denoted as <span class="math notranslate nohighlight">\( T_w(t) \)</span>, can be changed as a function of time, but it remains the same along the length of the tube. On the other hand, the temperature of the fluid inside the tube, <span class="math notranslate nohighlight">\( T(z, t) \)</span>, depends both on its position along the tube <span class="math notranslate nohighlight">\( z \)</span> and on time <span class="math notranslate nohighlight">\( t \)</span>. It evolves according to the following partial differential equation:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial T}{\partial t} = -v \frac{\partial T}{\partial z} + \frac{h}{\rho C_p} (T_w(t) - T)
\]</div>
<p>where we have:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\( v \)</span>: the average speed of the fluid moving through the tube,</p></li>
<li><p><span class="math notranslate nohighlight">\( h \)</span>: how easily heat transfers from the wall to the fluid,</p></li>
<li><p><span class="math notranslate nohighlight">\( \rho \)</span> and <span class="math notranslate nohighlight">\( C_p \)</span>: the fluid’s density and heat capacity.</p></li>
</ul>
<p>This equation describes how the fluid’s temperature changes as it moves along the tube and interacts with the tube’s wall temperature. The fluid enters the tube with an initial temperature <span class="math notranslate nohighlight">\( T_0 \)</span> at the inlet (where <span class="math notranslate nohighlight">\( z = 0 \)</span>). Our objective is to adjust the wall temperature <span class="math notranslate nohighlight">\( T_w(t) \)</span> so that by a specific final time <span class="math notranslate nohighlight">\( t_f \)</span>, the fluid’s temperature reaches a desired distribution <span class="math notranslate nohighlight">\( T_s(z) \)</span> along the length of the tube. The relationship for <span class="math notranslate nohighlight">\( T_s(z) \)</span> under steady-state conditions (ie. when changes over time are no longer considered), is given by:</p>
<div class="math notranslate nohighlight">
\[
\frac{d T_s}{d z} = \frac{h}{v \rho C_p}[\theta - T_s]
\]</div>
<p>where <span class="math notranslate nohighlight">\( \theta \)</span> is a constant temperature we want to maintain at the wall. The objective is to control the wall temperature <span class="math notranslate nohighlight">\( T_w(t) \)</span> so that by the end of the time interval <span class="math notranslate nohighlight">\( t_f \)</span>, the fluid temperature <span class="math notranslate nohighlight">\( T(z, t_f) \)</span> is as close as possible to the desired distribution <span class="math notranslate nohighlight">\( T_s(z) \)</span>. This can be formalized by minimizing the following quantity:</p>
<div class="math notranslate nohighlight">
\[
I = \int_0^L \left[T(z, t_f) - T_s(z)\right]^2 dz
\]</div>
<p>where <span class="math notranslate nohighlight">\( L \)</span> is the length of the tube. Additionally, we require that the wall temperature cannot exceed a maximum allowable value <span class="math notranslate nohighlight">\( T_{\max} \)</span>:</p>
<div class="math notranslate nohighlight">
\[
T_w(t) \leq T_{\max}\]</div>
</section>
<section id="nuclear-reactor">
<h2>Nuclear Reactor<a class="headerlink" href="#nuclear-reactor" title="Link to this heading">#</a></h2>
<p><img alt="Nuclear Reactor Diagram" src="_images/nuclear_reactor.svg" /></p>
<p>In a nuclear reactor, neutrons interact with fissile nuclei, causing nuclear fission. This process produces more neutrons and smaller fissile nuclei called precursors. The precursors subsequently absorb more neutrons, generating “delayed” neutrons. The kinetic energy of these products is converted into thermal energy through collisions with neighboring atoms. The reactor’s power output is determined by the concentration of neutrons available for nuclear fission.</p>
<p>The reaction kinetics can be modeled using a system of ordinary differential equations:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{x}(t) &amp;= \frac{r(t)x(t) - \alpha x^2(t) - \beta x(t)}{\tau} + \mu y(t), &amp; x(0) &amp;= x_0 \\
\dot{y}(t) &amp;= \frac{\beta x(t)}{\tau} - \mu y(t), &amp; y(0) &amp;= y_0
\end{align*}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x(t)\)</span>: concentration of neutrons at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y(t)\)</span>: concentration of precursors at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(t\)</span>: time</p></li>
<li><p><span class="math notranslate nohighlight">\(r(t) = r[u(t)]\)</span>: degree of change in neutron multiplication at time <span class="math notranslate nohighlight">\(t\)</span> as a function of control rod displacement <span class="math notranslate nohighlight">\(u(t)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha\)</span>: reactivity coefficient</p></li>
<li><p><span class="math notranslate nohighlight">\(\beta\)</span>: fraction of delayed neutrons</p></li>
<li><p><span class="math notranslate nohighlight">\(\mu\)</span>: decay constant for precursors</p></li>
<li><p><span class="math notranslate nohighlight">\(\tau\)</span>: average time taken by a neutron to produce a neutron or precursor</p></li>
</ul>
<p>The power output can be adjusted based on demand by inserting or retracting a neutron-absorbing control rod. Inserting the control rod absorbs neutrons, reducing the heat flux and power output, while retracting the rod has the opposite effect.</p>
<p>The objective is to change the neutron concentration <span class="math notranslate nohighlight">\(x(t)\)</span> from an initial value <span class="math notranslate nohighlight">\(x_0\)</span> to a stable value <span class="math notranslate nohighlight">\(x_\mathrm{f}\)</span> at time <span class="math notranslate nohighlight">\(t_\mathrm{f}\)</span> while minimizing the displacement of the control rod. This can be formulated as an optimal control problem, where the goal is to find the control function <span class="math notranslate nohighlight">\(u(t)\)</span> that minimizes the objective functional:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
I = \int_0^{t_\mathrm{f}} u^2(t) \, \mathrm{d}t
\end{equation*}\]</div>
<p>subject to the final conditions:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
x(t_\mathrm{f}) &amp;= x_\mathrm{f} \\
\dot{x}(t_\mathrm{f}) &amp;= 0
\end{align*}\]</div>
<p>and the constraint <span class="math notranslate nohighlight">\(|u(t)| \leq u_\mathrm{max}\)</span></p>
</section>
<section id="chemotherapy">
<h2>Chemotherapy<a class="headerlink" href="#chemotherapy" title="Link to this heading">#</a></h2>
<p>Chemotherapy uses drugs to kill cancer cells. However, these drugs can also have toxic effects on healthy cells in the body. To optimize the effectiveness of chemotherapy while minimizing its side effects, we can formulate an optimal control problem.</p>
<p>The drug concentration <span class="math notranslate nohighlight">\(y_1(t)\)</span> and the number of immune cells <span class="math notranslate nohighlight">\(y_2(t)\)</span>, healthy cells <span class="math notranslate nohighlight">\(y_3(t)\)</span>, and cancer cells <span class="math notranslate nohighlight">\(y_4(t)\)</span> in an organ at any time <span class="math notranslate nohighlight">\(t\)</span> during chemotherapy can be modeled using a system of ordinary differential equations:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{y}_1(t) &amp;= u(t) - \gamma_6 y_1(t) \\
\dot{y}_2(t) &amp;= \dot{y}_{2,\text{in}} + r_2 \frac{y_2(t) y_4(t)}{\beta_2 + y_4(t)} - \gamma_3 y_2(t) y_4(t) - \gamma_4 y_2(t) - \alpha_2 y_2(t) \left(1 - e^{-y_1(t) \lambda_2}\right) \\
\dot{y}_3(t) &amp;= r_3 y_3(t) \left(1 - \beta_3 y_3(t)\right) - \gamma_5 y_3(t) y_4(t) - \alpha_3 y_3(t) \left(1 - e^{-y_1(t) \lambda_3}\right) \\
\dot{y}_4(t) &amp;= r_1 y_4(t) \left(1 - \beta_1 y_4(t)\right) - \gamma_1 y_3(t) y_4(t) - \gamma_2 y_2(t) y_4(t) - \alpha_1 y_4(t) \left(1 - e^{-y_1(t) \lambda_1}\right)
\end{align*}\]</div>
<p>where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(y_1(t)\)</span>: drug concentration in the organ at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_2(t)\)</span>: number of immune cells in the organ at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_3(t)\)</span>: number of healthy cells in the organ at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(y_4(t)\)</span>: number of cancer cells in the organ at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\dot{y}_{2,\text{in}}\)</span>: constant rate of immune cells entering the organ to fight cancer cells</p></li>
<li><p><span class="math notranslate nohighlight">\(u(t)\)</span>: rate of drug injection into the organ at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r_i, \beta_i\)</span>: constants in the growth terms</p></li>
<li><p><span class="math notranslate nohighlight">\(\alpha_i, \lambda_i\)</span>: constants in the decay terms due to the action of the drug</p></li>
<li><p><span class="math notranslate nohighlight">\(\gamma_i\)</span>: constants in the remaining decay terms</p></li>
</ul>
<p>The objective is to minimize the number of cancer cells <span class="math notranslate nohighlight">\(y_4(t)\)</span> in a specified time <span class="math notranslate nohighlight">\(t_\mathrm{f}\)</span> while using the minimum amount of drug to reduce its toxic effects. This can be formulated as an optimal control problem, where the goal is to find the control function <span class="math notranslate nohighlight">\(u(t)\)</span> that minimizes the objective functional:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
I = y_4(t_\mathrm{f}) + \int_0^{t_\mathrm{f}} u(t) \, \mathrm{d}t
\end{equation*}\]</div>
<p>subject to the system dynamics, initial conditions, and the constraint <span class="math notranslate nohighlight">\(u(t) \geq 0\)</span>.</p>
<p>Additional constraints may include:</p>
<ul>
<li><p>Maintaining a minimum number of healthy cells during treatment:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
y_3(t) \geq y_{3,\min}
\end{equation*}\]</div>
</li>
<li><p>Imposing an upper limit on the drug dosage:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
u(t) \leq u_\max
\end{equation*}\]</div>
</li>
</ul>
</section>
<section id="government-corruption">
<h2>Government Corruption<a class="headerlink" href="#government-corruption" title="Link to this heading">#</a></h2>
<p>In this model from Feichtinger and Wirl (1994), we aim to understand the incentives for politicians to engage in corrupt activities or to combat corruption. The model considers a politician’s popularity as a dynamic process that is influenced by the public’s memory of recent and past corruption. The objective is to find conditions under which self-interested politicians would choose to be honest or dishonest.</p>
<p>The model introduces the following notation:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(C(t)\)</span>: accumulated awareness (knowledge) of past corruption at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(u(t)\)</span>: extent of corruption (politician’s control variable) at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\delta\)</span>: rate of forgetting past corruption</p></li>
<li><p><span class="math notranslate nohighlight">\(P(t)\)</span>: politician’s popularity at time <span class="math notranslate nohighlight">\(t\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(g(P)\)</span>: growth function of popularity; <span class="math notranslate nohighlight">\(g''(P) &lt; 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(f(C)\)</span>: function measuring the loss of popularity caused by <span class="math notranslate nohighlight">\(C\)</span>; <span class="math notranslate nohighlight">\(f'(C) &gt; 0\)</span>, <span class="math notranslate nohighlight">\(f''(C) \geq 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(U_1(P)\)</span>: benefits associated with being popular; <span class="math notranslate nohighlight">\(U_1'(P) &gt; 0\)</span>, <span class="math notranslate nohighlight">\(U_1''(P) \leq 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(U_2(u)\)</span>: benefits resulting from bribery and fraud; <span class="math notranslate nohighlight">\(U_2'(u) &gt; 0\)</span>, <span class="math notranslate nohighlight">\(U_2''(u) &lt; 0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(r\)</span>: discount rate</p></li>
</ul>
<p>The dynamics of the public’s memory of recent and past corruption <span class="math notranslate nohighlight">\(C(t)\)</span> are modeled as:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{C}(t) &amp;= u(t) - \delta C(t), \quad C(0) = C_0
\end{align*}\]</div>
<p>The evolution of the politician’s popularity <span class="math notranslate nohighlight">\(P(t)\)</span> is governed by:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\dot{P}(t) &amp;= g(P(t)) - f(C(t)), \quad P(0) = P_0
\end{align*}\]</div>
<p>The politician’s objective is to maximize the following objective:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{equation*}
\int_0^{\infty} e^{-rt} [U_1(P(t)) + U_2(u(t))] \, \mathrm{d}t
\end{equation*}\]</div>
<p>subject to the dynamics of corruption awareness and popularity.</p>
<p>The optimal control problem can be formulated as follows:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\max_{u(\cdot)} \quad &amp; \int_0^{\infty} e^{-rt} [U_1(P(t)) + U_2(u(t))] \, \mathrm{d}t \\
\text{s.t.} \quad &amp; \dot{C}(t) = u(t) - \delta C(t), \quad C(0) = C_0 \\
&amp; \dot{P}(t) = g(P(t)) - f(C(t)), \quad P(0) = P_0
\end{align*}\]</div>
<p>The state variables are the accumulated awareness of past corruption <span class="math notranslate nohighlight">\(C(t)\)</span> and the politician’s popularity <span class="math notranslate nohighlight">\(P(t)\)</span>. The control variable is the extent of corruption <span class="math notranslate nohighlight">\(u(t)\)</span>. The objective functional represents the discounted stream of benefits coming from being honest (popularity) and from being dishonest (corruption).</p>
</section>
</section>
<section id="solving-initial-value-problems">
<h1>Solving Initial Value Problems<a class="headerlink" href="#solving-initial-value-problems" title="Link to this heading">#</a></h1>
<p>An ODE is an implicit representation of a state-space trajectory: it tells us how the state changes in time but not precisely what the state is at any given time. To find out this information, we need to either solve the ODE analytically (for some special structure) or, as we’re going to do, solve them numerically. This numerical procedure is meant to solve what is called an IVP (initial value problem) of the form:</p>
<div class="math notranslate nohighlight">
\[
\text{Find } x(t) \text{ given } \dot{x}(t) = f(x(t), t) \text{ and } x(t_0) = x_0
\]</div>
<section id="euler-s-method">
<h2>Euler’s Method<a class="headerlink" href="#euler-s-method" title="Link to this heading">#</a></h2>
<p>The algorithm to solve this problem is, in its simplest form, a for loop which closely resembles the updates encountered in gradient descent (in fact, gradient descent can be derived from the gradient flow ODE, but that’s another discussion). The so-called explicit Euler’s method can be implemented as follow:</p>
<div class="proof algorithm admonition" id="euler-method">
<p class="admonition-title"><span class="caption-number">Algorithm 44 </span> (Euler’s method)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> <span class="math notranslate nohighlight">\(f(x, t)\)</span>, <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(t_0\)</span>, <span class="math notranslate nohighlight">\(t_{end}\)</span>, <span class="math notranslate nohighlight">\(h\)</span></p>
<p><strong>Output:</strong> Approximate solution <span class="math notranslate nohighlight">\(x(t)\)</span> at discrete time points</p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(t = t_0\)</span>, <span class="math notranslate nohighlight">\(x = x_0\)</span></p></li>
<li><p>While <span class="math notranslate nohighlight">\(t &lt; t_{end}\)</span>:</p></li>
<li><p>Compute <span class="math notranslate nohighlight">\(x_{new} = x + h f(x, t)\)</span></p></li>
<li><p>Update <span class="math notranslate nohighlight">\(t = t + h\)</span></p></li>
<li><p>Update <span class="math notranslate nohighlight">\(x = x_{new}\)</span></p></li>
<li><p>Store or output the pair <span class="math notranslate nohighlight">\((t, x)\)</span></p></li>
<li><p>End While</p></li>
</ol>
</section>
</div><p>Consider the following simple dynamical system of a ballistic motion model, neglecting air resistance. The state of the system is described by two variables: <span class="math notranslate nohighlight">\(y(t)\)</span>: vertical position at time <span class="math notranslate nohighlight">\(t\)</span> and <span class="math notranslate nohighlight">\(v(t)\)</span>, the vertical velocity at time <span class="math notranslate nohighlight">\(t\)</span>. The corresponding ODE is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\frac{dy}{dt} &amp;= v \\
\frac{dv}{dt} &amp;= -g
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(g \approx 9.81 \text{ m/s}^2\)</span> is the acceleration due to gravity. In our code, we use the initial conditions
<span class="math notranslate nohighlight">\(y(0) = 0 \text{ m}\)</span> and <span class="math notranslate nohighlight">\(v(0) = v_0 \text{ m/s}\)</span> where <span class="math notranslate nohighlight">\(v_0\)</span> is the initial velocity (in this case, <span class="math notranslate nohighlight">\(v_0 = 20 \text{ m/s}\)</span>).
The analytical solution to this system is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
y(t) &amp;= v_0t - \frac{1}{2}gt^2 \\
v(t) &amp;= v_0 - gt
\end{aligned}
\end{split}\]</div>
<p>This system models the vertical motion of an object launched upward, reaching a maximum height before falling back down due to gravity.</p>
<p>Euler’s method can be obtained by taking the first-order Taylor expansion of <span class="math notranslate nohighlight">\(x(t)\)</span> at <span class="math notranslate nohighlight">\(t\)</span>:</p>
<div class="math notranslate nohighlight">
\[
x(t + h) \approx x(t) + h \frac{dx}{dt}(t) = x(t) + h f(x(t), t)
\]</div>
<p>Each step of the algorithm therefore involves approximating the function with a linear function of slope <span class="math notranslate nohighlight">\(f\)</span> over the given interval <span class="math notranslate nohighlight">\(h\)</span>.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derivative function for vertical motion under gravity.</span>
<span class="sd">    y[0] is position, y[1] is velocity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># acceleration due to gravity (m/s^2)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">g</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">euler_method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implement Euler&#39;s method for the entire time range.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span>

<span class="k">def</span><span class="w"> </span><span class="nf">true_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analytical solution for the ballistic trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y0</span><span class="p">,</span> <span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span>  <span class="c1"># initial height and velocity</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">v0</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">t</span>

<span class="c1"># Set up the problem</span>
<span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span>
<span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>  <span class="c1"># initial height = 0, initial velocity = 20 m/s</span>

<span class="c1"># Different step sizes</span>
<span class="n">step_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]</span>
<span class="n">markers</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;^&#39;</span><span class="p">]</span>

<span class="c1"># True solution</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">y_true</span><span class="p">,</span> <span class="n">v_true</span> <span class="o">=</span> <span class="n">true_solution</span><span class="p">(</span><span class="n">t_fine</span><span class="p">)</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># Plot Euler approximations</span>
<span class="k">for</span> <span class="n">h</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">marker</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">step_sizes</span><span class="p">,</span> <span class="n">colors</span><span class="p">,</span> <span class="n">markers</span><span class="p">):</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">euler_method</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> 
             <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Euler h = </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>

<span class="c1"># Plot true solution last so it&#39;s on top</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True trajectory&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Height (m)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Euler&#39;s Method: Effect of Step Size on Ballistic Trajectory Approximation&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Add text to explain the effect of step size</span>
<span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;Smaller step sizes</span><span class="se">\n</span><span class="s2">yield better approximations&quot;</span><span class="p">,</span> 
         <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">),</span>
         <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/c6e546669f5e35e425c4d1ee54ab90c0350ef285dc8d6f34be0269cc67788793.png" src="_images/c6e546669f5e35e425c4d1ee54ab90c0350ef285dc8d6f34be0269cc67788793.png" />
</div>
</div>
<p>Another way to understand Euler’s method is through the fundamental theorem of calculus:</p>
<div class="math notranslate nohighlight">
\[
x(t + h) = x(t) + \int_t^{t+h} f(x(\tau), \tau) d\tau
\]</div>
<p>We then approximate the integral term with a box of width <span class="math notranslate nohighlight">\(h\)</span> and height <span class="math notranslate nohighlight">\(f\)</span>, and therefore of area <span class="math notranslate nohighlight">\(h f\)</span>.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rectangle</span>

<span class="k">def</span><span class="w"> </span><span class="nf">v</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Velocity function for the ballistic trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="mi">20</span>   <span class="c1"># initial velocity (m/s)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># acceleration due to gravity (m/s^2)</span>
    <span class="k">return</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">g</span> <span class="o">*</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">position</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Position function (integral of velocity).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="k">return</span> <span class="n">v0</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Set up the problem</span>
<span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">num_points</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>

<span class="c1"># Calculate true velocity and position</span>
<span class="n">v_true</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">x_true</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Euler&#39;s method with a large step size for visualization</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">t_euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">x_euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t_euler</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_euler</span><span class="p">)):</span>
    <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">v</span><span class="p">(</span><span class="n">t_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="c1"># Plotting</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">12</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Plot velocity function and its approximation</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v_true</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True velocity&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v_true</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True area (displacement)&#39;</span><span class="p">)</span>

<span class="c1"># Add rectangles with hashed pattern, ruler-like annotations, and area values</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_euler</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">t_i</span> <span class="o">=</span> <span class="n">t_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">v_i</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">t_i</span><span class="p">)</span>
    <span class="n">rect</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">t_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> 
                     <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> 
                     <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;///&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
    
    <span class="c1"># Add ruler-like annotations</span>
    <span class="c1"># Vertical ruler (height)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="n">t_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">),</span>
                 <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;&lt;-&gt;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">-</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">v_i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;v(t</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">) = </span><span class="si">{</span><span class="n">v_i</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> 
             <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    
    <span class="c1"># Horizontal ruler (width)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">t_i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                 <span class="n">arrowprops</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;&lt;-&gt;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">))</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;h = </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> 
             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    
    <span class="c1"># Add area value in the middle of each rectangle</span>
    <span class="n">area</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">v_i</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v_i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Area = </span><span class="si">{</span><span class="n">area</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> 
             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">))</span>

<span class="c1"># Plot only the points for Euler&#39;s method</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_euler</span><span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="n">t_euler</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Euler&#39;s points&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Velocity (m/s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Velocity Function and Euler&#39;s Approximation&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Extend y-axis to show horizontal rulers</span>

<span class="c1"># Plot position function and its approximation</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_true</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True position&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_euler</span><span class="p">,</span> <span class="n">x_euler</span><span class="p">,</span> <span class="s1">&#39;ro--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Euler&#39;s approximation&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="c1"># Add vertical arrows and horizontal lines to show displacement and time step</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_euler</span><span class="p">)):</span>
    <span class="n">t_i</span> <span class="o">=</span> <span class="n">t_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">x_prev</span> <span class="o">=</span> <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x_curr</span> <span class="o">=</span> <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="c1"># Vertical line for displacement</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t_i</span><span class="p">,</span> <span class="n">t_i</span><span class="p">],</span> <span class="p">[</span><span class="n">x_prev</span><span class="p">,</span> <span class="n">x_curr</span><span class="p">],</span> <span class="s1">&#39;g:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Horizontal line for time step</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">t_i</span> <span class="o">-</span> <span class="n">h</span><span class="p">,</span> <span class="n">t_i</span><span class="p">],</span> <span class="p">[</span><span class="n">x_prev</span><span class="p">,</span> <span class="n">x_prev</span><span class="p">],</span> <span class="s1">&#39;g:&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># Add text to show the displacement value</span>
    <span class="n">displacement</span> <span class="o">=</span> <span class="n">x_curr</span> <span class="o">-</span> <span class="n">x_prev</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="mf">0.05</span><span class="p">,</span> <span class="p">(</span><span class="n">x_prev</span> <span class="o">+</span> <span class="n">x_curr</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;+</span><span class="si">{</span><span class="n">displacement</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    
    <span class="c1"># Add text to show the time step</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">-</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">x_prev</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;h = </span><span class="si">{</span><span class="n">h</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> 
             <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position (m)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Position: True vs Euler&#39;s Approximation&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Add explanatory text</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.845</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="s2">&quot;Red hashed areas show</span><span class="se">\n</span><span class="s2">Euler&#39;s approximation</span><span class="se">\n</span><span class="s2">of the area under the curve&quot;</span><span class="p">,</span> 
         <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">),</span>
         <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/ce8eb043e762784070d3f9d1dd4e2ceca120fe54103d362232d8baa5777f332c.png" src="_images/ce8eb043e762784070d3f9d1dd4e2ceca120fe54103d362232d8baa5777f332c.png" />
</div>
</div>
</section>
<section id="implicit-euler-s-method">
<h2>Implicit Euler’s Method<a class="headerlink" href="#implicit-euler-s-method" title="Link to this heading">#</a></h2>
<p>An alternative approach is the Implicit Euler method, also known as the Backward Euler method. Instead of using the derivative at the current point to step forward, it uses the derivative at the end of the interval. This leads to the following update rule:</p>
<div class="math notranslate nohighlight">
\[
x_{new} = x + h f(x_{new}, t_{new})
\]</div>
<p>Note that <span class="math notranslate nohighlight">\(x_{new}\)</span> appears on both sides of the equation, making this an implicit method. The algorithm for the Implicit Euler method can be described as follows:</p>
<div class="proof algorithm admonition" id="implicit-euler-method">
<p class="admonition-title"><span class="caption-number">Algorithm 45 </span> (Implicit Euler’s Method)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> <span class="math notranslate nohighlight">\(f(x, t)\)</span>, <span class="math notranslate nohighlight">\(x_0\)</span>, <span class="math notranslate nohighlight">\(t_0\)</span>, <span class="math notranslate nohighlight">\(t_{end}\)</span>, <span class="math notranslate nohighlight">\(h\)</span></p>
<p><strong>Output:</strong> Approximate solution <span class="math notranslate nohighlight">\(x(t)\)</span> at discrete time points</p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(t = t_0\)</span>, <span class="math notranslate nohighlight">\(x = x_0\)</span></p></li>
<li><p>While <span class="math notranslate nohighlight">\(t &lt; t_{end}\)</span>:</p></li>
<li><p>Set <span class="math notranslate nohighlight">\(t_{new} = t + h\)</span></p></li>
<li><p>Solve for <span class="math notranslate nohighlight">\(x_{new}\)</span> in the equation: <span class="math notranslate nohighlight">\(x_{new} = x + h f(x_{new}, t_{new})\)</span></p></li>
<li><p>Update <span class="math notranslate nohighlight">\(t = t_{new}\)</span></p></li>
<li><p>Update <span class="math notranslate nohighlight">\(x = x_{new}\)</span></p></li>
<li><p>Store or output the pair <span class="math notranslate nohighlight">\((t, x)\)</span></p></li>
<li><p>End While</p></li>
</ol>
</section>
</div><p>The key difference in the Implicit Euler method is step 4, where we need to solve a (potentially nonlinear) equation to find <span class="math notranslate nohighlight">\(x_{new}\)</span>. This is typically done using iterative methods such as fixed-point iteration or Newton’s method.</p>
<section id="stiff-odes">
<h3>Stiff ODEs<a class="headerlink" href="#stiff-odes" title="Link to this heading">#</a></h3>
<p>While the Implicit Euler method requires more computation per step, it often allows for larger step sizes and can provide better stability for certain types of problems, especially stiff ODEs.</p>
<p>Stiff ODEs are differential equations for which certain numerical methods for solving the equation are numerically unstable, unless the step size is taken to be extremely small. These ODEs typically involve multiple processes occurring at widely different rates. In a stiff problem, the fastest-changing component of the solution can make the numerical method unstable unless the step size is extremely small. However, such a small step size may lead to an impractical amount of computation to traverse the entire interval of interest.</p>
<p>For example, consider a chemical reaction where some reactions occur very quickly while others occur much more slowly. The fast reactions quickly approach their equilibrium, but small perturbations in the slower reactions can cause rapid changes in the fast reactions.</p>
<p>A classic example of a stiff ODE is the Van der Pol oscillator with a large parameter. The Van der Pol equation is:</p>
<div class="math notranslate nohighlight">
\[
\frac{d^2x}{dt^2} - \mu(1-x^2)\frac{dx}{dt} + x = 0
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mu\)</span> is a scalar parameter. This second-order ODE can be transformed into a system of first-order ODEs by introducing a new variable <span class="math notranslate nohighlight">\(y = \frac{dx}{dt}\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\frac{dx}{dt} &amp;= y \\
\frac{dy}{dt} &amp;= \mu(1-x^2)y - x
\end{aligned}
\end{split}\]</div>
<p>When <span class="math notranslate nohighlight">\(\mu\)</span> is large (e.g., <span class="math notranslate nohighlight">\(\mu = 1000\)</span>), this system becomes stiff. The large <span class="math notranslate nohighlight">\(\mu\)</span> causes rapid changes in <span class="math notranslate nohighlight">\(y\)</span> when <span class="math notranslate nohighlight">\(x\)</span> is near ±1, but slower changes elsewhere. This leads to a solution with sharp transitions followed by periods of gradual change.</p>
</section>
</section>
<section id="trapezoid-method">
<h2>Trapezoid Method<a class="headerlink" href="#trapezoid-method" title="Link to this heading">#</a></h2>
<p>The trapezoid method, also known as the trapezoidal rule, offers improved accuracy and stability compared to the simple Euler method. The name “trapezoid method” comes from the idea of using a trapezoid to approximate the integral term in the fundamental theorem of calculus. This leads to the following update rule:</p>
<div class="math notranslate nohighlight">
\[
x_{new} = x + \frac{h}{2}[f(x, t) + f(x_{new}, t_{new})]
\]</div>
<p>where <span class="math notranslate nohighlight">\( t_{new} = t + h \)</span>. Note that this formula involves <span class="math notranslate nohighlight">\( x_{new} \)</span> on both sides of the equation, making it an implicit method, similar to the implicit Euler method discussed earlier.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib.patches</span><span class="w"> </span><span class="kn">import</span> <span class="n">Rectangle</span><span class="p">,</span> <span class="n">Polygon</span>

<span class="k">def</span><span class="w"> </span><span class="nf">v</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Velocity function for the ballistic trajectory.&quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="mi">20</span>   <span class="c1"># initial velocity (m/s)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># acceleration due to gravity (m/s^2)</span>
    <span class="k">return</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">g</span> <span class="o">*</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">position</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Position function (integral of velocity).&quot;&quot;&quot;</span>
    <span class="n">v0</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="k">return</span> <span class="n">v0</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Set up the problem</span>
<span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">num_points</span> <span class="o">=</span> <span class="mi">1000</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">num_points</span><span class="p">)</span>

<span class="c1"># Calculate true velocity and position</span>
<span class="n">v_true</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">x_true</span> <span class="o">=</span> <span class="n">position</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Euler&#39;s method and Trapezoid method with a large step size for visualization</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.5</span>
<span class="n">t_numeric</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="n">x_euler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">)</span>
<span class="n">x_trapezoid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">)):</span>
    <span class="c1"># Euler&#39;s method</span>
    <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_euler</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">v</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Trapezoid method (implicit, so we use a simple fixed-point iteration)</span>
    <span class="n">x_trapezoid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_trapezoid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>  <span class="c1"># 5 iterations should be enough for this simple problem</span>
        <span class="n">x_trapezoid</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_trapezoid</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">v</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">v</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

<span class="c1"># Plotting</span>
<span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">16</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Plot velocity function and its approximations</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">v_true</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True velocity&#39;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v_true</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True area (displacement)&#39;</span><span class="p">)</span>

<span class="c1"># Add trapezoids and rectangles</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">t_i</span><span class="p">,</span> <span class="n">t_next</span> <span class="o">=</span> <span class="n">t_numeric</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t_numeric</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">v_i</span><span class="p">,</span> <span class="n">v_next</span> <span class="o">=</span> <span class="n">v</span><span class="p">(</span><span class="n">t_i</span><span class="p">),</span> <span class="n">v</span><span class="p">(</span><span class="n">t_next</span><span class="p">)</span>
    
    <span class="c1"># Euler&#39;s rectangle (hashed pattern)</span>
    <span class="n">rect</span> <span class="o">=</span> <span class="n">Rectangle</span><span class="p">((</span><span class="n">t_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">h</span><span class="p">,</span> <span class="n">v_i</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;///&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">rect</span><span class="p">)</span>
    
    <span class="c1"># Trapezoid (dot pattern)</span>
    <span class="n">trapezoid</span> <span class="o">=</span> <span class="n">Polygon</span><span class="p">([(</span><span class="n">t_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">t_i</span><span class="p">,</span> <span class="n">v_i</span><span class="p">),</span> <span class="p">(</span><span class="n">t_next</span><span class="p">,</span> <span class="n">v_next</span><span class="p">),</span> <span class="p">(</span><span class="n">t_next</span><span class="p">,</span> <span class="mi">0</span><span class="p">)],</span> 
                        <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;....&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">trapezoid</span><span class="p">)</span>
    
    <span class="c1"># Add area values</span>
    <span class="n">euler_area</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">v_i</span>
    <span class="n">trapezoid_area</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="n">v_i</span> <span class="o">+</span> <span class="n">v_next</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">v_i</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Euler: </span><span class="si">{</span><span class="n">euler_area</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">t_i</span> <span class="o">+</span> <span class="n">h</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">v_i</span> <span class="o">+</span> <span class="n">v_next</span><span class="p">)</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;Trapezoid: </span><span class="si">{</span><span class="n">trapezoid_area</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;top&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">fontweight</span><span class="o">=</span><span class="s1">&#39;bold&#39;</span><span class="p">)</span>

<span class="c1"># Plot points for Euler&#39;s and Trapezoid methods</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">),</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Euler&#39;s points&quot;</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">,</span> <span class="n">v</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">),</span> <span class="s1">&#39;go&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Trapezoid points&quot;</span><span class="p">)</span>

<span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Velocity (m/s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Velocity Function: True vs Numerical Approximations&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Plot position function and its approximations</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_true</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True position&#39;</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">,</span> <span class="n">x_euler</span><span class="p">,</span> <span class="s1">&#39;ro--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Euler&#39;s approximation&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_numeric</span><span class="p">,</span> <span class="n">x_trapezoid</span><span class="p">,</span> <span class="s1">&#39;go--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Trapezoid approximation&quot;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Position (m)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Position: True vs Numerical Approximations&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Add explanatory text</span>
<span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="mf">1.76</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="s2">&quot;Red hashed areas: Euler&#39;s approximation</span><span class="se">\n</span><span class="s2">Green dotted areas: Trapezoid approximation&quot;</span><span class="p">,</span> 
         <span class="n">bbox</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">),</span>
         <span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/ffd8117274ade7605b2e6f1a7ea5b1e123f07f921403ad34a611484422b9d94c.png" src="_images/ffd8117274ade7605b2e6f1a7ea5b1e123f07f921403ad34a611484422b9d94c.png" />
</div>
</div>
<p>Algorithmically, the trapezoid method can be described as follows:</p>
<div class="proof algorithm admonition" id="algorithm-2">
<p class="admonition-title"><span class="caption-number">Algorithm 46 </span> (Trapezoid Method)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> <span class="math notranslate nohighlight">\( f(x, t) \)</span>, <span class="math notranslate nohighlight">\( x_0 \)</span>, <span class="math notranslate nohighlight">\( t_0 \)</span>, <span class="math notranslate nohighlight">\( t_{end} \)</span>, <span class="math notranslate nohighlight">\( h \)</span></p>
<p><strong>Output:</strong> Approximate solution <span class="math notranslate nohighlight">\( x(t) \)</span> at discrete time points</p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\( t = t_0 \)</span>, <span class="math notranslate nohighlight">\( x = x_0 \)</span></p></li>
<li><p>While <span class="math notranslate nohighlight">\( t &lt; t_{end} \)</span>:</p></li>
<li><p>  Set <span class="math notranslate nohighlight">\( t_{new} = t + h \)</span></p></li>
<li><p>  Solve for <span class="math notranslate nohighlight">\( x_{new} \)</span>in the equation: <span class="math notranslate nohighlight">\( x_{new} = x + \frac{h}{2}[f(x, t) + f(x_{new}, t_{new})] \)</span></p></li>
<li><p>  Update <span class="math notranslate nohighlight">\( t = t_{new} \)</span></p></li>
<li><p>  Update <span class="math notranslate nohighlight">\( x = x_{new} \)</span></p></li>
<li><p>  Store or output the pair <span class="math notranslate nohighlight">\( (t, x) \)</span></p></li>
</ol>
</section>
</div><p>The trapezoid method can also be derived by averaging the forward Euler and backward Euler methods. Recall that:</p>
<ol class="arabic">
<li><p><strong>Forward Euler method:</strong></p>
<div class="math notranslate nohighlight">
\[ x_{n+1} = x_n + h f(x_n, t_n) \]</div>
</li>
<li><p><strong>Backward Euler method:</strong></p>
<div class="math notranslate nohighlight">
\[ x_{n+1} = x_n + h f(x_{n+1}, t_{n+1}) \]</div>
</li>
</ol>
<p>Taking the average of these two methods yields:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
x_{n+1} &amp;= \frac{1}{2} \left( x_n + h f(x_n, t_n) \right) + \frac{1}{2} \left( x_n + h f(x_{n+1}, t_{n+1}) \right) \\
&amp;= x_n + \frac{h}{2} \left( f(x_n, t_n) + f(x_{n+1}, t_{n+1}) \right)
\end{aligned}
\end{split}\]</div>
<p>This is precisely the update rule for the trapezoid method. Recall that the forward Euler method approximates the solution by extrapolating linearly using the slope at the beginning of the interval <span class="math notranslate nohighlight">\([t_n, t_{n+1}] \)</span>. In contrast, the backward Euler method extrapolates linearly using the slope at the end of the interval. The trapezoid method, on the other hand, averages these two slopes. This averaging provides better approximation properties than either of the methods alone, offering both stability and accuracy. Note finally that unlike the forward or backward Euler methods, the trapezoid method is also symmetric in time. This means that if you were to reverse time and apply the method backward, you would get the same results (up to numerical precision).</p>
</section>
<section id="trapezoidal-predictor-corrector">
<h2>Trapezoidal Predictor-Corrector<a class="headerlink" href="#trapezoidal-predictor-corrector" title="Link to this heading">#</a></h2>
<p>The trapezoid method can also be implemented under the so-called predictor-corrector framework. This interpretation reformulates the implicit trapezoid rule into an explicit two-step process:</p>
<ol class="arabic">
<li><p><strong>Predictor Step</strong>:<br />
We make an initial guess for <span class="math notranslate nohighlight">\( x_{n+1} \)</span> using the forward Euler method:</p>
<div class="math notranslate nohighlight">
\[
   x_{n+1}^* = x_n + h f(x_n, t_n)
   \]</div>
<p>This is our “predictor” step, where <span class="math notranslate nohighlight">\( x_{n+1}^* \)</span> is the predicted value of <span class="math notranslate nohighlight">\( x_{n+1} \)</span>.</p>
</li>
<li><p><strong>Corrector Step</strong>:<br />
We then use this predicted value to estimate <span class="math notranslate nohighlight">\( f(x_{n+1}^*, t_{n+1}) \)</span> and apply the trapezoid formula:</p>
<div class="math notranslate nohighlight">
\[
   x_{n+1} = x_n + \frac{h}{2} \left[ f(x_n, t_n) + f(x_{n+1}^*, t_{n+1}) \right]
   \]</div>
<p>This is our “corrector” step, where the initial guess <span class="math notranslate nohighlight">\( x_{n+1}^* \)</span> is corrected by taking into account the slope at <span class="math notranslate nohighlight">\( (x_{n+1}^*, t_{n+1}) \)</span>.</p>
</li>
</ol>
<p>This two-step process is similar to performing one iteration of Newton’s method to solve the implicit trapezoid equation, starting from the Euler prediction. However, to fully solve the implicit equation, multiple iterations would be necessary until convergence is achieved.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Derivative function for vertical motion under gravity.</span>
<span class="sd">    y[0] is position, y[1] is velocity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># acceleration due to gravity (m/s^2)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">g</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">true_solution</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analytical solution for the ballistic trajectory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">y0</span><span class="p">,</span> <span class="n">v0</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">20</span>  <span class="c1"># initial height and velocity</span>
    <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>
    <span class="k">return</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">v0</span><span class="o">*</span><span class="n">t</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">v0</span> <span class="o">-</span> <span class="n">g</span><span class="o">*</span><span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">trapezoid_method_visual</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implement the trapezoid method for the entire time range.</span>
<span class="sd">    Returns predictor and corrector steps for visualization.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">+</span> <span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">y_predictor</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_predictor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="c1"># Predictor step (Euler forward)</span>
        <span class="n">slope_start</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">y_predictor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="n">slope_start</span>
        
        <span class="c1"># Corrector step</span>
        <span class="n">slope_end</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">y_predictor</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">h</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">slope_start</span> <span class="o">+</span> <span class="n">slope_end</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">y_predictor</span>

<span class="c1"># Set up the problem</span>
<span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span>
<span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>  <span class="c1"># initial height = 0, initial velocity = 20 m/s</span>
<span class="n">h</span> <span class="o">=</span> <span class="mf">0.5</span>  <span class="c1"># Step size</span>

<span class="c1"># Compute trapezoid method steps</span>
<span class="n">t</span><span class="p">,</span> <span class="n">y_corrector</span><span class="p">,</span> <span class="n">y_predictor</span> <span class="o">=</span> <span class="n">trapezoid_method_visual</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># Plot the true solution for comparison</span>
<span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">t_end</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">y_true</span><span class="p">,</span> <span class="n">v_true</span> <span class="o">=</span> <span class="n">true_solution</span><span class="p">(</span><span class="n">t_fine</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_fine</span><span class="p">,</span> <span class="n">y_true</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True trajectory&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># Plot the predictor and corrector steps</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="c1"># Points for the predictor step</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_corrector</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    <span class="n">p1_predictor</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_predictor</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    
    <span class="c1"># Points for the corrector step</span>
    <span class="n">p1_corrector</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_corrector</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
    
    <span class="c1"># Plot predictor step</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1_predictor</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p1_predictor</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p1_predictor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1_predictor</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    
    <span class="c1"># Plot corrector step</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1_corrector</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p1_corrector</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;g--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">p1_corrector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1_corrector</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>
    
    <span class="c1"># Add arrows to show the predictor and corrector adjustments</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="p">,</span> <span class="n">y_predictor</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> 
              <span class="n">head_width</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">head_length</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">arrow</span><span class="p">(</span><span class="n">p1_predictor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p1_predictor</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y_corrector</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_predictor</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> 
              <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span> <span class="n">head_width</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">head_length</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">length_includes_head</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Add legend entries for predictor and corrector steps</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Predictor step (Forward Euler)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">([],</span> <span class="p">[],</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Corrector step (Trapezoid)&#39;</span><span class="p">)</span>

<span class="c1"># Labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Height (m)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Trapezoid Method: Predictor-Corrector Structure&quot;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/1e9a9ef46c07dced8c1f402d659d400aaf636a7237521188af92cafbc8fe4f96.png" src="_images/1e9a9ef46c07dced8c1f402d659d400aaf636a7237521188af92cafbc8fe4f96.png" />
</div>
</div>
</section>
<section id="collocation-methods">
<h2>Collocation Methods<a class="headerlink" href="#collocation-methods" title="Link to this heading">#</a></h2>
<p>The numerical integration methods we discussed earlier are inherently <strong>sequential</strong>: given an initial state, we step forward in time and approximate what happens over a short interval. The accuracy of this procedure depends on the chosen rule (Euler, trapezoid, Runge–Kutta) and on the information available locally. Each new state is obtained by evaluating a formula that approximates the derivative or integral over that small step.</p>
<p><strong>Collocation methods provide an alternative viewpoint.</strong> Instead of advancing one step at a time, they approximate the entire trajectory with a finite set of basis functions and require the dynamics to hold at selected points. This replaces the original differential equation with a system of <strong>algebraic equations</strong>: relations among the coefficients of the basis functions that must all be satisfied simultaneously. Solving these equations fixes the whole trajectory in one computation.</p>
<p>Seen from this angle, integration rules, spline interpolation, quadrature, and collocation are all instances of the same principle: an infinite-dimensional problem is reduced to finitely many parameters linked by numerical rules. The difference is mainly in scope. Sequential integration advances the state forward one interval at a time, which makes it simple but prone to error accumulation. Collocation belongs to the class of <strong>simultaneous methods</strong> already introduced for DOCPs: the entire trajectory is represented at once, the dynamics are imposed everywhere in the discretization, and approximation error is spread across the horizon rather than accumulating step by step.</p>
<p>This global enforcement comes at a computational cost since the resulting algebraic system is larger and denser. However, the benefit is precisely the structural one we saw in simultaneous methods earlier: by exposing the coupling between states, controls, and dynamics explicitly, collocation allows solvers to exploit sparsity and to enforce path constraints directly at the collocation points. This is why collocation is especially effective for challenging continuous-time optimal control problems where robustness and constraint satisfaction are central.</p>
</section>
<section id="quick-primer-on-polynomials">
<h2>Quick Primer on Polynomials<a class="headerlink" href="#quick-primer-on-polynomials" title="Link to this heading">#</a></h2>
<p>Collocation methods are based on polynomial approximation theory. Therefore, the first step in developing collocation-based optimal control techniques is to review the fundamentals of polynomial functions.</p>
<p>Polynomials are typically introduced through their standard form:</p>
<div class="math notranslate nohighlight">
\[
p(t) = a_n t^n + a_{n-1} t^{n-1} + \cdots + a_1 t + a_0
\]</div>
<p>In this expression, the <span class="math notranslate nohighlight">\(a_i\)</span> are coefficients which linearly combine the powers of <span class="math notranslate nohighlight">\(t\)</span> to represent a function. The set of functions <span class="math notranslate nohighlight">\(\{ 1, t, t^2, t^3, \ldots, t^n \}\)</span> used in the standard polynomial representation is called the <strong>monomial basis</strong>.</p>
<p>In linear algebra, a basis is a set of vectors in a vector space such that any vector in the space can be uniquely represented as a linear combination of these basis vectors. In the same way, a <strong>polynomial basis</strong> is such that any function <span class="math notranslate nohighlight">\( f(x) \)</span> (within the function space) to be expressed as:</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{k=0}^{\infty} c_k p_k(x),
\]</div>
<p>where the coefficients <span class="math notranslate nohighlight">\( c_k \)</span> are generally determined by solving a system of equation.</p>
<p>Just as vectors can be represented in different coordinate systems (bases), functions can also be expressed using various polynomial bases. However, the ability to apply a change of basis does not imply that all types of polynomials are equivalent from a practical standpoint. In practice, our choice of polynomial basis is dictated by considerations of efficiency, accuracy, and stability when approximating a function.</p>
<p>For instance, despite the monomial basis being easy to understand and implement, it often performs poorly in practice due to numerical instability. This instability arises as its coefficients take on large values: an ill-conditioning problem. The following kinds of polynomial often remedy this issues.</p>
<section id="orthogonal-polynomials">
<h3>Orthogonal Polynomials<a class="headerlink" href="#orthogonal-polynomials" title="Link to this heading">#</a></h3>
<p>An <strong>orthogonal polynomial basis</strong> is a set of polynomials that are not only orthogonal to each other but also form a complete basis for a certain space of functions. This means that any function within that space can be represented as a linear combination of these polynomials.</p>
<p>More precisely, let <span class="math notranslate nohighlight">\( \{ p_0(x), p_1(x), p_2(x), \dots \} \)</span> be a sequence of polynomials where each <span class="math notranslate nohighlight">\( p_n(x) \)</span> is a polynomial of degree <span class="math notranslate nohighlight">\( n \)</span>. We say that this set forms an orthogonal polynomial basis if any polynomial <span class="math notranslate nohighlight">\( q(x) \)</span> of degree <span class="math notranslate nohighlight">\( n \)</span> or less can be uniquely expressed as a linear combination of <span class="math notranslate nohighlight">\( \{ p_0(x), p_1(x), \dots, p_n(x) \} \)</span>. Furthermore, the orthogonality property means that for any <span class="math notranslate nohighlight">\( i \neq j \)</span>:</p>
<div class="math notranslate nohighlight">
\[
\langle p_i, p_j \rangle = \int_a^b p_i(x) p_j(x) w(x) \, dx = 0.
\]</div>
<p>for some weight function <span class="math notranslate nohighlight">\( w(x) \)</span> over a given interval of orthogonality <span class="math notranslate nohighlight">\( [a, b] \)</span>.</p>
<p>The orthogonality property allows to simplify the computation of the coefficients involved in the polynomial representation of a function. At a high level, what happens is that when taking the inner product of <span class="math notranslate nohighlight">\( f(x) \)</span> with each basis polynomial, <span class="math notranslate nohighlight">\( p_k(x) \)</span> isolates the corresponding coefficient <span class="math notranslate nohighlight">\( c_k \)</span>, which can be found to be:</p>
<div class="math notranslate nohighlight">
\[
c_k = \frac{\langle f, p_k \rangle}{\langle p_k, p_k \rangle} = \frac{\int_a^b f(x) p_k(x) w(x) \, dx}{\int_a^b p_k(x)^2 w(x) \, dx}.
\]</div>
<p>Here are some examples of the most common orthogonal polynomials used in practice.</p>
<section id="legendre-polynomials">
<h4>Legendre Polynomials<a class="headerlink" href="#legendre-polynomials" title="Link to this heading">#</a></h4>
<p>Legendre polynomials <span class="math notranslate nohighlight">\( \{ P_n(x) \} \)</span> are defined on the interval <span class="math notranslate nohighlight">\([-1, 1]\)</span> and satisfy the orthogonality condition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\int_{-1}^{1} P_n(x) P_m(x) \, dx = 
\begin{cases}
0 &amp; \text{if } n \neq m, \\
\frac{2}{2n + 1} &amp; \text{if } n = m.
\end{cases}
\end{split}\]</div>
<p>They can be generated using the recurrence relation:</p>
<div class="math notranslate nohighlight">
\[
(n+1) P_{n+1}(x) = (2n + 1) x P_n(x) - n P_{n-1}(x),
\]</div>
<p>with initial conditions:</p>
<div class="math notranslate nohighlight">
\[
P_0(x) = 1, \quad P_1(x) = x.
\]</div>
<p>The first four Legendre polynomials resulting from this recurrence are the following:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">IPython.display</span><span class="w"> </span><span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">Math</span>

<span class="k">def</span><span class="w"> </span><span class="nf">legendre_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">p0</span><span class="p">)</span> <span class="o">/</span> <span class="n">k</span>
            <span class="n">p0</span><span class="p">,</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span>
        <span class="k">return</span> <span class="n">p1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">legendre_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># Define a poly1d object to represent x</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">legendre_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">poly</span>

<span class="k">def</span><span class="w"> </span><span class="nf">poly_to_latex</span><span class="p">(</span><span class="n">poly</span><span class="p">):</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">coefficients</span>
    <span class="n">variable</span> <span class="o">=</span> <span class="n">poly</span><span class="o">.</span><span class="n">variable</span>
    
    <span class="n">terms</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
        <span class="n">power</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">coeff_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coeff</span><span class="si">:</span><span class="s2">.2g</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">coeff</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="ow">or</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="k">if</span> <span class="n">coeff</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coeff_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="n">power</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coeff_str</span><span class="si">}{</span><span class="n">variable</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">term</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">coeff_str</span><span class="si">}{</span><span class="n">variable</span><span class="si">}</span><span class="s2">^</span><span class="si">{</span><span class="n">power</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">terms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term</span><span class="p">)</span>
    
    <span class="n">latex_poly</span> <span class="o">=</span> <span class="s2">&quot; + &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">terms</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; + -&quot;</span><span class="p">,</span> <span class="s2">&quot; - &quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">latex_poly</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">legendre_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">Math</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">(x) = </span><span class="si">{</span><span class="n">poly_to_latex</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle P_0(x) = 1\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle P_1(x) = x\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle P_2(x) = 1.5x^2 - 0.5\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle P_3(x) = 2.5x^3 - 1.5x\]</div>
</div>
</div>
</section>
<section id="chebyshev-polynomials">
<h4>Chebyshev Polynomials<a class="headerlink" href="#chebyshev-polynomials" title="Link to this heading">#</a></h4>
<p>There are two types of Chebyshev polynomials: <strong>Chebyshev polynomials of the first kind</strong>, <span class="math notranslate nohighlight">\( \{ T_n(x) \} \)</span>, and <strong>Chebyshev polynomials of the second kind</strong>, <span class="math notranslate nohighlight">\( \{ U_n(x) \} \)</span>. We typically focus on the first kind. They are defined on the interval <span class="math notranslate nohighlight">\([-1, 1]\)</span> and satisfy the orthogonality condition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\int_{-1}^{1} \frac{T_n(x) T_m(x)}{\sqrt{1 - x^2}} \, dx = 
\begin{cases}
0 &amp; \text{if } n \neq m, \\
\frac{\pi}{2} &amp; \text{if } n = m \neq 0, \\
\pi &amp; \text{if } n = m = 0.
\end{cases}
\end{split}\]</div>
<p>The Chebyshev polynomials of the first kind can be generated using the recurrence relation:</p>
<div class="math notranslate nohighlight">
\[
T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x),
\]</div>
<p>with initial conditions:</p>
<div class="math notranslate nohighlight">
\[
T_0(x) = 1, \quad T_1(x) = x.
\]</div>
<p>Remarkably, this recurrence relation also admits an explicit formula:</p>
<div class="math notranslate nohighlight">
\[
T_n(x) = \cos(n \cos^{-1}(x)).
\]</div>
<p>Let’s now implement it in Python:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">chebyshev_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">t1</span> <span class="o">-</span> <span class="n">t0</span>
            <span class="n">t0</span><span class="p">,</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span>
        <span class="k">return</span> <span class="n">t1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">chebyshev_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># Define a poly1d object to represent x</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">chebyshev_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">poly</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">chebyshev_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">Math</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">(x) = </span><span class="si">{</span><span class="n">poly_to_latex</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle T_0(x) = 1\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle T_1(x) = x\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle T_2(x) = 2x^2 - 1\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle T_3(x) = 4x^3 - 3x\]</div>
</div>
</div>
</section>
<section id="hermite-polynomials">
<h4>Hermite Polynomials<a class="headerlink" href="#hermite-polynomials" title="Link to this heading">#</a></h4>
<p>Hermite polynomials <span class="math notranslate nohighlight">\( \{ H_n(x) \} \)</span> are defined on the entire real line and are orthogonal with respect to the weight function <span class="math notranslate nohighlight">\( w(x) = e^{-x^2} \)</span>. They satisfy the orthogonality condition:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\int_{-\infty}^{\infty} H_n(x) H_m(x) e^{-x^2} \, dx = 
\begin{cases}
0 &amp; \text{if } n \neq m, \\
2^n n! \sqrt{\pi} &amp; \text{if } n = m.
\end{cases}
\end{split}\]</div>
<p>Hermite polynomials can be generated using the recurrence relation:</p>
<div class="math notranslate nohighlight">
\[
H_{n+1}(x) = 2x H_n(x) - 2n H_{n-1}(x),
\]</div>
<p>with initial conditions:</p>
<div class="math notranslate nohighlight">
\[
H_0(x) = 1, \quad H_1(x) = 2x.
\]</div>
<p>The following code computes the coefficients of the first four Hermite polynomials:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">hermite_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">h0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">h1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">h2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">*</span> <span class="n">h1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h0</span>
            <span class="n">h0</span><span class="p">,</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span>
        <span class="k">return</span> <span class="n">h1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">hermite_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># Define a poly1d object to represent x</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">hermite_polynomial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">poly</span>

<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">poly</span> <span class="o">=</span> <span class="n">hermite_coefficients</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">display</span><span class="p">(</span><span class="n">Math</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;H_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">(x) = </span><span class="si">{</span><span class="n">poly_to_latex</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle H_0(x) = 1\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle H_1(x) = 2x\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle H_2(x) = 4x^2 - 2\]</div>
<div class="output text_latex math notranslate nohighlight">
\[\displaystyle H_3(x) = 8x^3 - 12x\]</div>
</div>
</div>
</section>
</section>
</section>
<section id="collocation-conditions">
<h2>Collocation Conditions<a class="headerlink" href="#collocation-conditions" title="Link to this heading">#</a></h2>
<p>Consider a general ODE of the form:</p>
<div class="math notranslate nohighlight">
\[
\dot{y}(t) = f(y(t), t), \quad y(t_0) = y_0,
\]</div>
<p>where <span class="math notranslate nohighlight">\( y(t) \in \mathbb{R}^n \)</span> is the state vector, and <span class="math notranslate nohighlight">\( f: \mathbb{R}^n \times \mathbb{R} \rightarrow \mathbb{R}^n \)</span> is a known function. The goal is to approximate the solution <span class="math notranslate nohighlight">\( y(t) \)</span> over a given interval <span class="math notranslate nohighlight">\([t_0, t_f]\)</span>. Collocation methods achieve this by:</p>
<ol class="arabic">
<li><p><strong>Choosing a basis</strong> to approximate <span class="math notranslate nohighlight">\( y(t) \)</span> using a finite sum of basis functions <span class="math notranslate nohighlight">\( \phi_i(t) \)</span>:</p>
<div class="math notranslate nohighlight">
\[
   y(t) \approx \sum_{i=0}^{N} c_i \phi_i(t),
   \]</div>
<p>where <span class="math notranslate nohighlight">\( \{c_i\} \)</span> are the coefficients to be determined.</p>
</li>
<li><p><strong>Selecting collocation points</strong> <span class="math notranslate nohighlight">\( t_1, t_2, \ldots, t_N \)</span> within the interval <span class="math notranslate nohighlight">\([t_0, t_f]\)</span>. These are typically chosen to be the roots of certain orthogonal polynomials, like Legendre or Chebyshev polynomials, or can be spread equally across the interval.</p></li>
<li><p><strong>Enforcing the ODE at the collocation points</strong> for each <span class="math notranslate nohighlight">\( t_j \)</span>:</p>
<div class="math notranslate nohighlight">
\[
   \dot{y}(t_j) = f(y(t_j), t_j).
   \]</div>
<p>To implement this, we differentiate the approximate solution <span class="math notranslate nohighlight">\( y(t) \)</span> with respect to time:</p>
<div class="math notranslate nohighlight">
\[
   \dot{y}(t) \approx \sum_{i=0}^{N} c_i \dot{\phi}_i(t).
   \]</div>
<p>Substituting this into the ODE at the collocation points gives:</p>
<div class="math notranslate nohighlight">
\[
   \sum_{i=0}^{N} c_i \dot{\phi}_i(t_j) = f\left(\sum_{i=0}^{N} c_i \phi_i(t_j), t_j\right), \quad j = 1, \ldots, N.
   \]</div>
</li>
</ol>
<p>The collocation equations are formed by enforcing the ODE at all collocation points, leading to a system of nonlinear equations:</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=0}^{N} c_i \dot{\phi}_i(t_j) - f\left(\sum_{i=0}^{N} c_i \phi_i(t_j), t_j\right) = 0, \quad j = 1, \ldots, N.
\]</div>
<p>Furthermore when solving an initial value problem (IVP),  we also need to incorporate the initial condition <span class="math notranslate nohighlight">\( y(t_0) = y_0 \)</span> as an additional constraint:</p>
<div class="math notranslate nohighlight">
\[
\sum_{i=0}^{N} c_i \phi_i(t_0) = y_0.
\]</div>
<p>The collocation conditions and IVP condition are combined together to form a root-finding problem, which we can generically solve numerically using Newton’s method.</p>
</section>
<section id="common-numerical-integration-techniques-as-collocation-methods">
<h2>Common Numerical Integration Techniques as Collocation Methods<a class="headerlink" href="#common-numerical-integration-techniques-as-collocation-methods" title="Link to this heading">#</a></h2>
<p>Many common numerical integration techniques can be viewed as special cases of collocation methods.
While the general collocation method we discussed earlier applies to the entire interval <span class="math notranslate nohighlight">\([t_0, t_f]\)</span>, many numerical integration techniques can be viewed as collocation methods applied locally, step by step.</p>
<p>In practical numerical integration, we often divide the full interval <span class="math notranslate nohighlight">\([t_0, t_f]\)</span> into smaller subintervals or steps. In general, this allows us to user simpler basis functions thereby reducing computational complexity, and gives us more flexibility in dynamically ajusting the step size using local error estimates. When we apply collocation locally, we’re essentially using the collocation method to “step” from <span class="math notranslate nohighlight">\(t_n\)</span> to <span class="math notranslate nohighlight">\(t_{n+1}\)</span>. As we did, earlier we still apply the following three steps:</p>
<ol class="arabic simple">
<li><p>We choose a basis function to approximate <span class="math notranslate nohighlight">\(y(t)\)</span> over <span class="math notranslate nohighlight">\([t_n, t_{n+1}]\)</span>.</p></li>
<li><p>We select collocation points within this interval.</p></li>
<li><p>We enforce the ODE at these points to determine the coefficients of our basis function.</p></li>
</ol>
<p>We can make this idea clearer by re-deriving some of the numerical integration methods seen before using this perspective.</p>
<section id="explicit-euler-method">
<h3>Explicit Euler Method<a class="headerlink" href="#explicit-euler-method" title="Link to this heading">#</a></h3>
<p>For the Explicit Euler method, we use a linear basis function for each step:</p>
<div class="math notranslate nohighlight">
\[
\phi(t) = 1 + c(t - t_n)
\]</div>
<p>Note that we use <span class="math notranslate nohighlight">\((t - t_n)\)</span> rather than just <span class="math notranslate nohighlight">\(t\)</span> because we’re approximating the solution locally, relative to the start of each step. We then choose one collocation point at <span class="math notranslate nohighlight">\(t_{n+1}\)</span> where we have:</p>
<div class="math notranslate nohighlight">
\[
y'(t_{n+1}) = c = f(y_n, t_n)
\]</div>
<p>Our local approximation is:</p>
<div class="math notranslate nohighlight">
\[
y(t) \approx y_n + c(t - t_n)
\]</div>
<p>At <span class="math notranslate nohighlight">\(t = t_{n+1}\)</span>, this gives:</p>
<div class="math notranslate nohighlight">
\[
y_{n+1} = y_n + c(t_{n+1} - t_n) = y_n + hf(y_n, t_n)
\]</div>
<p>where <span class="math notranslate nohighlight">\(h = t_{n+1} - t_n\)</span>. This is the classic Euler update formula.</p>
</section>
<section id="implicit-euler-method">
<h3>Implicit Euler Method<a class="headerlink" href="#implicit-euler-method" title="Link to this heading">#</a></h3>
<p>The Implicit Euler method uses the same linear basis function:</p>
<div class="math notranslate nohighlight">
\[
\phi(t) = 1 + c(t - t_n)
\]</div>
<p>Again, we choose one collocation point at <span class="math notranslate nohighlight">\(t_{n+1}\)</span>. The main difference is that we enforce the ODE using <span class="math notranslate nohighlight">\(y_{n+1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
y'(t_{n+1}) = c = f(y_{n+1}, t_{n+1})
\]</div>
<p>Our approximation remains:</p>
<div class="math notranslate nohighlight">
\[
y(t) \approx y_n + c(t - t_n)
\]</div>
<p>At <span class="math notranslate nohighlight">\(t = t_{n+1}\)</span>, this leads to the implicit equation:</p>
<div class="math notranslate nohighlight">
\[
y_{n+1} = y_n + hf(y_{n+1}, t_{n+1})
\]</div>
</section>
<section id="trapezoidal-method">
<h3>Trapezoidal Method<a class="headerlink" href="#trapezoidal-method" title="Link to this heading">#</a></h3>
<p>The Trapezoidal method uses a quadratic basis function:</p>
<div class="math notranslate nohighlight">
\[
\phi(t) = 1 + c(t - t_n) + a(t - t_n)^2
\]</div>
<p>We use two collocation points: <span class="math notranslate nohighlight">\(t_n\)</span> and <span class="math notranslate nohighlight">\(t_{n+1}\)</span>. Enforcing the ODE at these points gives:</p>
<ul class="simple">
<li><p>At <span class="math notranslate nohighlight">\(t_n\)</span>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
y'(t_n) = c = f(y_n, t_n)
\]</div>
<ul class="simple">
<li><p>At <span class="math notranslate nohighlight">\(t_{n+1}\)</span>:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
y'(t_{n+1}) = c + 2ah = f(y_n + ch + ah^2, t_{n+1})
\]</div>
<p>Our approximation is:</p>
<div class="math notranslate nohighlight">
\[
y(t) \approx y_n + c(t - t_n) + a(t - t_n)^2
\]</div>
<p>At <span class="math notranslate nohighlight">\(t = t_{n+1}\)</span>, this gives:</p>
<div class="math notranslate nohighlight">
\[
y_{n+1} = y_n + ch + ah^2
\]</div>
<p>Solving the system of equations leads to the trapezoidal update:</p>
<div class="math notranslate nohighlight">
\[
y_{n+1} = y_n + \frac{h}{2}[f(y_n, t_n) + f(y_{n+1}, t_{n+1})]
\]</div>
</section>
<section id="runge-kutta-methods">
<h3>Runge-Kutta Methods<a class="headerlink" href="#runge-kutta-methods" title="Link to this heading">#</a></h3>
<p>Higher-order Runge-Kutta methods can also be interpreted as collocation methods. The RK4 method corresponds to a collocation method using a cubic polynomial basis:</p>
<div class="math notranslate nohighlight">
\[
\phi(t) = 1 + c_1(t - t_n) + c_2(t - t_n)^2 + c_3(t - t_n)^3
\]</div>
<p>Here, we’re using a cubic polynomial to approximate the solution over each step, rather than the linear or quadratic approximations of the other methods above. For RK4, we use four collocation points:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(t_n\)</span> (the start of the step)</p></li>
<li><p><span class="math notranslate nohighlight">\(t_n + h/2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(t_n + h/2\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(t_n + h\)</span> (the end of the step)</p></li>
</ol>
<p>These points are called the “Gauss-Lobatto” points, scaled to our interval <span class="math notranslate nohighlight">\([t_n, t_n + h]\)</span>.
The RK4 method enforces the ODE at these collocation points, leading to four stages:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
k_1 &amp;= hf(y_n, t_n) \\
k_2 &amp;= hf(y_n + \frac{1}{2}k_1, t_n + \frac{h}{2}) \\
k_3 &amp;= hf(y_n + \frac{1}{2}k_2, t_n + \frac{h}{2}) \\
k_4 &amp;= hf(y_n + k_3, t_n + h)
\end{aligned}
\end{split}\]</div>
<p>The final update formula for RK4 can be derived by solving the system of equations resulting from enforcing the ODE at our collocation points:</p>
<div class="math notranslate nohighlight">
\[
y_{n+1} = y_n + \frac{1}{6}(k_1 + 2k_2 + 2k_3 + k_4)
\]</div>
</section>
</section>
<section id="example-solving-a-simple-ode-by-collocation">
<h2>Example: Solving a Simple ODE by Collocation<a class="headerlink" href="#example-solving-a-simple-ode-by-collocation" title="Link to this heading">#</a></h2>
<p>Consider a simple ODE:</p>
<div class="math notranslate nohighlight">
\[
\frac{dy}{dt} = -y, \quad y(0) = 1, \quad t \in [0, 2]
\]</div>
<p>The analytical solution is <span class="math notranslate nohighlight">\(y(t) = e^{-t}\)</span>. We apply the collocation method with a monomial basis of order <span class="math notranslate nohighlight">\(N\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\phi_i(t) = t^i, \quad i = 0, 1, \ldots, N
\]</div>
<p>We select <span class="math notranslate nohighlight">\(N\)</span> equally spaced points <span class="math notranslate nohighlight">\(\{t_1, \ldots, t_N\}\)</span> in <span class="math notranslate nohighlight">\([0, 2]\)</span> as collocation points.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">root</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ode_function</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Define the ODE: dy/dt = -y&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">y</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_ode_collocation</span><span class="p">(</span><span class="n">ode_func</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">order</span><span class="p">):</span>
    <span class="n">t0</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="n">t_span</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># number of collocation points</span>
    <span class="n">t_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="n">n_points</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">collocation_residuals</span><span class="p">(</span><span class="n">coeffs</span><span class="p">):</span>
        <span class="n">residuals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Initial condition residual</span>
        <span class="n">y_init</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
        <span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_init</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>
        <span class="c1"># Collocation point residuals</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">t_points</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>  <span class="c1"># Skip the first point as it&#39;s used for initial condition</span>
            <span class="n">y</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
            <span class="n">dy_dt</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">residuals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dy_dt</span> <span class="o">-</span> <span class="n">ode_func</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">residuals</span>

    <span class="c1"># Initial guess for coefficients</span>
    <span class="n">initial_coeffs</span> <span class="o">=</span> <span class="p">[</span><span class="n">y0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">order</span>

    <span class="c1"># Solve the system of equations</span>
    <span class="n">solution</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">collocation_residuals</span><span class="p">,</span> <span class="n">initial_coeffs</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to converge to a solution.&quot;</span><span class="p">)</span>

    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">x</span>

    <span class="c1"># Generate solution</span>
    <span class="n">t_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t0</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
    <span class="n">y_solution</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t_fine</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">t_fine</span><span class="p">,</span> <span class="n">y_solution</span><span class="p">,</span> <span class="n">t_points</span><span class="p">,</span> <span class="n">coeffs</span>

<span class="c1"># Example usage</span>
<span class="n">t_span</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">y0</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">orders</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="c1"># Different polynomial orders to try</span>

<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t_collocation</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">solve_ode_collocation</span><span class="p">(</span><span class="n">ode_function</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    
    <span class="c1"># Calculate y values at collocation points</span>
    <span class="n">y_collocation</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">c</span> <span class="o">*</span> <span class="n">t_collocation</span><span class="o">**</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coeffs</span><span class="p">))</span>
    
    <span class="c1"># Plot the results</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">t_collocation</span><span class="p">,</span> <span class="n">y_collocation</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

<span class="c1"># Plot the analytical solution</span>
<span class="n">t_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">t_span</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">t_span</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">y_analytical</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_analytical</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_analytical</span><span class="p">,</span> <span class="n">y_analytical</span><span class="p">,</span> <span class="s1">&#39;k--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Analytical&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;t&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;ODE Solutions: dy/dt = -y, y(0) = 1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Print error for each order</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Maximum absolute errors:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solve_ode_collocation</span><span class="p">(</span><span class="n">ode_function</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="n">y_true</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="p">)</span>
    <span class="n">max_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_true</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">max_error</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ValueError</span><span class="g g-Whitespace">                                </span>Traceback (most recent call last)
<span class="n">Cell</span> <span class="n">In</span><span class="p">[</span><span class="mi">8</span><span class="p">],</span> <span class="n">line</span> <span class="mi">51</span>
<span class="g g-Whitespace">     </span><span class="mi">48</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="g g-Whitespace">     </span><span class="mi">50</span> <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="n">orders</span><span class="p">:</span>
<span class="ne">---&gt; </span><span class="mi">51</span>     <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t_collocation</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">solve_ode_collocation</span><span class="p">(</span><span class="n">ode_function</span><span class="p">,</span> <span class="n">t_span</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">53</span>     <span class="c1"># Calculate y values at collocation points</span>
<span class="nn">     54     y_collocation = sum(c * t_collocation**i for i, c</span> in <span class="ni">enumerate</span><span class="nt">(coeffs))</span>

<span class="nn">Cell In[8], line 33,</span> in <span class="ni">solve_ode_collocation</span><span class="nt">(ode_func, t_span, y0, order)</span>
<span class="g g-Whitespace">     </span><span class="mi">30</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">root</span><span class="p">(</span><span class="n">collocation_residuals</span><span class="p">,</span> <span class="n">initial_coeffs</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">32</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">solution</span><span class="o">.</span><span class="n">success</span><span class="p">:</span>
<span class="ne">---&gt; </span><span class="mi">33</span>     <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Failed to converge to a solution.&quot;</span><span class="p">)</span>
<span class="g g-Whitespace">     </span><span class="mi">35</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">solution</span><span class="o">.</span><span class="n">x</span>
<span class="g g-Whitespace">     </span><span class="mi">37</span> <span class="c1"># Generate solution</span>

<span class="ne">ValueError</span>: Failed to converge to a solution.
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;Figure size 1200x800 with 0 Axes&gt;
</pre></div>
</div>
</div>
</div>
</section>
</section>
<section id="nonlinear-programming">
<h1>Nonlinear Programming<a class="headerlink" href="#nonlinear-programming" title="Link to this heading">#</a></h1>
<p>Unless specific assumptions are made on the dynamics and cost structure, a DOCP is, in its most general form, a nonlinear mathematical program (commonly referred to as an NLP, not to be confused with Natural Language Processing). An NLP can be formulated as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize } &amp; f(\mathbf{x}) \\
\text{subject to } &amp; \mathbf{g}(\mathbf{x}) \leq \mathbf{0} \\
&amp; \mathbf{h}(\mathbf{x}) = \mathbf{0}
\end{aligned}
\end{split}\]</div>
<p>Where:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(f: \mathbb{R}^n \to \mathbb{R}\)</span> is the objective function</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{g}: \mathbb{R}^n \to \mathbb{R}^m\)</span> represents inequality constraints</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{h}: \mathbb{R}^n \to \mathbb{R}^\ell\)</span> represents equality constraints</p></li>
</ul>
<p>Unlike unconstrained optimization commonly used in deep learning, the optimality of a solution in constrained optimization must consider both the objective value and constraint feasibility. To illustrate this, consider the following problem, which includes both equality and inequality constraints:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{align*}
\text{Minimize} \quad &amp; f(x_1, x_2) = (x_1 - 1)^2 + (x_2 - 2.5)^2 \\
\text{subject to} \quad &amp; g(x_1, x_2) = (x_1 - 1)^2 + (x_2 - 1)^2 \leq 1.5, \\
&amp; h(x_1, x_2) = x_2 - \left(0.5 \sin(2 \pi x_1) + 1.5\right) = 0.
\end{align*}
\end{split}\]</div>
<p>In this example, the objective function <span class="math notranslate nohighlight">\(f(x_1, x_2)\)</span> is quadratic, the inequality constraint <span class="math notranslate nohighlight">\(g(x_1, x_2)\)</span> defines a circular feasible region centered at <span class="math notranslate nohighlight">\((1, 1)\)</span> with a radius of <span class="math notranslate nohighlight">\(\sqrt{1.5}\)</span> and the equality constraint <span class="math notranslate nohighlight">\(h(x_1, x_2)\)</span> requires <span class="math notranslate nohighlight">\(x_2\)</span> to lie on a sine wave function. The following code demonstrates the difference between the unconstrained, and constrained solutions to this problem.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>

<span class="c1"># Define the objective function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Define the inequality constraint function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">constraint</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1.5</span>

<span class="c1"># Define the gradient of the objective function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">objective_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)])</span>

<span class="c1"># Define the gradient of the inequality constraint function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">constraint_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># Define the sine wave equality constraint function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sine_wave_equality_constraint</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># Define the gradient of the sine wave equality constraint function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sine_wave_equality_constraint_gradient</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Define the constraints including the sine wave equality constraint</span>
<span class="n">sine_wave_constraints</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">constraint</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">constraint_gradient</span><span class="p">},</span>  <span class="c1"># Inequality constraint</span>
                         <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">sine_wave_equality_constraint</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">sine_wave_equality_constraint_gradient</span><span class="p">}]</span>  <span class="c1"># Sine wave equality constraint</span>

<span class="c1"># Define only the inequality constraint</span>
<span class="n">inequality_constraints</span> <span class="o">=</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">constraint</span><span class="p">,</span> <span class="s1">&#39;jac&#39;</span><span class="p">:</span> <span class="n">constraint_gradient</span><span class="p">}]</span>

<span class="c1"># Initial guess</span>
<span class="n">x0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.25</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]</span>

<span class="c1"># Solve the optimization problem with the sine wave equality constraint</span>
<span class="n">res_sine_wave_constraint</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">objective_gradient</span><span class="p">,</span> 
                                    <span class="n">constraints</span><span class="o">=</span><span class="n">sine_wave_constraints</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

<span class="n">x_opt_sine_wave_constraint</span> <span class="o">=</span> <span class="n">res_sine_wave_constraint</span><span class="o">.</span><span class="n">x</span>

<span class="c1"># Solve the optimization problem with only the inequality constraint</span>
<span class="n">res_inequality_only</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">objective_gradient</span><span class="p">,</span> 
                               <span class="n">constraints</span><span class="o">=</span><span class="n">inequality_constraints</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

<span class="n">x_opt_inequality_only</span> <span class="o">=</span> <span class="n">res_inequality_only</span><span class="o">.</span><span class="n">x</span>

<span class="c1"># Solve the unconstrained optimization problem for reference</span>
<span class="n">res_unconstrained</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span> <span class="n">jac</span><span class="o">=</span><span class="n">objective_gradient</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>
<span class="n">x_opt_unconstrained</span> <span class="o">=</span> <span class="n">res_unconstrained</span><span class="o">.</span><span class="n">x</span>

<span class="c1"># Generate data for visualization</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># Objective function values</span>
<span class="n">constraint_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># Data for sine wave constraint</span>
<span class="n">x_sine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">400</span><span class="p">)</span>
<span class="n">y_sine</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">x_sine</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span>

<span class="c1"># Visualization with Improved Color Scheme</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">)</span>  <span class="c1"># Heatmap for the objective function</span>

<span class="c1"># Plot all the optimal points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_inequality_only</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_inequality_only</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimal Solution (Inequality Only)&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_sine_wave_constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_sine_wave_constraint</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;mo&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimal Solution (Sine Wave Equality &amp; Inequality)&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_unconstrained</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_unconstrained</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;co&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Unconstrained Minimum&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">markeredgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>

<span class="c1"># Adjust constraint boundary colors</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contour</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">constraint_values</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;navy&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">constraint_values</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;skyblue&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Plot the sine wave equality constraint with a high contrast color</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_sine</span><span class="p">,</span> <span class="n">y_sine</span><span class="p">,</span> <span class="s1">&#39;lime&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sine Wave Equality Constraint&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Example NLP&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper left&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span> <span class="n">fancybox</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Set the aspect ratio to be equal so the circle appears correctly</span>
<span class="n">plt</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">adjustable</span><span class="o">=</span><span class="s1">&#39;box&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
<section id="karush-kuhn-tucker-kkt-conditions">
<h2>Karush-Kuhn-Tucker (KKT) conditions<a class="headerlink" href="#karush-kuhn-tucker-kkt-conditions" title="Link to this heading">#</a></h2>
<p>While this example is simple enough to convince ourselves visually of the solution to this particular problem, it falls short of providing us with actionable chracterization of what constitutes and optimal solution in general.
The Karush-Kuhn-Tucker (KKT) conditions provide us with an answer to this problem by generalizing the first-order optimality conditions in unconstrained optimization to problems involving both equality and inequality constraints.
This result relies on the construction of an auxiliary function called the Lagrangian, defined as:</p>
<div class="math notranslate nohighlight">
\[\mathcal{L}(\mathbf{x}, \boldsymbol{\mu}, \boldsymbol{\lambda})=f(\mathbf{x})+\boldsymbol{\mu}^{\top} \mathbf{g}(\mathbf{x})+\boldsymbol{\lambda}^{\top} \mathbf{h}(\mathbf{x})\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\mu} \in \mathbb{R}^m\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\lambda} \in \mathbb{R}^\ell\)</span> are known as Lagrange multipliers. The first-order optimality conditions then state that if <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>, then there must exist corresponding Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^*\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^*\)</span> such that:</p>
<div class="proof definition admonition" id="kkt-conditions">
<p class="admonition-title"><span class="caption-number">Definition 4 </span></p>
<section class="definition-content" id="proof-content">
<ol class="arabic">
<li><p>The gradient of the Lagrangian with respect to <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> must be zero at the optimal point (<strong>stationarity</strong>):</p>
<div class="math notranslate nohighlight">
\[\nabla_x \mathcal{L}(\mathbf{x}^*, \boldsymbol{\mu}^*, \boldsymbol{\lambda}^*) = \nabla f(\mathbf{x}^*) + \sum_{i=1}^m \mu_i^* \nabla g_i(\mathbf{x}^*) + \sum_{j=1}^\ell \lambda_j^* \nabla h_j(\mathbf{x}^*) = \mathbf{0}\]</div>
<p>In the case where we only have equality constraints, this means that the gradient of the objective and that of constraint are parallel to each other at the optimum but point in opposite directions.</p>
</li>
<li><p>A valid solution of a NLP is one which satisfies all the constraints (<strong>primal feasibility</strong>)</p>
<div class="math notranslate nohighlight">
\[\begin{aligned}
   \mathbf{g}(\mathbf{x}^*) &amp;\leq \mathbf{0}, \enspace \text{and} \enspace \mathbf{h}(\mathbf{x}^*) &amp;= \mathbf{0}
   \end{aligned}\]</div>
</li>
<li><p>Furthermore, the Lagrange multipliers for <strong>inequality</strong> constraints must be non-negative (<strong>dual feasibility</strong>)</p>
<div class="math notranslate nohighlight">
\[\boldsymbol{\mu}^* \geq \mathbf{0}\]</div>
<p>This condition stems from the fact that the inequality constraints can only push the solution in one direction.</p>
</li>
<li><p>Finally, for each inequality constraint, either the constraint is active (equality holds) or its corresponding Lagrange multiplier is zero at an optimal solution (<strong>complementary slackness</strong>)</p>
<div class="math notranslate nohighlight">
\[\mu_i^* g_i(\mathbf{x}^*) = 0, \quad \forall i = 1,\ldots,m\]</div>
</li>
</ol>
</section>
</div><p>Let’s now solve our example problem above, this time using <a class="reference external" href="https://coin-or.github.io/Ipopt/">Ipopt</a> via the <a class="reference external" href="http://www.pyomo.org/">Pyomo</a> interface so that we can access the Lagrange multipliers found by the solver.</p>
<div class="cell tag_hide-cell docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell content</span>
<span class="expanded">Hide code cell content</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.environ</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pyomo.opt</span><span class="w"> </span><span class="kn">import</span> <span class="n">SolverFactory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">myst_nb</span><span class="w"> </span><span class="kn">import</span> <span class="n">glue</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="c1"># Define the Pyomo model</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">ConcreteModel</span><span class="p">()</span>

<span class="c1"># Define the variables</span>
<span class="n">model</span><span class="o">.</span><span class="n">x1</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mf">1.25</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">x2</span> <span class="o">=</span> <span class="n">Var</span><span class="p">(</span><span class="n">initialize</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>

<span class="c1"># Define the objective function</span>
<span class="k">def</span><span class="w"> </span><span class="nf">objective_rule</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x2</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
<span class="n">model</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">Objective</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">objective_rule</span><span class="p">,</span> <span class="n">sense</span><span class="o">=</span><span class="n">minimize</span><span class="p">)</span>

<span class="c1"># Define the inequality constraint (circle)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">inequality_constraint_rule</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;=</span> <span class="mf">1.5</span>
<span class="n">model</span><span class="o">.</span><span class="n">ineq_constraint</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">inequality_constraint_rule</span><span class="p">)</span>

<span class="c1"># Define the equality constraint (sine wave) using Pyomo&#39;s math functions</span>
<span class="k">def</span><span class="w"> </span><span class="nf">equality_constraint_rule</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">model</span><span class="o">.</span><span class="n">x2</span> <span class="o">==</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">model</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.5</span>
<span class="n">model</span><span class="o">.</span><span class="n">eq_constraint</span> <span class="o">=</span> <span class="n">Constraint</span><span class="p">(</span><span class="n">rule</span><span class="o">=</span><span class="n">equality_constraint_rule</span><span class="p">)</span>

<span class="c1"># Create a suffix component to capture dual values</span>
<span class="n">model</span><span class="o">.</span><span class="n">dual</span> <span class="o">=</span> <span class="n">Suffix</span><span class="p">(</span><span class="n">direction</span><span class="o">=</span><span class="n">Suffix</span><span class="o">.</span><span class="n">IMPORT</span><span class="p">)</span>

<span class="c1"># Create a solver</span>
<span class="n">solver</span><span class="o">=</span><span class="n">SolverFactory</span><span class="p">(</span><span class="s1">&#39;ipopt&#39;</span><span class="p">)</span>

<span class="c1"># Solve the problem</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">tee</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Check if the solver found an optimal solution</span>
<span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="n">SolverStatus</span><span class="o">.</span><span class="n">ok</span> <span class="ow">and</span> 
    <span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span> <span class="o">==</span> <span class="n">TerminationCondition</span><span class="o">.</span><span class="n">optimal</span><span class="p">):</span>
    
    <span class="c1"># Print the results</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x1: </span><span class="si">{</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x2: </span><span class="si">{</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">x2</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Print the objective value</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objective value: </span><span class="si">{</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Print the Lagrange multipliers (dual values)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Lagrange multipliers:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">component_objects</span><span class="p">(</span><span class="n">Constraint</span><span class="p">,</span> <span class="n">active</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]: </span><span class="si">{</span><span class="n">model</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">glue</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">dual</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">index</span><span class="p">]],</span> <span class="n">display</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Solver did not find an optimal solution.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Solver Status: </span><span class="si">{</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Termination Condition: </span><span class="si">{</span><span class="n">results</span><span class="o">.</span><span class="n">solver</span><span class="o">.</span><span class="n">termination_condition</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
<p>After running the code, we find that the Lagrange multiplier associated with the inequality constraint is approximately . This very small value, close to zero, suggests that the inequality constraint is not active at the optimal solution, meaning that the solution point lies inside the circle defined by this constraint. This can be verified visually in the figure above. As for the equality constraint, its corresponding Lagrange multiplier is  and the fact that it’s non-zero indicates that this constraint is active at the optimal solution. In general when we find a Lagrange multiplier close to zero (like the one for the inequality constraint), it means that constraint is not “binding”—the optimal solution does not lie on the boundary defined by this constraint. In contrast, a non-zero Lagrange multiplier, such as the one for the equality constraint, indicates that the constraint is active and that any relaxation would directly affect the objective function’s value, as required by the stationarity condition.</p>
</section>
<section id="lagrange-multiplier-theorem">
<h2>Lagrange Multiplier Theorem<a class="headerlink" href="#lagrange-multiplier-theorem" title="Link to this heading">#</a></h2>
<p>The KKT conditions introduced above characterize the solution structure of constrained optimization problems with equality constraints. In this particular context, these conditions are referred to as the first-order optimality conditions, as part of the Lagrange multiplier theorem. Let’s just re-state them in that simpler setting:</p>
<div class="proof definition admonition" id="definition-4">
<p class="admonition-title"><span class="caption-number">Definition 5 </span> (Lagrange Multiplier Theorem)</p>
<section class="definition-content" id="proof-content">
<p>Consider the constrained optimization problem:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mathbf{x}} \quad &amp; f(\mathbf{x}) \\
\text{subject to} \quad &amp; h_i(\mathbf{x}) = 0, \quad i = 1, \ldots, m
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{x} \in \mathbb{R}^n\)</span>, <span class="math notranslate nohighlight">\(f: \mathbb{R}^n \to \mathbb{R}\)</span>, and <span class="math notranslate nohighlight">\(h_i: \mathbb{R}^n \to \mathbb{R}\)</span> for <span class="math notranslate nohighlight">\(i = 1, \ldots, m\)</span>.</p>
<p>Assume that:</p>
<ol class="arabic simple">
<li><p><span class="math notranslate nohighlight">\(f\)</span> and <span class="math notranslate nohighlight">\(h_i\)</span> are continuously differentiable functions.</p></li>
<li><p>The gradients <span class="math notranslate nohighlight">\(\nabla h_i(\mathbf{x}^*)\)</span> are linearly independent at the optimal point <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>.</p></li>
</ol>
<p>Then, there exist unique Lagrange multipliers <span class="math notranslate nohighlight">\(\lambda_i^* \in \mathbb{R}\)</span>, <span class="math notranslate nohighlight">\(i = 1, \ldots, m\)</span>, such that the following first-order optimality conditions hold:</p>
<ol class="arabic simple">
<li><p>Stationarity: <span class="math notranslate nohighlight">\(\nabla f(\mathbf{x}^*) + \sum_{i=1}^m \lambda_i^* \nabla h_i(\mathbf{x}^*) = \mathbf{0}\)</span></p></li>
<li><p>Primal feasibility: <span class="math notranslate nohighlight">\(h_i(\mathbf{x}^*) = 0\)</span>, for <span class="math notranslate nohighlight">\(i = 1, \ldots, m\)</span></p></li>
</ol>
</section>
</div><p>Note that both the stationarity and primal feasibility statements are simply saying that the derivative of the Lagrangian in either the primal or dual variables must be zero at an optimal constrained solution. In other words:</p>
<div class="math notranslate nohighlight">
\[
\nabla_{\mathbf{x}, \boldsymbol{\lambda}} L(\mathbf{x}^*, \boldsymbol{\lambda}^*) = \mathbf{0}
\]</div>
<p>Letting <span class="math notranslate nohighlight">\(\mathbf{F}(\mathbf{x}, \boldsymbol{\lambda})\)</span> stand for <span class="math notranslate nohighlight">\(\nabla_{\mathbf{x}, \boldsymbol{\lambda}} L(\mathbf{x}, \boldsymbol{\lambda})\)</span>, the Lagrange multipliers theorem tells us that an optimal primal-dual pair is actually a zero of that function <span class="math notranslate nohighlight">\(\mathbf{F}\)</span>: the derivative of the Lagrangian. Therefore, we can use this observation to craft a solution method for solving equality constrained optimization using Newton’s method, which is a numerical procedure for finding zeros of a nonlinear function.</p>
</section>
<section id="newton-s-method">
<h2>Newton’s Method<a class="headerlink" href="#newton-s-method" title="Link to this heading">#</a></h2>
<p>Newton’s method is a numerical procedure for solving root-finding problems. These are nonlinear systems of equations of the form:</p>
<p>Find <span class="math notranslate nohighlight">\(\mathbf{z}^* \in \mathbb{R}^n\)</span> such that <span class="math notranslate nohighlight">\(\mathbf{F}(\mathbf{z}^*) = \mathbf{0}\)</span></p>
<p>where <span class="math notranslate nohighlight">\(\mathbf{F}: \mathbb{R}^n \to \mathbb{R}^n\)</span> is a continuously differentiable function. Newton’s method then consists in applying the following sequence of iterates:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{z}^{k+1} = \mathbf{z}^k - [\nabla \mathbf{F}(\mathbf{z}^k)]^{-1} \mathbf{F}(\mathbf{z}^k)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{z}^k\)</span> is the k-th iterate, and <span class="math notranslate nohighlight">\(\nabla \mathbf{F}(\mathbf{z}^k)\)</span> is the Jacobian matrix of <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> evaluated at <span class="math notranslate nohighlight">\(\mathbf{z}^k\)</span>.</p>
<p>Newton’s method exhibits local quadratic convergence: if the initial guess <span class="math notranslate nohighlight">\(\mathbf{z}^0\)</span> is sufficiently close to the true solution <span class="math notranslate nohighlight">\(\mathbf{z}^*\)</span>, and <span class="math notranslate nohighlight">\(\nabla \mathbf{F}(\mathbf{z}^*)\)</span> is nonsingular, the method converges quadratically to <span class="math notranslate nohighlight">\(\mathbf{z}^*\)</span> <span id="id1">[<a class="reference internal" href="bibliography.html#id8" title="J. M. Ortega and W. C. Rheinboldt. Iterative Solution of Nonlinear Equations in Several Variables. Computer Science and Applied Mathematics. Academic Press, New York, 1970.">34</a>]</span>. However, the method is sensitive to the initial guess; if it’s too far from the desired solution, Newton’s method might fail to converge or converge to a different root. To mitigate this problem, a set of techniques known as numerical continuation methods <span id="id2">[<a class="reference internal" href="bibliography.html#id9" title="E. L. Allgower and K. Georg. Numerical Continuation Methods: An Introduction. Volume 13 of Springer Series in Computational Mathematics. Springer-Verlag, Berlin, Heidelberg, 1990.">2</a>]</span> have been developed. These methods effectively enlarge the basin of attraction of Newton’s method by solving a sequence of related problems, progressing from an easy one to the target problem. This approach is reminiscent of several concepts in machine learning and statistical inference: curriculum learning in machine learning, where models are trained on increasingly complex data; tempering in Markov Chain Monte Carlo (MCMC) samplers, which gradually adjusts the target distribution to improve mixing; and modern diffusion models, which use a similar concept of gradually transforming noise into structured data.</p>
<section id="efficient-implementation-of-newton-s-method">
<h3>Efficient Implementation of Newton’s Method<a class="headerlink" href="#efficient-implementation-of-newton-s-method" title="Link to this heading">#</a></h3>
<p>Note that each step of Newton’s method involves computing the inverse of a Jacobian matrix. However, a cardinal rule in numerical linear algebra is to avoid computing matrix inverses explicitly: rarely, if ever, should there be a <code class="docutils literal notranslate"><span class="pre">np.lindex.inv</span></code> in your code. Instead, the numerically stable and computationally efficient approach is to solve a linear system of equations at each step.
Given the Newton’s method iterate:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{z}^{k+1} = \mathbf{z}^k - [\nabla \mathbf{F}(\mathbf{z}^k)]^{-1} \mathbf{F}(\mathbf{z}^k)
\]</div>
<p>We can reformulate this as a two-step procedure:</p>
<ol class="arabic simple">
<li><p>Solve the linear system: <span class="math notranslate nohighlight">\(\underbrace{[\nabla \mathbf{F}(\mathbf{z}^k)]}_{\mathbf{A}} \Delta \mathbf{z}^k = -\mathbf{F}(\mathbf{z}^k)\)</span></p></li>
<li><p>Update: <span class="math notranslate nohighlight">\(\mathbf{z}^{k+1} = \mathbf{z}^k + \Delta \mathbf{z}^k\)</span></p></li>
</ol>
<p>The structure of the linear system in step 1 often allows for specialized solution methods. In the context of automatic differentiation, matrix-free linear solvers are particularly useful. These solvers can find a solution without explicitly forming the matrix A, requiring only the ability to evaluate matrix-vector or vector-matrix products. Typical examples of such methods include classical matrix-splitting methods (e.g., Richardson iteration) or conjugate gradient methods through <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.cg.html"><code class="docutils literal notranslate"><span class="pre">sparse.linalg.cg</span></code></a> for example. Another useful method is the Generalized Minimal Residual method (GMRES) implemented in SciPy via <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.gmres.html"><code class="docutils literal notranslate"><span class="pre">sparse.linalg.gmres</span></code></a>, which is useful when facing non-symmetric and indefinite systems.</p>
<p>By inspecting the structure of matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> in the specific application where the function <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> is the derivative of the Lagrangian, we will also uncover an important structure known as the KKT matrix. This structure will then allow us to derive a Quadratic Programming (QP) sub-problem as part of a larger iterative procedure for solving equality and inequality constrained problems via Sequential Quadratic Programming (SQP).</p>
</section>
</section>
<section id="solving-equality-constrained-programs-with-newton-s-method">
<h2>Solving Equality Constrained Programs with Newton’s Method<a class="headerlink" href="#solving-equality-constrained-programs-with-newton-s-method" title="Link to this heading">#</a></h2>
<p>To solve equality-constrained optimization problems using Newton’s method, we begin by recognizing that the problem reduces to finding a zero of the function <span class="math notranslate nohighlight">\(\mathbf{F}(\mathbf{z}) = \nabla_{\mathbf{x}, \boldsymbol{\lambda}} L(\mathbf{x}, \boldsymbol{\lambda})\)</span>. Here, <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> represents the derivative of the Lagrangian function, and <span class="math notranslate nohighlight">\(\mathbf{z} = (\mathbf{x}, \boldsymbol{\lambda})\)</span> combines both the primal variables <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> and the dual variables (Lagrange multipliers) <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}\)</span>. Explicitly, we have:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\mathbf{F}(\mathbf{z}) = \begin{bmatrix} \nabla_{\mathbf{x}} L(\mathbf{x}, \boldsymbol{\lambda}) \\ \mathbf{h}(\mathbf{x}) \end{bmatrix} = \begin{bmatrix} \nabla f(\mathbf{x}) + \sum_{i=1}^m \lambda_i \nabla h_i(\mathbf{x}) \\ \mathbf{h}(\mathbf{x}) \end{bmatrix}.
\end{split}\]</div>
<p>Newton’s method involves linearizing <span class="math notranslate nohighlight">\(\mathbf{F}(\mathbf{z})\)</span> around the current iterate <span class="math notranslate nohighlight">\(\mathbf{z}^k = (\mathbf{x}^k, \boldsymbol{\lambda}^k)\)</span> and then solving the resulting linear system. At each iteration <span class="math notranslate nohighlight">\(k\)</span>, Newton’s method updates the current estimate by solving the linear system:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{z}^{k+1} = \mathbf{z}^k - [\nabla \mathbf{F}(\mathbf{z}^k)]^{-1} \mathbf{F}(\mathbf{z}^k).
\]</div>
<p>However, instead of explicitly inverting the Jacobian matrix <span class="math notranslate nohighlight">\(\nabla \mathbf{F}(\mathbf{z}^k)\)</span>, we solve the linear system:</p>
<div class="math notranslate nohighlight">
\[
\underbrace{\nabla \mathbf{F}(\mathbf{z}^k)}_{\mathbf{A}} \Delta \mathbf{z}^k = -\mathbf{F}(\mathbf{z}^k),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \mathbf{z}^k = (\Delta \mathbf{x}^k, \Delta \boldsymbol{\lambda}^k)\)</span> represents the Newton step for the primal and dual variables. Substituting the expression for <span class="math notranslate nohighlight">\(\mathbf{F}(\mathbf{z})\)</span> and its Jacobian, the system becomes:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k) &amp; \nabla \mathbf{h}(\mathbf{x}^k)^T \\
\nabla \mathbf{h}(\mathbf{x}^k) &amp; \mathbf{0}
\end{bmatrix}
\begin{bmatrix}
\Delta \mathbf{x}^k \\
\Delta \boldsymbol{\lambda}^k
\end{bmatrix}
=
-
\begin{bmatrix}
\nabla f(\mathbf{x}^k) + \nabla \mathbf{h}(\mathbf{x}^k)^T \boldsymbol{\lambda}^k \\
\mathbf{h}(\mathbf{x}^k)
\end{bmatrix}.
\end{split}\]</div>
<p>The matrix on the left-hand side is known as the KKT matrix, as it stems from the Karush-Kuhn-Tucker conditions for this optimization problem
The solution of this system provides the updates <span class="math notranslate nohighlight">\(\Delta \mathbf{x}^k\)</span> and <span class="math notranslate nohighlight">\(\Delta \boldsymbol{\lambda}^k\)</span>, which are then used to update the primal and dual variables:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}^{k+1} = \mathbf{x}^k + \Delta \mathbf{x}^k, \quad \boldsymbol{\lambda}^{k+1} = \boldsymbol{\lambda}^k + \Delta \boldsymbol{\lambda}^k.
\]</div>
<section id="demonstration">
<h3>Demonstration<a class="headerlink" href="#demonstration" title="Link to this heading">#</a></h3>
<p>The following code demonstates how we can implement this idea in Jax. In this demonstration, we are minimizing a quadratic objective function subject to a single equality constraint, a problem formally stated as follows:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{x \in \mathbb{R}^2} \quad &amp; f(x) = (x_1 - 2)^2 + (x_2 - 1)^2 \\
\text{subject to} \quad &amp; h(x) = x_1^2 + x_2^2 - 1 = 0
\end{aligned}
\end{split}\]</div>
<p>Geometrically speaking, the constraint <span class="math notranslate nohighlight">\(h(x)\)</span> describes a unit circle centered at the origin. To solve this problem using the method of Lagrange multipliers, we form the Lagrangian:</p>
<div class="math notranslate nohighlight">
\[
L(x, \lambda) = f(x) + \lambda h(x) = (x_1 - 2)^2 + (x_2 - 1)^2 + \lambda(x_1^2 + x_2^2 - 1)
\]</div>
<p>For this particular problem, it happens so that we can also find an analytical without even having to use Newton’s method. From the first-order optimality conditions, we obtain the following linear system of equations:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
   2(x_1 - 2) + 2\lambda x_1 &amp;= 0 \\
   2(x_2 - 1) + 2\lambda x_2 &amp;= 0 \\
   x_1^2 + x_2^2 - 1 &amp;= 0\\
\end{align*}\]</div>
<p>From the first two equations, we then get:</p>
<div class="math notranslate nohighlight">
\[x_1 = \frac{2}{1 + \lambda}, \quad x_2 = \frac{1}{1 + \lambda}\]</div>
<p>which we can substitute these into the 3rd constraint equation to obtain:</p>
<div class="math notranslate nohighlight">
\[(\frac{2}{1 + \lambda})^2 + (\frac{1}{1 + \lambda})^2 = 1 \Leftrightarrow \lambda = \sqrt{5} - 1$\]</div>
<p>This value of the Lagrange multiplier can then be backsubstituted into the above equations to obtain <span class="math notranslate nohighlight">\(x_1 = \frac{2}{\sqrt{5}}\)</span> and <span class="math notranslate nohighlight">\(x_2 =  \frac{1}{\sqrt{5}}\)</span>.
We can verify numerically (and visually on the following graph) that the point <span class="math notranslate nohighlight">\((2/\sqrt{5}, 1/\sqrt{5})\)</span> is indeed the point on the unit circle closest to <span class="math notranslate nohighlight">\((2, 1)\)</span>.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">jacfwd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Define the objective function and constraint</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>

<span class="c1"># Lagrangian</span>
<span class="k">def</span><span class="w"> </span><span class="nf">L</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">lambda_</span> <span class="o">*</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Gradient and Hessian of Lagrangian</span>
<span class="n">grad_L_x</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">grad_L_lambda</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">hess_L_xx</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">grad_L_x</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">hess_L_xlambda</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">grad_L_x</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

<span class="c1"># Newton&#39;s method</span>
<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">newton_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">):</span>
    <span class="n">grad_x</span> <span class="o">=</span> <span class="n">grad_L_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
    <span class="n">grad_lambda</span> <span class="o">=</span> <span class="n">grad_L_lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
    <span class="n">hess_xx</span> <span class="o">=</span> <span class="n">hess_L_xx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
    <span class="n">hess_xlambda</span> <span class="o">=</span> <span class="n">hess_L_xlambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Construct the full KKT matrix</span>
    <span class="n">kkt_matrix</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">block</span><span class="p">([</span>
        <span class="p">[</span><span class="n">hess_xx</span><span class="p">,</span> <span class="n">hess_xlambda</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)],</span>
        <span class="p">[</span><span class="n">hess_xlambda</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">]])]</span>
    <span class="p">])</span>
    
    <span class="c1"># Construct the right-hand side</span>
    <span class="n">rhs</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="o">-</span><span class="n">grad_x</span><span class="p">,</span> <span class="o">-</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">grad_lambda</span><span class="p">])])</span>
    
    <span class="c1"># Solve the KKT system</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">kkt_matrix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="n">lambda_</span> <span class="o">+</span> <span class="n">delta</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_constrained_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span> <span class="o">=</span> <span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">x_new</span><span class="p">,</span> <span class="n">lambda_new</span> <span class="o">=</span> <span class="n">newton_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_new</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lambda_new</span> <span class="o">-</span> <span class="n">lambda_</span><span class="p">])]))</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span> <span class="o">=</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">lambda_new</span>
    
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

<span class="c1"># Analytical solution</span>
<span class="k">def</span><span class="w"> </span><span class="nf">analytical_solution</span><span class="p">():</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">lambda_opt</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]),</span> <span class="n">lambda_opt</span>

<span class="c1"># Solve the problem numerically</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">lambda0</span> <span class="o">=</span> <span class="mf">0.0</span>
<span class="n">x_opt_num</span><span class="p">,</span> <span class="n">lambda_opt_num</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">solve_constrained_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span><span class="p">)</span>

<span class="c1"># Compute analytical solution</span>
<span class="n">x_opt_ana</span><span class="p">,</span> <span class="n">lambda_opt_ana</span> <span class="o">=</span> <span class="n">analytical_solution</span><span class="p">()</span>

<span class="c1"># Verify the result</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Numerical Solution:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constraint violation: </span><span class="si">{</span><span class="n">g</span><span class="p">(</span><span class="n">x_opt_num</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objective function value: </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x_opt_num</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Analytical Solution:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constraint violation: </span><span class="si">{</span><span class="n">g</span><span class="p">(</span><span class="n">x_opt_ana</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objective function value: </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x_opt_ana</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Comparison:&quot;</span><span class="p">)</span>
<span class="n">x_diff</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_opt_num</span> <span class="o">-</span> <span class="n">x_opt_ana</span><span class="p">)</span>
<span class="n">lambda_diff</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lambda_opt_num</span> <span class="o">-</span> <span class="n">lambda_opt_ana</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Difference in x: </span><span class="si">{</span><span class="n">x_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Difference in lambda: </span><span class="si">{</span><span class="n">lambda_diff</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Precision test</span>
<span class="n">rtol</span> <span class="o">=</span> <span class="mf">1e-5</span>  <span class="c1"># relative tolerance</span>
<span class="n">atol</span> <span class="o">=</span> <span class="mf">1e-8</span>  <span class="c1"># absolute tolerance</span>

<span class="n">x_close</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">x_opt_num</span><span class="p">,</span> <span class="n">x_opt_ana</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
<span class="n">lambda_close</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">lambda_opt_num</span><span class="p">,</span> <span class="n">lambda_opt_ana</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Precision Test:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x values are close: </span><span class="si">{</span><span class="n">x_close</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;lambda values are close: </span><span class="si">{</span><span class="n">lambda_close</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">x_close</span> <span class="ow">and</span> <span class="n">lambda_close</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The numerical solution matches the analytical solution within the specified tolerance.&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The numerical solution differs from the analytical solution more than the specified tolerance.&quot;</span><span class="p">)</span>

<span class="c1"># Visualize the result</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Create a mesh for the contour plot</span>
<span class="n">x1_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x2_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X1</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1_range</span><span class="p">,</span> <span class="n">x2_range</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">f</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="n">x1_range</span><span class="p">]</span> <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">x2_range</span><span class="p">])</span>

<span class="c1"># Plot filled contours</span>
<span class="n">contour</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Objective Function Value&#39;</span><span class="p">)</span>

<span class="c1"># Plot the constraint</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x1</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Constraint&#39;</span><span class="p">)</span>

<span class="c1"># Plot the optimal points (numerical and analytical) and initial point</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_opt_num</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_num</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Numerical Optimal Point&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_opt_ana</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_ana</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Analytical Optimal Point&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Initial Point&#39;</span><span class="p">)</span>

<span class="c1"># Add labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Constrained Optimization: Numerical vs Analytical Solution&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Set the axis limits explicitly</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
<section id="the-sqp-approach-taylor-expansion-and-quadratic-approximation">
<h2>The SQP Approach: Taylor Expansion and Quadratic Approximation<a class="headerlink" href="#the-sqp-approach-taylor-expansion-and-quadratic-approximation" title="Link to this heading">#</a></h2>
<p>Sequential Quadratic Programming (SQP) tackles the problem of solving constrained programs by iteratively solving a sequence of simpler subproblems. Specifically, these subproblems are quadratic programs (QPs) that approximate the original problem around the current iterate by using a quadratic model of the objective function and a linear model of the constraints. Suppose we have the following optimization problem with equality constraints:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mathbf{x}} \quad &amp; f(\mathbf{x}) \\
\text{subject to} \quad &amp; \mathbf{h}(\mathbf{x}) = \mathbf{0}.
\end{aligned}
\end{split}\]</div>
<p>At each iteration <span class="math notranslate nohighlight">\(k\)</span>, we approximate the objective function <span class="math notranslate nohighlight">\(f(\mathbf{x})\)</span> using a second-order Taylor expansion around the current iterate <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span>. The standard Taylor expansion for <span class="math notranslate nohighlight">\(f\)</span> would be:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
f(\mathbf{x}) \approx f(\mathbf{x}^k) + \nabla f(\mathbf{x}^k)^T (\mathbf{x} - \mathbf{x}^k) + \frac{1}{2} (\mathbf{x} - \mathbf{x}^k)^T \nabla^2 f(\mathbf{x}^k) (\mathbf{x} - \mathbf{x}^k).
\end{align*}\]</div>
<p>This expansion uses the <strong>Hessian of the objective function</strong> <span class="math notranslate nohighlight">\(\nabla^2 f(\mathbf{x}^k)\)</span> to capture the curvature of <span class="math notranslate nohighlight">\(f\)</span>. However, in the context of constrained optimization, we also need to account for the effect of the constraints on the local behavior of the solution. If we were to use only <span class="math notranslate nohighlight">\(\nabla^2 f(\mathbf{x}^k)\)</span>, we would not capture the influence of the constraints on the curvature of the feasible region. The resulting subproblem might then lead to steps that violate the constraints or are less effective in achieving convergence. The choice that we make instead is to use the Hessian of the Lagrangian, <span class="math notranslate nohighlight">\(\nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k)\)</span>, leading to the following quadratic model:</p>
<div class="math notranslate nohighlight">
\[
f(\mathbf{x}) \approx f(\mathbf{x}^k) + \nabla f(\mathbf{x}^k)^T (\mathbf{x} - \mathbf{x}^k) + \frac{1}{2} (\mathbf{x} - \mathbf{x}^k)^T \nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k) (\mathbf{x} - \mathbf{x}^k).
\]</div>
<p>Similarly, the equality constraints <span class="math notranslate nohighlight">\(\mathbf{h}(\mathbf{x})\)</span> are linearized around <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{h}(\mathbf{x}) \approx \mathbf{h}(\mathbf{x}^k) + \nabla \mathbf{h}(\mathbf{x}^k) (\mathbf{x} - \mathbf{x}^k).
\]</div>
<p>Combining these approximations, we obtain a Quadratic Programming (QP) subproblem, which approximates our original problem locally at <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span> but is easier to solve:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{Minimize} \quad &amp; \nabla f(\mathbf{x}^k)^T \Delta \mathbf{x} + \frac{1}{2} \Delta \mathbf{x}^T \nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k) \Delta \mathbf{x} \\
\text{subject to} \quad &amp; \nabla \mathbf{h}(\mathbf{x}^k) \Delta \mathbf{x} + \mathbf{h}(\mathbf{x}^k) = \mathbf{0},
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \mathbf{x} = \mathbf{x} - \mathbf{x}^k\)</span>. The QP subproblem solved at each iteration focuses on finding the optimal step direction <span class="math notranslate nohighlight">\(\Delta \mathbf{x}\)</span> for the primal variables.
While solving this QP, we obtain not only the step <span class="math notranslate nohighlight">\(\Delta \mathbf{x}\)</span> but also the associated Lagrange multipliers for the QP subproblem, which correspond to an updated dual variable vector <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1}\)</span>. More specifically, after solving the QP, we use <span class="math notranslate nohighlight">\(\Delta \mathbf{x}^k\)</span> to update the primal variables:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\mathbf{x}^{k+1} = \mathbf{x}^k + \Delta \mathbf{x}^k.
\end{align*}\]</div>
<p>Simultaneously, the Lagrange multipliers from the QP provide the updated dual variables <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1}\)</span>.
We summarize the SQP algorithm in the following pseudo-code:</p>
<div class="proof algorithm admonition" id="alg-sqp">
<p class="admonition-title"><span class="caption-number">Algorithm 47 </span> (Sequential Quadratic Programming (SQP))</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> Initial estimate <span class="math notranslate nohighlight">\(\mathbf{x}^0\)</span>, initial Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^0\)</span>, tolerance <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span>.</p>
<p><strong>Output:</strong> Solution <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>, Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^*\)</span>.</p>
<p><strong>Procedure:</strong></p>
<ol class="arabic">
<li><p><strong>Compute the QP Solution:</strong> Solve the QP subproblem to obtain <span class="math notranslate nohighlight">\(\Delta \mathbf{x}^k\)</span>. The QP solver also provides the updated Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1}\)</span> associated with the constraints.</p></li>
<li><p><strong>Update the Estimates:</strong> Update the primal variables:</p>
<div class="math notranslate nohighlight">
\[
   \mathbf{x}^{k+1} = \mathbf{x}^k + \Delta \mathbf{x}^k.
   \]</div>
<p>Set the dual variables to the updated values <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1}\)</span> from the QP solution.</p>
</li>
<li><p><strong>Repeat Until Convergence:</strong> Continue iterating until <span class="math notranslate nohighlight">\(\|\Delta \mathbf{x}^k\| &lt; \epsilon\)</span> and the KKT conditions are satisfied.</p></li>
</ol>
</section>
</div><section id="connection-to-newton-s-method-in-the-equality-constrained-case">
<h3>Connection to Newton’s Method in the Equality-Constrained Case<a class="headerlink" href="#connection-to-newton-s-method-in-the-equality-constrained-case" title="Link to this heading">#</a></h3>
<p>The QP subproblem in SQP is directly related to applying Newton’s method for equality-constrained optimization. To see this, note that the KKT matrix of the QP subproblem is:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\begin{bmatrix}
\nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k) &amp; \nabla \mathbf{h}(\mathbf{x}^k)^T \\
\nabla \mathbf{h}(\mathbf{x}^k) &amp; \mathbf{0}
\end{bmatrix}
\begin{bmatrix}
\Delta \mathbf{x}^k \\
\Delta \boldsymbol{\lambda}^k
\end{bmatrix}
=
-
\begin{bmatrix}
\nabla f(\mathbf{x}^k) + \nabla \mathbf{h}(\mathbf{x}^k)^T \boldsymbol{\lambda}^k \\
\mathbf{h}(\mathbf{x}^k)
\end{bmatrix}
\end{align*}\]</div>
<p>This is exactly the same linear system that have to solve when applying Newton’s method to the KKT conditions of the original program! Thus, solving the QP subproblem at each iteration of SQP is equivalent to taking a Newton step on the KKT conditions of the original nonlinear problem.</p>
</section>
</section>
<section id="sqp-for-inequality-constrained-optimization">
<h2>SQP for Inequality-Constrained Optimization<a class="headerlink" href="#sqp-for-inequality-constrained-optimization" title="Link to this heading">#</a></h2>
<p>So far, we’ve applied the ideas behind Sequential Quadratic Programming (SQP) to problems with only equality constraints. Now, let’s extend this framework to handle optimization problems that also include inequality constraints.
Consider a general nonlinear optimization problem that includes both equality and inequality constraints:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\min_{\mathbf{x}} \quad &amp; f(\mathbf{x}) \\
\text{subject to} \quad &amp; \mathbf{g}(\mathbf{x}) \leq \mathbf{0}, \\
&amp; \mathbf{h}(\mathbf{x}) = \mathbf{0}.
\end{align*}\]</div>
<p>As we did earlier, we approximate this problem by constructing a quadratic approximation to the objective and a linearization of the constraints. QP subproblem at each iteration is then formulated as:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\text{Minimize} \quad &amp; \nabla f(\mathbf{x}^k)^T \Delta \mathbf{x} + \frac{1}{2} \Delta \mathbf{x}^T \nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k, \boldsymbol{\nu}^k) \Delta \mathbf{x} \\
\text{subject to} \quad &amp; \nabla \mathbf{g}(\mathbf{x}^k) \Delta \mathbf{x} + \mathbf{g}(\mathbf{x}^k) \leq \mathbf{0}, \\
&amp; \nabla \mathbf{h}(\mathbf{x}^k) \Delta \mathbf{x} + \mathbf{h}(\mathbf{x}^k) = \mathbf{0},
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta \mathbf{x} = \mathbf{x} - \mathbf{x}^k\)</span> represents the step direction for the primal variables. The following pseudocode outlines the steps involved in applying SQP to a problem with both equality and inequality constraints:</p>
<div class="proof algorithm admonition" id="alg-sqp-ineq">
<p class="admonition-title"><span class="caption-number">Algorithm 48 </span> (Sequential Quadratic Programming (SQP) with Inequality Constraints)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> Initial estimate <span class="math notranslate nohighlight">\(\mathbf{x}^0\)</span>, initial multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^0, \boldsymbol{\nu}^0\)</span>, tolerance <span class="math notranslate nohighlight">\(\epsilon &gt; 0\)</span>.</p>
<p><strong>Output:</strong> Solution <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>, Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^*, \boldsymbol{\nu}^*\)</span>.</p>
<p><strong>Procedure:</strong></p>
<ol class="arabic">
<li><p><strong>Initialization:</strong>
Set <span class="math notranslate nohighlight">\(k = 0\)</span>.</p></li>
<li><p><strong>Repeat:</strong></p>
<p>a. <strong>Construct the QP Subproblem:</strong>
Formulate the QP subproblem using the current iterate <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^k\)</span>, and <span class="math notranslate nohighlight">\(\boldsymbol{\nu}^k\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
   \begin{aligned}
   \text{Minimize} \quad &amp; \nabla f(\mathbf{x}^k)^T \Delta \mathbf{x} + \frac{1}{2} \Delta \mathbf{x}^T \nabla^2_{\mathbf{x}\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k, \boldsymbol{\nu}^k) \Delta \mathbf{x} \\
   \text{subject to} \quad &amp; \nabla \mathbf{g}(\mathbf{x}^k) \Delta \mathbf{x} + \mathbf{g}(\mathbf{x}^k) \leq \mathbf{0}, \\
   &amp; \nabla \mathbf{h}(\mathbf{x}^k) \Delta \mathbf{x} + \mathbf{h}(\mathbf{x}^k) = \mathbf{0}.
   \end{aligned}
   \end{split}\]</div>
<p>b. <strong>Solve the QP Subproblem:</strong>
Solve for <span class="math notranslate nohighlight">\(\Delta \mathbf{x}^k\)</span> and obtain the updated Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1}\)</span> and <span class="math notranslate nohighlight">\(\boldsymbol{\nu}^{k+1}\)</span>.</p>
<p>c. <strong>Update the Estimates:</strong>
Update the primal variables and multipliers:</p>
<div class="math notranslate nohighlight">
\[
   \mathbf{x}^{k+1} = \mathbf{x}^k + \Delta \mathbf{x}^k.
   \]</div>
<p>d. <strong>Check for Convergence:</strong>
If <span class="math notranslate nohighlight">\(\|\Delta \mathbf{x}^k\| &lt; \epsilon\)</span> and the KKT conditions are satisfied, stop. Otherwise, set <span class="math notranslate nohighlight">\(k = k + 1\)</span> and repeat.</p>
</li>
<li><p><strong>Return:</strong>
<span class="math notranslate nohighlight">\(\mathbf{x}^* = \mathbf{x}^{k+1}, \boldsymbol{\lambda}^* = \boldsymbol{\lambda}^{k+1}, \boldsymbol{\nu}^* = \boldsymbol{\nu}^{k+1}\)</span>.</p></li>
</ol>
</section>
</div><section id="demonstration-with-jax-and-cvxpy">
<h3>Demonstration with JAX and CVXPy<a class="headerlink" href="#demonstration-with-jax-and-cvxpy" title="Link to this heading">#</a></h3>
<p>Consider the following equality and inequality-constrained problem:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\min_{x \in \mathbb{R}^2} \quad &amp; f(x) = (x_1 - 2)^2 + (x_2 - 1)^2 \\
\text{subject to} \quad &amp; g(x) = x_1^2 - x_2 \leq 0  \\
&amp; h(x) = x_1^2 + x_2^2 - 1 = 0
\end{align*}\]</div>
<p>This example builds on our previous one but adds a parabola-shaped inequality constraint. We require our solution to lie not only on the circle defining our equality constraint but also below the parabola. To solve the QP subproblem, we will be using the <a class="reference external" href="https://www.cvxpy.org/">CVXPY</a> package. While the Lagrangian and derivatives could be computed easily by hand, we use <a class="reference external" href="https://jax.readthedocs.io/">JAX</a> for generality:</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">jacfwd</span><span class="p">,</span> <span class="n">hessian</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">cvxpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Define the objective function and constraints</span>
<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Corrected inequality constraint: x[1] &lt;= x[0]^2</span>

<span class="c1"># Compute gradients and Jacobians using JAX</span>
<span class="n">grad_f</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="n">hess_f</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">hessian</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
<span class="n">jac_g</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
<span class="n">jac_h</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">jacfwd</span><span class="p">(</span><span class="n">h</span><span class="p">))</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lagrangian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lambda_</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="n">hess_L</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">hessian</span><span class="p">(</span><span class="n">lagrangian</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_qp_subproblem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">nu</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">delta_x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    
    <span class="c1"># Convert JAX arrays to numpy for cvxpy</span>
    <span class="n">grad_f_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grad_f</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">hess_L_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hess_L</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">nu</span><span class="p">))</span>
    <span class="n">jac_g_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jac_g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">jac_h_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">jac_h</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">g_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="n">h_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    
    <span class="n">obj</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">grad_f_np</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">delta_x</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">quad_form</span><span class="p">(</span><span class="n">delta_x</span><span class="p">,</span> <span class="n">hess_L_np</span><span class="p">))</span>
    
    <span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">jac_g_np</span> <span class="o">@</span> <span class="n">delta_x</span> <span class="o">+</span> <span class="n">g_np</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">jac_h_np</span> <span class="o">@</span> <span class="n">delta_x</span> <span class="o">+</span> <span class="n">h_np</span> <span class="o">&lt;=</span> <span class="mi">0</span>
    <span class="p">]</span>
    
    <span class="n">prob</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">constraints</span><span class="p">)</span>
    <span class="n">prob</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">delta_x</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">prob</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dual_value</span><span class="p">,</span> <span class="n">prob</span><span class="o">.</span><span class="n">constraints</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">dual_value</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sqp</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">lambda_</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_iter</span><span class="p">):</span>
        <span class="n">delta_x</span><span class="p">,</span> <span class="n">new_lambda</span><span class="p">,</span> <span class="n">new_nu</span> <span class="o">=</span> <span class="n">solve_qp_subproblem</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">nu</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">delta_x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">:</span>
            <span class="k">break</span>
        
        <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">delta_x</span>
        <span class="n">lambda_</span> <span class="o">=</span> <span class="n">new_lambda</span>
        <span class="n">nu</span> <span class="o">=</span> <span class="n">new_nu</span>
        
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

<span class="c1"># Initial point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>

<span class="c1"># Solve using SQP</span>
<span class="n">x_opt</span><span class="p">,</span> <span class="n">lambda_opt</span><span class="p">,</span> <span class="n">nu_opt</span><span class="p">,</span> <span class="n">iterations</span> <span class="o">=</span> <span class="n">sqp</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal x: </span><span class="si">{</span><span class="n">x_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal lambda: </span><span class="si">{</span><span class="n">lambda_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimal nu: </span><span class="si">{</span><span class="n">nu_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iterations: </span><span class="si">{</span><span class="n">iterations</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Visualize the result</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Create a mesh for the contour plot</span>
<span class="n">x1_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x2_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X1</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1_range</span><span class="p">,</span> <span class="n">x2_range</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">f</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="n">x1_range</span><span class="p">]</span> <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">x2_range</span><span class="p">])</span>

<span class="c1"># Plot filled contours</span>
<span class="n">contour</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Objective Function Value&#39;</span><span class="p">)</span>

<span class="c1"># Plot the equality constraint</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x1_eq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">x2_eq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_eq</span><span class="p">,</span> <span class="n">x2_eq</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Equality Constraint&#39;</span><span class="p">)</span>

<span class="c1"># Plot the inequality constraint and shade the feasible region</span>
<span class="n">x1_ineq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x2_ineq</span> <span class="o">=</span> <span class="n">x1_ineq</span><span class="o">**</span><span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_ineq</span><span class="p">,</span> <span class="n">x2_ineq</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Inequality Constraint&#39;</span><span class="p">)</span>

<span class="c1"># Shade the feasible region for the inequality constraint</span>
<span class="n">x2_lower</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2_ineq</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x1_ineq</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">x2_lower</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">/...&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Feasible Region&#39;</span><span class="p">)</span>

<span class="c1"># Plot the optimal and initial points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_opt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimal Point&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Initial Point&#39;</span><span class="p">)</span>

<span class="c1"># Add labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;SQP for Inequality Constraints with CVXPY and JAX&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Set the axis limits explicitly</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Verify the result</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Equality constraint violation: </span><span class="si">{</span><span class="n">g</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality constraint violation: </span><span class="si">{</span><span class="n">h</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objective function value: </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
</section>
<section id="the-arrow-hurwicz-uzawa-algorithm">
<h2>The Arrow-Hurwicz-Uzawa algorithm<a class="headerlink" href="#the-arrow-hurwicz-uzawa-algorithm" title="Link to this heading">#</a></h2>
<p>While the SQP method addresses constrained optimization problems by sequentially solving quadratic subproblems, an alternative approach emerges from viewing constrained optimization as a min-max problem. This perspective leads to a simpler algorithm, originally introduced by the Arrow-Hurwicz-Uzawa <span id="id3">[<a class="reference internal" href="bibliography.html#id10" title="Kenneth J Arrow, Leonid Hurwicz, and Hirofumi Uzawa. Studies in linear and non-linear programming. Stanford University Press, 1958.">3</a>]</span>. Consider the following general constrained optimization problem encompassing both equality and inequality constraints:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mathbf{x}} \quad &amp; f(\mathbf{x}) \\
\text{subject to} \quad &amp; \mathbf{g}(\mathbf{x}) \leq \mathbf{0} \\
&amp; \mathbf{h}(\mathbf{x}) = \mathbf{0}
\end{aligned}
\end{split}\]</div>
<p>Using the Lagrangian function <span class="math notranslate nohighlight">\(L(\mathbf{x}, \boldsymbol{\lambda}, \boldsymbol{\mu}) = f(\mathbf{x}) + \boldsymbol{\mu}^T \mathbf{g}(\mathbf{x}) + \boldsymbol{\lambda}^T \mathbf{h}(\mathbf{x})\)</span>, we can reformulate this problem as the following min-max problem:</p>
<div class="math notranslate nohighlight">
\[
\min_{\mathbf{x}} \max_{\boldsymbol{\lambda}, \boldsymbol{\mu} \geq 0} L(\mathbf{x}, \boldsymbol{\lambda}, \boldsymbol{\mu})
\]</div>
<p>The role of each component in this min-max structure can be understood as follows:</p>
<ol class="arabic simple">
<li><p>The outer minimization over <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> finds the feasible point that minimizes the objective function <span class="math notranslate nohighlight">\(f(\mathbf{x})\)</span>.</p></li>
<li><p>The maximization over <span class="math notranslate nohighlight">\(\boldsymbol{\mu} \geq 0\)</span> ensures that inequality constraints <span class="math notranslate nohighlight">\(\mathbf{g}(\mathbf{x}) \leq \mathbf{0}\)</span> are satisfied. If any inequality constraint is violated, the corresponding term in <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^T \mathbf{g}(\mathbf{x})\)</span> can be made arbitrarily large by choosing a large enough <span class="math notranslate nohighlight">\(\mu_i\)</span>.</p></li>
<li><p>The maximization over <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}\)</span> ensures that equality constraints <span class="math notranslate nohighlight">\(\mathbf{h}(\mathbf{x}) = \mathbf{0}\)</span> are satisfied.</p></li>
</ol>
<p>Using this observation, we can devise an algorithm which, like SQP, will update both the primal and dual variables at every step. But rather than using second-order optimization, we will simply use a first-order gradient update step: a descent step in the primal variable, and an ascent step in the dual one. The corresponding procedure, when implemented by gradient descent, is called Gradient Ascent Descent in the learning and optimization communities. In the case of equality constraints only, the algorithm looks like the following:</p>
<div class="proof algorithm admonition" id="ahuz-eq">
<p class="admonition-title"><span class="caption-number">Algorithm 49 </span> (Arrow-Hurwicz-Uzawa for equality constraints only)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> Initial guess <span class="math notranslate nohighlight">\(\mathbf{x}^0\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^0\)</span>, step sizes <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>
<strong>Output:</strong> Optimal <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^*\)</span></p>
<p>1: <strong>for</strong> <span class="math notranslate nohighlight">\(k = 0, 1, 2, \ldots\)</span> until convergence <strong>do</strong></p>
<p>2:     <span class="math notranslate nohighlight">\(\mathbf{x}^{k+1} = \mathbf{x}^k - \alpha \nabla_{\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k)\)</span>  <strong>(Primal update)</strong></p>
<p>3:     <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1} = \boldsymbol{\lambda}^k + \beta \nabla_{\boldsymbol{\lambda}} L(\mathbf{x}^{k+1}, \boldsymbol{\lambda}^k)\)</span>  <strong>(Dual update)</strong></p>
<p>4: <strong>end for</strong></p>
<p>5: <strong>return</strong> <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^k\)</span></p>
</section>
</div><p>Now to account for the fact that the Lagrange multiplier needs to be non-negative for inequality constraints, we can use our previous idea from projected gradient descent for bound constraints and consider a projection, or clipping step to ensure that this condition is satisfied throughout. In this case, the algorithm looks like the following:</p>
<div class="proof algorithm admonition" id="ahuz-full">
<p class="admonition-title"><span class="caption-number">Algorithm 50 </span> (Arrow-Hurwicz-Uzawa for equality and inequality constraints)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> Initial guess <span class="math notranslate nohighlight">\(\mathbf{x}^0\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^0\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^0 \geq 0\)</span>, step sizes <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\gamma\)</span>
<strong>Output:</strong> Optimal <span class="math notranslate nohighlight">\(\mathbf{x}^*\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^*\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^*\)</span></p>
<p>1: <strong>for</strong> <span class="math notranslate nohighlight">\(k = 0, 1, 2, \ldots\)</span> until convergence <strong>do</strong></p>
<p>2:     <span class="math notranslate nohighlight">\(\mathbf{x}^{k+1} = \mathbf{x}^k - \alpha \nabla_{\mathbf{x}} L(\mathbf{x}^k, \boldsymbol{\lambda}^k, \boldsymbol{\mu}^k)\)</span>  <strong>(Primal update)</strong></p>
<p>3:     <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^{k+1} = \boldsymbol{\lambda}^k + \beta \nabla_{\boldsymbol{\lambda}} L(\mathbf{x}^{k+1}, \boldsymbol{\lambda}^k, \boldsymbol{\mu}^k)\)</span>  <strong>(Dual update for equality constraints)</strong></p>
<p>4:     <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^{k+1} = [\boldsymbol{\mu}^k + \gamma \nabla_{\boldsymbol{\mu}} L(\mathbf{x}^{k+1}, \boldsymbol{\lambda}^k, \boldsymbol{\mu}^k)]_+\)</span>  <strong>(Dual update with clipping for inequality constraints)</strong></p>
<p>5: <strong>end for</strong></p>
<p>6: <strong>return</strong> <span class="math notranslate nohighlight">\(\mathbf{x}^k\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}^k\)</span>, <span class="math notranslate nohighlight">\(\boldsymbol{\mu}^k\)</span></p>
</section>
</div><p>Here, <span class="math notranslate nohighlight">\([\cdot]_+\)</span> denotes the projection onto the non-negative orthant, ensuring that <span class="math notranslate nohighlight">\(\boldsymbol{\mu}\)</span> remains non-negative.</p>
<p>However, as it is widely known from the lessons of GAN (Generative Adversarial Network) training <span id="id4">[<a class="reference internal" href="bibliography.html#id11" title="Ian Goodfellow, Jean Pouget-Abadie, Mehdi Mirza, Bing Xu, David Warde-Farley, Sherjil Ozair, Aaron Courville, and Yoshua Bengio. Generative adversarial nets. In Advances in neural information processing systems, volume 27. 2014.">17</a>]</span>, Gradient Descent Ascent (GDA) can fail to converge or suffer from instability. The Arrow-Hurwicz-Uzawa algorithm, also known as the first-order Lagrangian method, is known to converge only locally, in the vicinity of an optimal primal-dual pair.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">jax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">jax.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">jnp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">jax</span><span class="w"> </span><span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">jit</span><span class="p">,</span> <span class="n">value_and_grad</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">optax</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Define the objective function and constraints</span>
<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>

<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Inequality constraint: x[1] &lt;= x[0]^2</span>

<span class="c1"># Define the Lagrangian</span>
<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">lagrangian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">lambda_</span><span class="p">,</span> <span class="n">g</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">+</span> <span class="n">jnp</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="n">h</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="c1"># Compute gradients of the Lagrangian</span>
<span class="n">grad_L_x</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">lagrangian</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
<span class="n">grad_L_lambda</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">lagrangian</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
<span class="n">grad_L_mu</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">grad</span><span class="p">(</span><span class="n">lagrangian</span><span class="p">,</span> <span class="n">argnums</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>

<span class="c1"># Define the Arrow-Hurwicz-Uzawa update step</span>
<span class="nd">@jit</span>
<span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="n">carry</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">opt_state_x</span><span class="p">,</span> <span class="n">opt_state_lambda</span><span class="p">,</span> <span class="n">opt_state_mu</span> <span class="o">=</span> <span class="n">carry</span>
    
    <span class="c1"># Compute gradients</span>
    <span class="n">grad_x</span> <span class="o">=</span> <span class="n">grad_L_x</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">grad_lambda</span> <span class="o">=</span> <span class="n">grad_L_lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    <span class="n">grad_mu</span> <span class="o">=</span> <span class="n">grad_L_mu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
    
    <span class="c1"># Update primal variables (minimization)</span>
    <span class="n">updates_x</span><span class="p">,</span> <span class="n">opt_state_x</span> <span class="o">=</span> <span class="n">optimizer_x</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grad_x</span><span class="p">,</span> <span class="n">opt_state_x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">updates_x</span><span class="p">)</span>
    
    <span class="c1"># Update dual variables (maximization)</span>
    <span class="n">updates_lambda</span><span class="p">,</span> <span class="n">opt_state_lambda</span> <span class="o">=</span> <span class="n">optimizer_lambda</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grad_lambda</span><span class="p">,</span> <span class="n">opt_state_lambda</span><span class="p">)</span>
    <span class="n">lambda_</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">(</span><span class="n">lambda_</span><span class="p">,</span> <span class="o">-</span><span class="n">updates_lambda</span><span class="p">)</span>  <span class="c1"># Positive update for maximization</span>
    
    <span class="n">updates_mu</span><span class="p">,</span> <span class="n">opt_state_mu</span> <span class="o">=</span> <span class="n">optimizer_mu</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">grad_mu</span><span class="p">,</span> <span class="n">opt_state_mu</span><span class="p">)</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">apply_updates</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="o">-</span><span class="n">updates_mu</span><span class="p">)</span>  <span class="c1"># Positive update for maximization</span>
    
    <span class="c1"># Project mu onto the non-negative orthant</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">opt_state_x</span><span class="p">,</span> <span class="n">opt_state_lambda</span><span class="p">,</span> <span class="n">opt_state_mu</span><span class="p">),</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">arrow_hurwicz_uzawa</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="c1"># Initialize optimizers</span>
    <span class="k">global</span> <span class="n">optimizer_x</span><span class="p">,</span> <span class="n">optimizer_lambda</span><span class="p">,</span> <span class="n">optimizer_mu</span>
    <span class="n">optimizer_x</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">optimizer_lambda</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    <span class="n">optimizer_mu</span> <span class="o">=</span> <span class="n">optax</span><span class="o">.</span><span class="n">adam</span><span class="p">(</span><span class="n">learning_rate</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
    
    <span class="n">opt_state_x</span> <span class="o">=</span> <span class="n">optimizer_x</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">opt_state_lambda</span> <span class="o">=</span> <span class="n">optimizer_lambda</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">lambda0</span><span class="p">)</span>
    <span class="n">opt_state_mu</span> <span class="o">=</span> <span class="n">optimizer_mu</span><span class="o">.</span><span class="n">init</span><span class="p">(</span><span class="n">mu0</span><span class="p">)</span>
    
    <span class="n">init_carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">opt_state_x</span><span class="p">,</span> <span class="n">opt_state_lambda</span><span class="p">,</span> <span class="n">opt_state_mu</span><span class="p">)</span>
    
    <span class="c1"># Use jax.lax.scan for the optimization loop</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">trajectory</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">lax</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">init_carry</span><span class="p">,</span> <span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">max_iter</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">lambda_</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">trajectory</span>

<span class="c1"># Initial point</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">lambda0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">mu0</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Solve using Arrow-Hurwicz-Uzawa</span>
<span class="n">x_opt</span><span class="p">,</span> <span class="n">lambda_opt</span><span class="p">,</span> <span class="n">mu_opt</span><span class="p">,</span> <span class="n">trajectory</span> <span class="o">=</span> <span class="n">arrow_hurwicz_uzawa</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">lambda0</span><span class="p">,</span> <span class="n">mu0</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final x: </span><span class="si">{</span><span class="n">x_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final lambda: </span><span class="si">{</span><span class="n">lambda_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final mu: </span><span class="si">{</span><span class="n">mu_opt</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Visualize the result</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Create a mesh for the contour plot</span>
<span class="n">x1_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x2_range</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">X1</span><span class="p">,</span> <span class="n">X2</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x1_range</span><span class="p">,</span> <span class="n">x2_range</span><span class="p">)</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">f</span><span class="p">(</span><span class="n">jnp</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">]))</span> <span class="k">for</span> <span class="n">x1</span> <span class="ow">in</span> <span class="n">x1_range</span><span class="p">]</span> <span class="k">for</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">x2_range</span><span class="p">])</span>

<span class="c1"># Plot filled contours</span>
<span class="n">contour</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X1</span><span class="p">,</span> <span class="n">X2</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">contour</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Objective Function Value&#39;</span><span class="p">)</span>

<span class="c1"># Plot the equality constraint</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">jnp</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x1_eq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">x2_eq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_eq</span><span class="p">,</span> <span class="n">x2_eq</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Equality Constraint&#39;</span><span class="p">)</span>

<span class="c1"># Plot the inequality constraint and shade the feasible region</span>
<span class="n">x1_ineq</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="n">x2_ineq</span> <span class="o">=</span> <span class="n">x1_ineq</span><span class="o">**</span><span class="mi">2</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_ineq</span><span class="p">,</span> <span class="n">x2_ineq</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;orange&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Inequality Constraint&#39;</span><span class="p">)</span>

<span class="c1"># Shade the feasible region for the inequality constraint</span>
<span class="n">x2_lower</span> <span class="o">=</span> <span class="n">jnp</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x2_ineq</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">x1_ineq</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">x2_lower</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">hatch</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\\</span><span class="s1">/...&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Feasible Region&#39;</span><span class="p">)</span>

<span class="c1"># Plot the optimal and initial points</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x_opt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_opt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Final Point&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Initial Point&#39;</span><span class="p">)</span>

<span class="c1"># Plot the optimization trajectory using scatter plot</span>
<span class="n">scatter</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">trajectory</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">trajectory</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="n">jnp</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">trajectory</span><span class="p">)),</span> 
                      <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;cool&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scatter</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Iteration&#39;</span><span class="p">)</span>

<span class="c1"># Add labels and title</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Arrow-Hurwicz-Uzawa Algorithm with JAX and Adam (Corrected Min/Max)&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper center&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.05</span><span class="p">),</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>

<span class="c1"># Set the axis limits explicitly</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>


<span class="c1"># Verify the result</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Equality constraint violation: </span><span class="si">{</span><span class="n">g</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Inequality constraint violation: </span><span class="si">{</span><span class="n">h</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objective function value: </span><span class="si">{</span><span class="n">f</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)</span><span class="si">:</span><span class="s2">.6f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
</div>
</section>
<section id="projected-gradient-descent">
<h2>Projected Gradient Descent<a class="headerlink" href="#projected-gradient-descent" title="Link to this heading">#</a></h2>
<p>The Arrow-Hurwicz-Uzawa algorithm provided a way to handle constraints through dual variables and a primal-dual update scheme. Another commonly used approach for constrained optimization is <strong>Projected Gradient Descent (PGD)</strong>. The idea is simple: take a gradient descent step as if the problem were unconstrained, then project the result back onto the feasible set. Formally:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1} = \mathcal{P}_C\big(\mathbf{x}_k - \alpha \nabla f(\mathbf{x}_k)\big),
\]</div>
<p>where $\mathcal{P}_C$ is the projection onto the feasible set $C$, $\alpha$ is the step size, and $f(\mathbf{x})$ is the objective function.</p>
<p>PGD is particularly effective when the projection is computationally cheap. A common example is <strong>box constraints</strong> (or bound constraints), where the feasible set is a hyperrectangle:</p>
<div class="math notranslate nohighlight">
\[
C = \{ \mathbf{x} \mid \mathbf{x}_{\mathrm{lb}} \leq \mathbf{x} \leq \mathbf{x}_{\mathrm{ub}} \}.
\]</div>
<p>In this case, the projection reduces to an element-wise clipping operation:</p>
<div class="math notranslate nohighlight">
\[
[\mathcal{P}_C(\mathbf{x})]_i = \max\big(\min([\mathbf{x}]_i, [\mathbf{x}_{\mathrm{ub}}]_i), [\mathbf{x}_{\mathrm{lb}}]_i\big).
\]</div>
<p>For bound-constrained problems, PGD is almost as easy to implement as standard gradient descent because the projection step is just a clipping operation. For more general constraints, however, the projection may require solving a separate optimization problem, which can be as hard as the original task. Here is the algorithm for a problem of the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\mathbf{x}} \quad &amp; f(\mathbf{x}) \\
\text{subject to} \quad &amp; \mathbf{x}_{\mathrm{lb}} \leq \mathbf{x} \leq \mathbf{x}_{\mathrm{ub}}.
\end{aligned}
\end{split}\]</div>
<div class="proof algorithm admonition" id="proj-grad-descent-bound-constraints">
<p class="admonition-title"><span class="caption-number">Algorithm 51 </span> (Projected Gradient Descent for Bound Constraints)</p>
<section class="algorithm-content" id="proof-content">
<p><strong>Input:</strong> Initial point <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>, step size <span class="math notranslate nohighlight">\(\alpha\)</span>, bounds <span class="math notranslate nohighlight">\(\mathbf{x}_{\mathrm{lb}}, \mathbf{x}_{\mathrm{ub}}\)</span>,
maximum iterations <span class="math notranslate nohighlight">\(\max_\text{iter}\)</span>, tolerance <span class="math notranslate nohighlight">\(\varepsilon\)</span></p>
<ol class="arabic simple">
<li><p>Initialize <span class="math notranslate nohighlight">\(k = 0\)</span></p></li>
<li><p>While <span class="math notranslate nohighlight">\(k &lt; \max_\text{iter}\)</span> and not converged:</p>
<ol class="arabic simple">
<li><p>Compute gradient: <span class="math notranslate nohighlight">\(\mathbf{g}_k = \nabla f(\mathbf{x}_k)\)</span></p></li>
<li><p>Update: <span class="math notranslate nohighlight">\(\mathbf{x}_{k+1} = \text{clip}(\mathbf{x}_k - \alpha \mathbf{g}_k,\; \mathbf{x}_{\mathrm{lb}}, \mathbf{x}_{\mathrm{ub}})\)</span></p></li>
<li><p>Check convergence: if <span class="math notranslate nohighlight">\(\|\mathbf{x}_{k+1} - \mathbf{x}_k\| &lt; \varepsilon\)</span>, stop</p></li>
<li><p><span class="math notranslate nohighlight">\(k = k + 1\)</span></p></li>
</ol>
</li>
<li><p>Return <span class="math notranslate nohighlight">\(\mathbf{x}_k\)</span></p></li>
</ol>
</section>
</div><p>The clipping function is defined as:</p>
<div class="math notranslate nohighlight">
\[
\text{clip}(x, x_{\mathrm{lb}}, x_{\mathrm{ub}}) = \max\big(\min(x, x_{\mathrm{ub}}), x_{\mathrm{lb}}\big).
\]</div>
<p>Under mild conditions such as Lipschitz continuity of the gradient, PGD converges to a stationary point of the constrained problem. Its simplicity and low cost make it a common choice whenever the projection can be computed efficiently.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="the-discrete-time-pontryagin-maximum-principle">
<h1>The Discrete-Time Pontryagin Maximum Principle<a class="headerlink" href="#the-discrete-time-pontryagin-maximum-principle" title="Link to this heading">#</a></h1>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="id5">
<h1>The Discrete-Time Pontryagin Maximum Principle<a class="headerlink" href="#id5" title="Link to this heading">#</a></h1>
<p>Discrete-time optimal control problems (DOCPs) form a specific class of nonlinear programming problems. Therefore, we can apply the general results from the Karush-Kuhn-Tucker (KKT) conditions to characterize the structure of optimal solutions to DOCPs in any of their three forms. The discrete-time analogue of the KKT conditions for DOCPs is known as the discrete-time Pontryagin Maximum Principle (PMP). The PMP was first described by Pontryagin in 1956 <span id="id6">[<a class="reference internal" href="bibliography.html#id12" title="Lev Semyonovich Pontryagin, Vladimir Grigor'evich Boltyanskii, Revaz Valerianovich Gamkrelidze, and Evgenii Frolovich Mishchenko. The Mathematical Theory of Optimal Processes. Interscience Publishers, 1962.">35</a>]</span> for continuous-time systems, with the discrete-time version following shortly after. Similar to the KKT conditions, the PMP is useful from both theoretical and practical perspectives. It not only allows us to sometimes find closed-form solutions but also inspires the development of algorithms.</p>
<p>Importantly, the PMP goes beyond the KKT conditions by demonstrating the existence of a particular recursive equation—the adjoint equation. This equation governs the evolution of the derivative of the Hamiltonian, a close cousin to the Lagrangian. The adjoint equation enables us to transform the PMP into an algorithmic procedure, which has much in common with backpropagation <span id="id7">[<a class="reference internal" href="bibliography.html#id13" title="David E Rumelhart, Geoffrey E Hinton, and Ronald J Williams. Learning representations by back-propagating errors. Nature, 323(6088):533–536, 1986.">39</a>]</span> in deep learning. This connection between optimal control theory has been noted by several researchers, including Griewank <span id="id8">[<a class="reference internal" href="bibliography.html#id14" title="Andreas Griewank. On automatic differentiation. Mathematical Programming: Recent Developments and Applications, 1989.">21</a>]</span> in the context of automatic differentiation, and LeCun <span id="id9">[<a class="reference internal" href="bibliography.html#id15" title="Yann LeCun. A theoretical framework for back-propagation. Proceedings of the 1988 Connectionist Models Summer School, pages 21–28, 1988.">28</a>]</span> in his early work on neural networks.</p>
<section id="pmp-for-mayer-problems">
<h2>PMP for Mayer Problems<a class="headerlink" href="#pmp-for-mayer-problems" title="Link to this heading">#</a></h2>
<p>Before delving into more general cases, let’s consider a Mayer problem where the goal is to minimize a terminal cost function <span class="math notranslate nohighlight">\(c_T(\mathbf{x}_T)\)</span>:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{alignat*}{2}
\text{minimize} \quad &amp; c_T(\mathbf{x}_T) &amp; \\
\text{such that} \quad 
&amp; \mathbf{x}_{t+1} = \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t), &amp; \quad &amp; t = 1, \dots, T-1, \\
&amp; \mathbf{u}_{lb} \leq \mathbf{u}_t \leq \mathbf{u}_{ub}, &amp; \quad &amp; t = 1, \dots, T, \\
&amp; \mathbf{x}_{lb} \leq \mathbf{x}_t \leq \mathbf{x}_{ub}, &amp; \quad &amp; t = 1, \dots, T, \\
\text{given} \quad &amp; \mathbf{x}_1. &amp;
\end{alignat*}
\end{split}\]</div>
<p>As done previously using the single shooting method, we reformulate this problem as an unconstrained optimization problem (excluding the state bound constraints since we lack a straightforward way to incorporate them directly). This reformulation is:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
J(\mathbf{u}_{1:T-1}) = c_T(\boldsymbol{\phi}_T(\mathbf{u}_{1:T-1}, \mathbf{x}_1)),
\end{align*}\]</div>
<p>where the state evolution functions <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_t\)</span> are defined recursively as:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\phi}_t(\mathbf{u}_{1:T-1}, \mathbf{x}_1) = 
\begin{cases}
\mathbf{x}_1, &amp; \text{if } t = 1, \\
\mathbf{f}_{t-1}(\boldsymbol{\phi}_{t-1}(\mathbf{u}_{1:T-1}, \mathbf{x}_1), \mathbf{u}_{t-1}), &amp; \text{if } t = 2, \ldots, T.
\end{cases}
\end{align*}\]</div>
<p>To find the first-order optimality condition, we differentiate the objective function <span class="math notranslate nohighlight">\(J(\mathbf{u}_{1:T-1})\)</span> with respect to each control variable <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> and set it to zero:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial J(\mathbf{u}_{1:T-1})}{\partial \mathbf{u}_t} = \frac{\partial c_T(\boldsymbol{\phi}_T)}{\partial \mathbf{u}_t} = 0, \quad t = 1, \ldots, T-1.
\]</div>
<p>Applying the chain rule, we get:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial c_T(\boldsymbol{\phi}_T)}{\partial \mathbf{u}_t} = \frac{\partial c_T(\boldsymbol{\phi}_T)}{\partial \boldsymbol{\phi}_T} \frac{\partial \boldsymbol{\phi}_T}{\partial \mathbf{u}_t}.
\]</div>
<p>Now, let’s expand the derivative <span class="math notranslate nohighlight">\(\frac{\partial \boldsymbol{\phi}_T}{\partial \mathbf{u}_t}\)</span> using its non-recursive form. From the definition of the state evolution functions, we have:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\phi}_T = \mathbf{f}_{T-1}(\boldsymbol{\phi}_{T-1}, \mathbf{u}_{T-1}), \quad \boldsymbol{\phi}_{T-1} = \mathbf{f}_{T-2}(\boldsymbol{\phi}_{T-2}, \mathbf{u}_{T-2}), \quad \ldots, \quad \boldsymbol{\phi}_{t+1} = \mathbf{f}_t(\boldsymbol{\phi}_t, \mathbf{u}_t).
\end{align*}\]</div>
<p>The above can also be written more recursively. For <span class="math notranslate nohighlight">\(s \geq t\)</span>, the derivative of <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_s\)</span> with respect to <span class="math notranslate nohighlight">\(\mathbf{u}_t\)</span> is:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \boldsymbol{\phi}_s}{\partial \mathbf{u}_t} = \frac{\partial \mathbf{f}_{s-1}}{\partial \boldsymbol{\phi}_{s-1}} \frac{\partial \boldsymbol{\phi}_{s-1}}{\partial \mathbf{u}_t}, \quad s = t+1, \ldots, T,
\]</div>
<p>and</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial \boldsymbol{\phi}_t}{\partial \mathbf{u}_t} = \frac{\partial \mathbf{f}_{t-1}}{\partial \mathbf{u}_t}.
\]</div>
<p>The overall derivative is then of the form:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\frac{\partial J(\mathbf{u}_{1:T-1})}{\partial \mathbf{u}_t} = \underbrace{\underbrace{\underbrace{\frac{\partial c_T(\boldsymbol{\phi}_T)}{\partial \boldsymbol{\phi}_T}}_{\boldsymbol{\lambda}_T} \frac{\partial \mathbf{f}_{T-1}}{\partial \boldsymbol{\phi}_{T-1}}}_{\boldsymbol{\lambda}_{T-1}} \cdots \frac{\partial \mathbf{f}_{t+1}}{\partial \boldsymbol{\phi}_{t+1}}}_{\boldsymbol{\lambda}_{t+1}} \frac{\partial \mathbf{f}_t}{\partial \mathbf{u}_t}.
\end{align*}\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}_t\)</span> is called the adjoint (co-state) variable, and contains the reverse accumulation of the derivative. The evolution of this variable also obeys a difference equation, but one which runs backward in time: the adjoint equation. The recursive relationship for the adjoint equation is then:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\lambda}_t = \frac{\partial \mathbf{f}_t}{\partial \boldsymbol{\phi}_t}^\top \boldsymbol{\lambda}_{t+1}, \quad t = 1, \ldots, T-1,
\]</div>
<p>with the terminal condition:</p>
<div class="math notranslate nohighlight">
\[
\boldsymbol{\lambda}_T = \frac{\partial c_T}{\partial \boldsymbol{\phi}_T}.
\]</div>
<p>The first-order optimality condition in terms of the adjoint variable can finally be written as:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial J(\mathbf{u}_{1:T-1})}{\partial \mathbf{u}_t} = \frac{\partial \mathbf{f}_t}{\partial \mathbf{u}_t}^\top \boldsymbol{\lambda}_{t+1} = 0, \quad t = 1, \ldots, T-1.
\]</div>
</section>
<section id="pmp-for-bolza-problems">
<h2>PMP for Bolza Problems<a class="headerlink" href="#pmp-for-bolza-problems" title="Link to this heading">#</a></h2>
<p>To derive the adjoint equation for the Bolza problem, we consider the optimal control problem where the objective is to minimize both a terminal cost <span class="math notranslate nohighlight">\(c_T(\mathbf{x}_T)\)</span> and the sum of intermediate costs <span class="math notranslate nohighlight">\(c_t(\mathbf{x}_t, \mathbf{u}_t)\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\text{minimize} \quad &amp; c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t, \mathbf{u}_t) \\
\text{such that} \quad 
&amp; \mathbf{x}_{t+1} = \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t), \quad t = 1, \dots, T-1, \\
\text{given} \quad &amp; \mathbf{x}_1.
\end{align*}\]</div>
<p>To handle the constraints, we introduce the Lagrangian function with multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}_t\)</span> for each constraint <span class="math notranslate nohighlight">\(\mathbf{x}_{t+1} = \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t)\)</span>:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
L(\mathbf{x}, \mathbf{u}, \boldsymbol{\lambda}) &amp;\triangleq c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t, \mathbf{u}_t) + \sum_{t=1}^{T-1} \boldsymbol{\lambda}_{t+1}^\top \left( \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t) - \mathbf{x}_{t+1} \right).
\end{align*}\]</div>
<p>The existence of an optimal constrained solution <span class="math notranslate nohighlight">\((\mathbf{x}^\star, \mathbf{u})^\star\)</span> implies that there exists a unique set of Lagrange multipliers <span class="math notranslate nohighlight">\(\boldsymbol{\lambda}_t^\star\)</span> such that the derivative of the Lagrangian with respect to all variables equals zero: <span class="math notranslate nohighlight">\(\nabla L(\mathbf{x}^\star, \mathbf{u}^\star, \boldsymbol{\lambda}^\star) = 0.\)</span></p>
<p>To simplify, we rearrange the Lagrangian so that each state variable <span class="math notranslate nohighlight">\(\mathbf{x}_t\)</span> appears only once in the summation:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
L(\mathbf{x}, \mathbf{u}, \boldsymbol{\lambda}) &amp;= c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} \left( c_t(\mathbf{x}_t, \mathbf{u}_t) + \boldsymbol{\lambda}_{t+1}^\top (\mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t) - \mathbf{x}_{t+1}) \right). \\
&amp;= c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t, \mathbf{u}_t) + \sum_{t=1}^{T-1} \boldsymbol{\lambda}_{t+1}^\top \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t) - \sum_{t=1}^{T-1} \boldsymbol{\lambda}_{t+1}^\top \mathbf{x}_{t+1}.
\end{align*}\]</div>
<p>Note that by adding and subtracting, we can write:</p>
<div class="math notranslate nohighlight">
\[
\sum_{t=1}^{T-1} \boldsymbol{\lambda}_{t+1}^\top \mathbf{x}_{t+1} = \boldsymbol{\lambda}_T^\top \mathbf{x}_T - \boldsymbol{\lambda}_1^\top \mathbf{x}_1 + \sum_{t=1}^{T-1} \boldsymbol{\lambda}_t^\top \mathbf{x}_t.
\]</div>
<p>Substituting this back into the Lagrangian gives:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
L(\mathbf{x}, \mathbf{u}, \boldsymbol{\lambda}) &amp;= c_T(\mathbf{x}_T) + \sum_{t=1}^{T-1} c_t(\mathbf{x}_t, \mathbf{u}_t) + \sum_{t=1}^{T-1} \boldsymbol{\lambda}_{t+1}^\top \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t) - \left( \boldsymbol{\lambda}_T^\top \mathbf{x}_T - \boldsymbol{\lambda}_1^\top \mathbf{x}_1 + \sum_{t=1}^{T-1} \boldsymbol{\lambda}_t^\top \mathbf{x}_t \right). \\
&amp;= c_T(\mathbf{x}_T) + \boldsymbol{\lambda}_T^\top \mathbf{x}_T - \boldsymbol{\lambda}_1^\top \mathbf{x}_1 + \sum_{t=1}^{T-1} \left( c_t(\mathbf{x}_t, \mathbf{u}_t) + \boldsymbol{\lambda}_{t+1}^\top \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t) - \boldsymbol{\lambda}_t^\top \mathbf{x}_t \right).
\end{align*}\]</div>
<p>By differentiating the Lagrangian with respect to each state <span class="math notranslate nohighlight">\(\mathbf{x}_i\)</span>, we obtain:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\frac{\partial L(\mathbf{x}, \mathbf{u}, \boldsymbol{\lambda})}{\partial \mathbf{x}_i} = 
\begin{cases}
\frac{\partial c_T (\mathbf{x}_T)}{\partial \mathbf{x}_T} + \boldsymbol{\lambda}_T, &amp; \text{if } i = T, \\
\frac{\partial c_t(\mathbf{x}_t, \mathbf{u}_t)}{\partial \mathbf{x}_t} + \boldsymbol{\lambda}_{t+1}^\top \frac{\partial \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t)}{\partial \mathbf{x}_t} - \boldsymbol{\lambda}_t, &amp; \text{if } i = 1, \dots, T-1.
\end{cases}
\end{split}\]</div>
<p>We finally obtain the adjoint equation by setting the above expression to zero at an optimal primal-dual pair, and re-arranging the terms:</p>
<div class="amsmath math notranslate nohighlight">
\[\begin{align*}
\boldsymbol{\lambda}^*_T &amp;= \frac{\partial c_T(\mathbf{x}^*_T)}{\partial \mathbf{x}^*_T}\\
\boldsymbol{\lambda}^*_t &amp;= \frac{\partial c_t(\mathbf{x}^*_t, \mathbf{u}^*_t)}{\partial \mathbf{x}^*_t} + (\boldsymbol{\lambda}^*_{t+1})^\top \frac{\partial \mathbf{f}_t(\mathbf{x}^*_t, \mathbf{u}^*_t)}{\partial \mathbf{x}^*_t}, \enspace t = T-1, \dots, 1
\end{align*}\]</div>
<p>The optimality condition for the controls is obtained by differentiating the Lagrangian with respect to <span class="math notranslate nohighlight">\(\mathbf{u}^*_t\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial L(\mathbf{x}^*, \mathbf{u}^*, \boldsymbol{\lambda}^*)}{\partial \mathbf{u}^*_t} = \frac{\partial c_t(\mathbf{x}^*_t, \mathbf{u}^*_t)}{\partial \mathbf{u}^*_t} + (\boldsymbol{\lambda}^*_{t+1})^\top \frac{\partial \mathbf{f}_t(\mathbf{x}^*_t, \mathbf{u}^*_t)}{\partial \mathbf{u}^*_t} = 0.
\]</div>
<p>As expected from the general theory of constrained optimization, we finally recover the fact that the constraints must be satisfied at an optimal solution:</p>
<div class="math notranslate nohighlight">
\[
\frac{\partial L(\mathbf{x}^*, \mathbf{u}^*, \boldsymbol{\lambda}^*)}{\partial \boldsymbol{\lambda}^*_{t+1}} = \mathbf{f}_t(\mathbf{x}^*_t, \mathbf{u}^*_t) - \mathbf{x}^*_{t+1} = 0.
\]</div>
<!-- ## Hamiltonian Formulation

The first-order optimality condition for the Bolza problem obtained above can be expressed using the so-called Hamiltonian function:

$$
H_t(\mathbf{x}_t, \mathbf{u}_t, \boldsymbol{\lambda}_{t+1}) = c_t(\mathbf{x}_t, \mathbf{u}_t) + \boldsymbol{\lambda}_{t+1}^\top \mathbf{f}_t(\mathbf{x}_t, \mathbf{u}_t).
$$

If $(\mathbf{x}^*, \mathbf{u}^*)$ is a local minimum control trajectory, then:

$$
\frac{\partial H_t(\mathbf{x}_t^*, \mathbf{u}_t^*, \boldsymbol{\lambda}_{t+1}^*)}{\partial \mathbf{u}_t} = 0, \quad t = 1, \ldots, T-1,
$$
where the adjoint variables (costate vectors) \(\boldsymbol{\lambda}_t^*\) are computed from:

$$
\boldsymbol{\lambda}_t^* = \frac{\partial H_t(\mathbf{x}_t^*, \mathbf{u}_t^*, \boldsymbol{\lambda}_{t+1}^*)}{\partial \mathbf{x}_t}, \quad t = 1, \ldots, T-1, \quad \boldsymbol{\lambda}_T^* = \frac{\partial c_T(\mathbf{x}_T^*)}{\partial \mathbf{x}_T}.
$$ --> --></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="cadp.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Policy Parametrization Methods</p>
      </div>
    </a>
    <a class="right-next"
       href="bibliography.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Bibliography</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Example COCPs</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pendulum-in-the-gym-environment">Pendulum in the Gym Environment</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#heat-exchanger">Heat Exchanger</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#nuclear-reactor">Nuclear Reactor</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#chemotherapy">Chemotherapy</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#government-corruption">Government Corruption</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-initial-value-problems">Solving Initial Value Problems</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-s-method">Euler’s Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-euler-s-method">Implicit Euler’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#stiff-odes">Stiff ODEs</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoid-method">Trapezoid Method</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-predictor-corrector">Trapezoidal Predictor-Corrector</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collocation-methods">Collocation Methods</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#quick-primer-on-polynomials">Quick Primer on Polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#orthogonal-polynomials">Orthogonal Polynomials</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#legendre-polynomials">Legendre Polynomials</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#chebyshev-polynomials">Chebyshev Polynomials</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#hermite-polynomials">Hermite Polynomials</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#collocation-conditions">Collocation Conditions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#common-numerical-integration-techniques-as-collocation-methods">Common Numerical Integration Techniques as Collocation Methods</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#explicit-euler-method">Explicit Euler Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#implicit-euler-method">Implicit Euler Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-method">Trapezoidal Method</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#runge-kutta-methods">Runge-Kutta Methods</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#example-solving-a-simple-ode-by-collocation">Example: Solving a Simple ODE by Collocation</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#nonlinear-programming">Nonlinear Programming</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#karush-kuhn-tucker-kkt-conditions">Karush-Kuhn-Tucker (KKT) conditions</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#lagrange-multiplier-theorem">Lagrange Multiplier Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#newton-s-method">Newton’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#efficient-implementation-of-newton-s-method">Efficient Implementation of Newton’s Method</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-equality-constrained-programs-with-newton-s-method">Solving Equality Constrained Programs with Newton’s Method</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#demonstration">Demonstration</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-sqp-approach-taylor-expansion-and-quadratic-approximation">The SQP Approach: Taylor Expansion and Quadratic Approximation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#connection-to-newton-s-method-in-the-equality-constrained-case">Connection to Newton’s Method in the Equality-Constrained Case</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#sqp-for-inequality-constrained-optimization">SQP for Inequality-Constrained Optimization</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#demonstration-with-jax-and-cvxpy">Demonstration with JAX and CVXPy</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-arrow-hurwicz-uzawa-algorithm">The Arrow-Hurwicz-Uzawa algorithm</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#projected-gradient-descent">Projected Gradient Descent</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-discrete-time-pontryagin-maximum-principle">The Discrete-Time Pontryagin Maximum Principle</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#id5">The Discrete-Time Pontryagin Maximum Principle</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pmp-for-mayer-problems">PMP for Mayer Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pmp-for-bolza-problems">PMP for Bolza Problems</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pierre-Luc Bacon
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>