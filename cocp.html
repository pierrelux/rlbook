
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Trajectory Optimization in Continuous Time &#8212; Practical Reinforcement Learning: From Algorithms to Applications</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"bm": ["{\\boldsymbol #1}", 1]}, "processEscapes": true}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'cocp';</script>
    <script src="_static/iframe-modal.js?v=f72a1242"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Model Predictive Control" href="mpc.html" />
    <link rel="prev" title="Discrete-Time Trajectory Optimization" href="ocp.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Practical Reinforcement Learning: From Algorithms to Applications</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Why This Book?
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modeling</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Why Build a Model? For Whom?</a></li>

<li class="toctree-l1"><a class="reference internal" href="ssm.html">Dynamics Models for Decision Making</a></li>




<li class="toctree-l1"><a class="reference internal" href="simulation.html">Programs as Models</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Trajectory Optimization</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ocp.html">Discrete-Time Trajectory Optimization</a></li>


<li class="toctree-l1 current active"><a class="current reference internal" href="#">Trajectory Optimization in Continuous Time</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Trajectories to Policies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mpc.html">Model Predictive Control</a></li>


<li class="toctree-l1"><a class="reference internal" href="dp.html">Dynamic Programming</a></li>



</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Learning from Data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="adp.html">Approximate Dynamic Programming</a></li>





<li class="toctree-l1"><a class="reference internal" href="cadp.html">Policy Parametrization Methods</a></li>







</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix_examples.html">Example COCPs</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_ivps.html">Solving Initial Value Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_nlp.html">Nonlinear Programming</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/edit/main/cocp.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/issues/new?title=Issue%20on%20page%20%2Fcocp.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/cocp.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Trajectory Optimization in Continuous Time</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trajectory Optimization in Continuous Time</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-transcription-methods">Direct Transcription Methods</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discretizing-cost-and-dynamics-together">Discretizing cost and dynamics together</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-choice-of-interior-points">On the choice of interior points</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint">Step-function based construction (piecewise constants; rectangle or midpoint)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#polynomial-interpolation">Polynomial Interpolation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-for-the-coefficients-monomial-basis">Solving for the Coefficients (Monomial Basis)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-different-basis">Using a Different Basis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#derivative-constraints">Derivative Constraints</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-ode-trajectories-collocation">Interpolating ODE Trajectories (Collocation)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boundary-conditions-and-node-families">Boundary Conditions and Node Families</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#control-parameterization-and-cost-integration">Control Parameterization and Cost Integration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-recipe-concrete-transcriptions">Applying the recipe: concrete transcriptions</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-collocation">Euler Collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-collocation">Trapezoidal collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hermitesimpson-quadratic-interpolation-midpoint-included">Hermite–Simpson (quadratic interpolation; midpoint included)</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#examples">Examples</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compressor-surge-problem">Compressor Surge Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-trapezoidal-collocation">Solution by Trapezoidal Collocation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#system-identification-as-trajectory-optimization-compressor-surge">System Identification as Trajectory Optimization (Compressor Surge)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#flight-trajectory-optimization">Flight Trajectory Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hydro-cascade-scheduling-with-physical-routing-and-multiple-shooting">Hydro Cascade Scheduling with Physical Routing and Multiple Shooting</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="trajectory-optimization-in-continuous-time">
<h1>Trajectory Optimization in Continuous Time<a class="headerlink" href="#trajectory-optimization-in-continuous-time" title="Link to this heading">#</a></h1>
<p>As in the discrete-time setting, we work with three continuous-time variants that differ only in how the objective is written while sharing the same dynamics, path constraints, and bounds. The path constraints <span class="math notranslate nohighlight">\(\mathbf{g}(\mathbf{x}(t),\mathbf{u}(t))\le \mathbf{0}\)</span> are pointwise in time, and the bounds <span class="math notranslate nohighlight">\(\mathbf{x}_{\min}\le \mathbf{x}(t)\le \mathbf{x}_{\max}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}_{\min}\le \mathbf{u}(t)\le \mathbf{u}_{\max}\)</span> are understood in the same pointwise sense.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row sd-g-1 sd-g-xs-1 sd-g-sm-1 sd-g-md-1 sd-g-lg-1 docutils">
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 1 </span> (Mayer Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; c(\mathbf{x}(t_f)) \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-1">
<p class="admonition-title"><span class="caption-number">Definition 2 </span> (Lagrange Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; \int_{t_0}^{t_f} c(\mathbf{x}(t), \mathbf{u}(t)) \, dt \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-2">
<p class="admonition-title"><span class="caption-number">Definition 3 </span> (Bolza Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; c(\mathbf{x}(t_f)) + \int_{t_0}^{t_f} c(\mathbf{x}(t), \mathbf{u}(t)) \, dt \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
</div>
</div>
<p>These three forms are different lenses on the same task. Bolza contains both terminal and running terms. Lagrange can be turned into Mayer by augmenting the state with an accumulator:</p>
<div class="math notranslate nohighlight">
\[
\dot{z}(t)=c(\mathbf{x}(t),\mathbf{u}(t)),\quad z(t_0)=0,\quad \text{minimize } z(t_f),
\]</div>
<p>with the original dynamics left unchanged. Mayer is a special case of Bolza with zero running cost. We will use these equivalences freely, since a numerical method cares only about what must be evaluated and where those evaluations are taken.</p>
<p>With this catalog in place, we now pass from functions to finite representations.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="direct-transcription-methods">
<h1>Direct Transcription Methods<a class="headerlink" href="#direct-transcription-methods" title="Link to this heading">#</a></h1>
<p>The discrete-time problems of the previous chapter already suggested how to proceed: we convert a continuous problem into one over finitely many numbers by deciding where to look at the trajectories and how to interpolate between those looks. We place a mesh <span class="math notranslate nohighlight">\(t_0&lt;t_1&lt;\cdots&lt;t_N=t_f\)</span> and, inside each window <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>, select a small set of interior fractions <span class="math notranslate nohighlight">\(\{\tau_j\}\)</span> on the reference interval <span class="math notranslate nohighlight">\([0,1]\)</span>. The running cost is additive over windows, so we write it as a sum of local integrals, map each window to <span class="math notranslate nohighlight">\([0,1]\)</span>, and approximate each local integral by a quadrature rule with nodes <span class="math notranslate nohighlight">\(\tau_j\)</span> and weights <span class="math notranslate nohighlight">\(w_j\)</span>. This produces</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
\sum_{k=0}^{N-1} h_k \sum_{j=1}^q w_j\, c\!\big(\mathbf{x}(t_k+h_k\tau_j),\,\mathbf{u}(t_k+h_k\tau_j)\big),
\]</div>
<p>with <span class="math notranslate nohighlight">\(h_k=t_{k+1}-t_k\)</span>. The dynamics are treated in the same way by the fundamental theorem of calculus,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
h_k \sum_{j=1}^q b_j\, \mathbf{f}\!\big(\mathbf{x}(t_k+h_k\tau_j),\,\mathbf{u}(t_k+h_k\tau_j)\big),
\]</div>
<p>so the places where we “pay” running cost are the same places where we “account” for state changes. Path constraints and bounds are then enforced at the same interior times. In the infinite-horizon discounted case, the same formulas apply with an extra factor <span class="math notranslate nohighlight">\(e^{-\rho(t_k+h_k\tau_j)}\)</span> multiplying the weights in the cost.</p>
<p>The values <span class="math notranslate nohighlight">\(\mathbf{x}(t_k+h_k\tau_j)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t_k+h_k\tau_j)\)</span> do not exist a priori. We create them by a finite representation. One option is shooting: parameterize <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> on the mesh, integrate the ODE across each window with a chosen numerical step, and read interior values from that step. Another is collocation: represent <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> inside each window by a local polynomial and choose its coefficients so that the ODE holds at the interior nodes. Both constructions lead to the same structure: a nonlinear program whose objective is a composite quadrature of the running term (plus any terminal term in the Bolza case) and whose constraints are algebraic relations that encode the ODE and the pointwise inequalities at the selected nodes.</p>
<p>Specific choices recover familiar schemes. If we use the left endpoint as the single interior node, we obtain the forward Euler transcription. If we use both endpoints with equal weights, we obtain the trapezoidal transcription. Higher-order rules arise when we include interior nodes and richer polynomials for <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. What matters here is the unifying picture: choose nodes, translate integrals into weighted sums, and couple those evaluations to a finite trajectory representation so that cost and physics are enforced at the same places. This is the organizing idea that will guide the rest of the chapter.</p>
<section id="discretizing-cost-and-dynamics-together">
<h2>Discretizing cost and dynamics together<a class="headerlink" href="#discretizing-cost-and-dynamics-together" title="Link to this heading">#</a></h2>
<p>In a continuous-time OCP, integrals appear twice: in the objective, which accumulates running cost over time, and implicitly in the dynamics, since state changes over any interval are the integral of the vector field. To compute, we must approximate both the integrals and the unknown functions <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> with finitely many numbers that an optimizer can manipulate.</p>
<p>A natural way to do this is to lay down a finite set of time points (a mesh) over the horizon. You can think of the mesh as a grid we overlay on the “true” trajectories that exist as mathematical objects but are not directly accessible. Our aim is to approximate those trajectories and their integrals using values and simple models tied to the mesh. Using the same mesh for both the cost and the dynamics keeps the representation coherent: we evaluate what we pay and how the state changes at consistent times.</p>
<p>Concretely, we begin by choosing a mesh</p>
<div class="math notranslate nohighlight">
\[
t_0&lt;t_1&lt;\cdots&lt;t_N=t_f,\qquad h_k:=t_{k+1}-t_k .
\]</div>
<p>The running cost is additive over disjoint intervals. When the horizon <span class="math notranslate nohighlight">\([t_0,t_f]\)</span> is partitioned by the mesh, additivity (linearity) of the integral gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;=\; \sum_{k=0}^{N-1} \int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt .
\]</div>
<p>This identity is exact: it is just the additivity (linearity) of the Lebesgue/Riemann integral over a partition. No approximation has been made yet. Approximations enter only when we later replace each window integral by a quadrature rule: a finite set of nodes and positive weights prescribing an integral approximation. This sets the table for three important ingredients that we will use throughout the chapter.</p>
<p>First, it turns a global object into <strong>local contributions</strong> that live on each <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>. Numerical integration is most effective when it is composite: we approximate each small interval integral and then sum the results. Doing so controls error uniformly, because the global quadrature error is the accumulation of local errors that shrink with the step size. It also allows non-uniform steps <span class="math notranslate nohighlight">\(h_k=t_{k+1}-t_k\)</span>, which we will use later for mesh refinement.</p>
<p>Second, the split aligns the cost with the <strong>local dynamics constraints</strong>. On each interval the ODE can be written, by the fundamental theorem of calculus, as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt.
\]</div>
<p>When we approximate this integral, we introduce interior evaluation points <span class="math notranslate nohighlight">\(t_{k,j}\in[t_k,t_{k+1}]\)</span>. Using the <strong>same points</strong> in the cost and in the dynamics ties <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> together coherently: the places where we “pay” for running cost are also the places where we enforce the ODE. This avoids a mismatch between where we approximate the objective and where we impose feasibility.</p>
<p>Third, the decomposition yields a nonlinear program with <strong>sparse structure</strong>. Each interval contributes a small block to the objective and constraints that depends only on variables from that interval (and its endpoints). Modern solvers exploit this banded sparsity to scale to long horizons.</p>
<p>With the split justified, we standardize the approximation. Map each interval to a reference domain via <span class="math notranslate nohighlight">\(t=t_k+h_k\tau\)</span> with <span class="math notranslate nohighlight">\(\tau\in[0,1]\)</span> and <span class="math notranslate nohighlight">\(dt=h_k\,d\tau\)</span>. A <strong>quadrature rule on <span class="math notranslate nohighlight">\([0,1]\)</span></strong> is specified by evaluation points <span class="math notranslate nohighlight">\(\{\tau_j\}_{j=1}^q \subset [0,1]\)</span> and positive weights <span class="math notranslate nohighlight">\(\{w_j\}_{j=1}^q\)</span> such that, for a smooth <span class="math notranslate nohighlight">\(\phi\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\int_0^1 \phi(\tau)\,d\tau \;\approx\; \sum_{j=1}^q w_j\,\phi(\tau_j).
\]</div>
<p>Applying it on each interval gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
h_k\sum_{j=1}^q w_j\, c\!\big(\mathbf{x}(t_k+h_k\tau_j),\,\mathbf{u}(t_k+h_k\tau_j)\big).
\]</div>
<p>Summing these window contributions gives a composite approximation of the integral over <span class="math notranslate nohighlight">\([t_0,t_f]\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
\sum_{k=0}^{N-1} h_k \sum_{j=1}^q w_j\, c\!\big(\mathbf{x}(t_{k,j}),\mathbf{u}(t_{k,j})\big).
\]</div>
<p>The outer index <span class="math notranslate nohighlight">\(k\)</span> indicates the window; the inner index <span class="math notranslate nohighlight">\(i\)</span> indicates the samples within that window; the factor <span class="math notranslate nohighlight">\(h_k\)</span> appears from the change of variables.</p>
<p>The dynamics admit the same treatment. By the fundamental theorem of calculus,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)
=\int_{t_k}^{t_{k+1}} \dot{\mathbf{x}}(t)\,dt
=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt .
\]</div>
<p>Replacing this integral by a quadrature rule that uses the <strong>same</strong> nodes produces the window defect relation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}-\mathbf{x}_k
\;\approx\;
h_k\sum_{j=1}^q b_j\, \mathbf{f}\!\big(\mathbf{x}(t_{k,j}),\mathbf{u}(t_{k,j})\big),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\{b_j\}\)</span> are the weights used for the ODE. Path constraints <span class="math notranslate nohighlight">\(\mathbf{g}(\mathbf{x}(t),\mathbf{u}(t))\le 0\)</span> are imposed at selected nodes <span class="math notranslate nohighlight">\(t_{k,j}\)</span> in the same spirit. Using the same evaluation points for cost and dynamics keeps the representation coherent: we “pay” running cost and “account” for state changes at the same times.</p>
<section id="on-the-choice-of-interior-points">
<h3>On the choice of interior points<a class="headerlink" href="#on-the-choice-of-interior-points" title="Link to this heading">#</a></h3>
<p>Once we select a mesh <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> and interior fractions <span class="math notranslate nohighlight">\(\{\tau_j\}_{j=1}^q\)</span> per window <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>, we need <span class="math notranslate nohighlight">\(\mathbf{x}(t_{k,j})\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t_{k,j})\)</span> at the evaluation times <span class="math notranslate nohighlight">\(t_{k,j} := t_k + h_k\tau_j\)</span>. These values do not preexist. They come from one of two constructions that align with the standard quadrature taxonomy: <strong>step-function based</strong> and <strong>interpolating-function based</strong> rules.</p>
<section id="step-function-based-construction-piecewise-constants-rectangle-or-midpoint">
<h4>Step-function based construction (piecewise constants; rectangle or midpoint)<a class="headerlink" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint" title="Link to this heading">#</a></h4>
<p>Here we approximate the relevant time functions by step functions on each window. For controls, a common choice is piecewise-constant:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{u}(t)=\mathbf{u}_k\quad\text{for }t\in[t_k,t_{k+1}].
\]</div>
<p>For the running cost and the vector field, the corresponding quadrature is a rectangle rule on <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>. Using the left endpoint gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\; h_k\,c(\mathbf{x}_k,\mathbf{u}_k),
\]</div>
<p>and replacing the dynamics integral by the same step-function idea yields the forward Euler relation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}=\mathbf{x}_k+h_k\,\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k,t_k).
\]</div>
<p>If we prefer the midpoint rectangle rule, we sample at <span class="math notranslate nohighlight">\(t_{k+\frac12}=t_k+\tfrac{h_k}{2}\)</span>. In practice we then generate <span class="math notranslate nohighlight">\(\mathbf{x}_{k+\frac12}\)</span> by a half-step of the chosen integrator, and set <span class="math notranslate nohighlight">\(\mathbf{u}_{k+\frac12}=\mathbf{u}_k\)</span> (piecewise-constant) or an average if we allow a short linear segment. Either way, interior values come from <strong>integrating forward</strong> given a step-function model for <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and a rectangle-rule view of the integrals. This is the shooting viewpoint. Single shooting keeps only control parameters as decision variables; multiple shooting adds the window-start states and enforces step consistency.</p>
</section>
<section id="interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">
<h4>Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)<a class="headerlink" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto" title="Link to this heading">#</a></h4>
<p>Here we approximate time functions by <strong>polynomials</strong> on each window. If we interpolate <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> linearly between endpoints, the cost naturally uses the trapezoidal rule</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c\,dt\;\approx\;\tfrac{h_k}{2}\big[c(\mathbf{x}_k,\mathbf{u}_k)+c(\mathbf{x}_{k+1},\mathbf{u}_{k+1})\big],
\]</div>
<p>and the dynamics use the matched trapezoidal defect</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}=\mathbf{x}_k+\tfrac{h_k}{2}\Big[\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k,t_k)+\mathbf{f}(\mathbf{x}_{k+1},\mathbf{u}_{k+1},t_{k+1})\Big].
\]</div>
<p>With a quadratic interpolation that includes the midpoint, Simpson’s rule appears in the cost and the Hermite–Simpson relations tie <span class="math notranslate nohighlight">\(\mathbf{x}_{k+\frac12}\)</span> to endpoint values and slopes. More generally, <strong>collocation</strong> chooses interior nodes on <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> (equally spaced gives Newton–Cotes like trapezoid or Simpson; Gaussian points give Gauss, Radau, or Lobatto schemes) and enforces the ODE at those nodes:</p>
<div class="math notranslate nohighlight">
\[
\frac{d}{dt}\mathbf{x}(t_{k,j})=\mathbf{f}\!\big(\mathbf{x}(t_{k,j}),\mathbf{u}(t_{k,j}),t_{k,j}\big),
\]</div>
<p>with continuity at endpoints. The interior values <span class="math notranslate nohighlight">\(\mathbf{x}(t_{k,j})\)</span> are <strong>evaluations of the decision polynomials</strong>; <span class="math notranslate nohighlight">\(\mathbf{u}(t_{k,j})\)</span> follows from the chosen control interpolation (constant, linear, or quadratic). The running cost is evaluated by the same interpolatory quadrature at the same nodes, which keeps “where we pay” aligned with “where we enforce.”</p>
</section>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="polynomial-interpolation">
<h1>Polynomial Interpolation<a class="headerlink" href="#polynomial-interpolation" title="Link to this heading">#</a></h1>
<p>We often want to construct a function that passes through a given set of points. For example, suppose we know a function should satisfy:</p>
<div class="math notranslate nohighlight">
\[
f(x_0) = y_0, \quad f(x_1) = y_1, \quad \dots, \quad f(x_m) = y_m.
\]</div>
<p>These are called <strong>interpolation constraints</strong>. Our goal is to find a function <span class="math notranslate nohighlight">\(f(x)\)</span> that satisfies all of them exactly.</p>
<p>To make the problem tractable, we restrict ourselves to a class of functions. In polynomial interpolation, we assume that <span class="math notranslate nohighlight">\(f(x)\)</span> is a polynomial of degree at most <span class="math notranslate nohighlight">\(N\)</span>. That means we are trying to find coefficients <span class="math notranslate nohighlight">\(c_0, \dots, c_N\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \, \phi_n(x),
\]</div>
<p>where the functions <span class="math notranslate nohighlight">\(\phi_n(x)\)</span> form a basis for the space of polynomials. The most common choice is the <strong>monomial basis</strong>, where <span class="math notranslate nohighlight">\(\phi_n(x) = x^n\)</span>. This gives:</p>
<div class="math notranslate nohighlight">
\[
f(x) = c_0 + c_1 x + c_2 x^2 + \dots + c_N x^N.
\]</div>
<p>Other valid bases include Legendre, Chebyshev, and Lagrange polynomials, each chosen for specific numerical properties. But all span the same function space.</p>
<p>To find a unique solution, we need the number of unknowns (the <span class="math notranslate nohighlight">\(c_n\)</span>) to match the number of constraints. Since a degree-<span class="math notranslate nohighlight">\(N\)</span> polynomial has <span class="math notranslate nohighlight">\(N+1\)</span> coefficients, we need:</p>
<div class="math notranslate nohighlight">
\[
N + 1 = m + 1 \quad \Rightarrow \quad N = m.
\]</div>
<p>So if we want a function that passes through 4 points, we need a cubic polynomial (<span class="math notranslate nohighlight">\(N = 3\)</span>). Choosing a higher degree than necessary would give us infinitely many solutions; a lower degree may make the problem unsolvable.</p>
<section id="solving-for-the-coefficients-monomial-basis">
<h2>Solving for the Coefficients (Monomial Basis)<a class="headerlink" href="#solving-for-the-coefficients-monomial-basis" title="Link to this heading">#</a></h2>
<p>If we fix the basis functions to be monomials, we can build a system of equations by plugging in each <span class="math notranslate nohighlight">\(x_i\)</span> into <span class="math notranslate nohighlight">\(f(x)\)</span>. This gives:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
f(x_0) &amp;= c_0 + c_1 x_0 + c_2 x_0^2 + \dots + c_N x_0^N = y_0 \\
f(x_1) &amp;= c_0 + c_1 x_1 + c_2 x_1^2 + \dots + c_N x_1^N = y_1 \\
&amp;\vdots \\
f(x_m) &amp;= c_0 + c_1 x_m + c_2 x_m^2 + \dots + c_N x_m^N = y_m
\end{aligned}
\end{split}\]</div>
<p>This system can be written in matrix form as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^N \\
1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^N \\
\vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\
1 &amp; x_m &amp; x_m^2 &amp; \cdots &amp; x_m^N
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ y_1 \\ \vdots \\ y_m
\end{bmatrix}
\end{split}\]</div>
<p>The matrix on the left is called the <strong>Vandermonde matrix</strong>. Solving this system gives the coefficients <span class="math notranslate nohighlight">\(c_n\)</span> that define the interpolating polynomial.</p>
</section>
<section id="using-a-different-basis">
<h2>Using a Different Basis<a class="headerlink" href="#using-a-different-basis" title="Link to this heading">#</a></h2>
<p>We don’t have to use monomials. We can pick any set of basis functions <span class="math notranslate nohighlight">\(\phi_n(x)\)</span>, such as Chebyshev or Fourier modes, and follow the same steps. The interpolating function becomes:</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \, \phi_n(x),
\]</div>
<p>and each interpolation constraint becomes:</p>
<div class="math notranslate nohighlight">
\[
f(x_i) = \sum_{n=0}^N c_n \, \phi_n(x_i) = y_i.
\]</div>
<p>Assembling these into a system gives:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\phi_0(x_0) &amp; \phi_1(x_0) &amp; \dots &amp; \phi_N(x_0) \\
\phi_0(x_1) &amp; \phi_1(x_1) &amp; \dots &amp; \phi_N(x_1) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0(x_m) &amp; \phi_1(x_m) &amp; \dots &amp; \phi_N(x_m)
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ y_1 \\ \vdots \\ y_m
\end{bmatrix}
\end{split}\]</div>
<p>From here, we solve as before and reconstruct <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
</section>
<section id="derivative-constraints">
<h2>Derivative Constraints<a class="headerlink" href="#derivative-constraints" title="Link to this heading">#</a></h2>
<p>Sometimes, instead of a value constraint <span class="math notranslate nohighlight">\(f(x_i) = y_i\)</span>, we want to impose a slope constraint <span class="math notranslate nohighlight">\(f'(x_i) = s_i\)</span>. This is common in applications like spline interpolation or collocation methods, where derivative information is available from an ODE.</p>
<p>Since</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \phi_n(x) \quad \Rightarrow \quad f'(x) = \sum_{n=0}^N c_n \phi_n'(x),
\]</div>
<p>we can directly write the slope constraint:</p>
<div class="math notranslate nohighlight">
\[
f'(x_i) = \sum_{n=0}^N c_n \phi_n'(x_i) = s_i.
\]</div>
<p>To enforce this, we replace one of the interpolation equations in our system with this slope constraint. The resulting system still has <span class="math notranslate nohighlight">\(m+1\)</span> equations and <span class="math notranslate nohighlight">\(N+1 = m+1\)</span> unknowns.</p>
<p>Concretely, suppose we have <span class="math notranslate nohighlight">\(k+1\)</span> value constraints at nodes <span class="math notranslate nohighlight">\(X=\{x_0,\ldots,x_k\}\)</span> with values <span class="math notranslate nohighlight">\(Y=\{y_0,\ldots,y_k\}\)</span> and <span class="math notranslate nohighlight">\(r\)</span> slope constraints at nodes <span class="math notranslate nohighlight">\(Z=\{z_1,\ldots,z_r\}\)</span> with slopes <span class="math notranslate nohighlight">\(S=\{s_1,\ldots,s_r\}\)</span>, with <span class="math notranslate nohighlight">\(k+1+r=N+1\)</span>. The linear system for the coefficients <span class="math notranslate nohighlight">\(\mathbf{c}=[c_0,\ldots,c_N]^\top\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\phi_0(x_0) &amp; \phi_1(x_0) &amp; \cdots &amp; \phi_N(x_0) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0(x_k) &amp; \phi_1(x_k) &amp; \cdots &amp; \phi_N(x_k) \\
\phi_0'(z_1) &amp; \phi_1'(z_1) &amp; \cdots &amp; \phi_N'(z_1) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0'(z_r) &amp; \phi_1'(z_r) &amp; \cdots &amp; \phi_N'(z_r)
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ \vdots \\ y_k \\ s_1 \\ \vdots \\ s_r
\end{bmatrix}.
\end{split}\]</div>
<p>If a value and a slope are imposed at the same node, take <span class="math notranslate nohighlight">\(z_j=x_i\)</span> and include both the value row and the derivative row; the system remains square. In the monomial basis, the top block is the Vandermonde matrix and the derivative block has entries <span class="math notranslate nohighlight">\(n\,x^{\,n-1}\)</span>. Once solved for <span class="math notranslate nohighlight">\(\mathbf{c}\)</span>, reconstruct</p>
<div class="math notranslate nohighlight">
\[
f(x)=\sum_{n=0}^N c_n\,\phi_n(x).
\]</div>
</section>
<section id="interpolating-ode-trajectories-collocation">
<h2>Interpolating ODE Trajectories (Collocation)<a class="headerlink" href="#interpolating-ode-trajectories-collocation" title="Link to this heading">#</a></h2>
<p>Having established the general framework of interpolation, we now apply these concepts to the specific context of approximating trajectories governed by ordinary differential equations.  The idea of applying polynomial interpolation with derivative constraints yields a method known as “collocation”. More precisely, a <strong>degree-<span class="math notranslate nohighlight">\(s\)</span> collocation method</strong> is a way to discretize an ordinary differential equation (ODE) by approximating the solution on each time interval with a polynomial of degree <span class="math notranslate nohighlight">\(s\)</span>, and then enforcing that this polynomial satisfies the ODE exactly at <span class="math notranslate nohighlight">\(s\)</span> carefully chosen points (the <em>collocation nodes</em>).</p>
<p>Consider a dynamical system described by the ordinary differential equation:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t),t)
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> represents the state trajectory and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> denotes the control input.
Let us focus on a single mesh interval <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> with step size <span class="math notranslate nohighlight">\(h_k := t_{k+1}-t_k\)</span>. To work with a standardized domain, we introduce the transformation <span class="math notranslate nohighlight">\(t = t_k + h_k\tau\)</span> that maps the physical interval <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> to the reference interval <span class="math notranslate nohighlight">\([0,1]\)</span>. On this reference interval, we select a set of collocation nodes <span class="math notranslate nohighlight">\(\{\tau_j\}_{j=0}^K \subset [0,1]\)</span>.</p>
<p>Our goal is now to approximate the unknown trajectory using a polynomial of degree <span class="math notranslate nohighlight">\(K\)</span>. Using a monomial basis, we represent (parameterize) our trajectory as:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\tau) := \sum_{n=0}^K \mathbf{a}_n\,\tau^n
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{a}_n \in \mathbb{R}^d\)</span> are coefficient vectors to be determined.
Collocation enforces the differential equation at a chosen set of nodes on <span class="math notranslate nohighlight">\([0,1]\)</span>. Depending on the node family, these nodes may be interior-only or may include one or both endpoints. With the polynomial state model, we can differentiate analytically. Using the change of variables <span class="math notranslate nohighlight">\(t=t_k+h_k\,\tau\)</span>, we obtain:</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}_h(t_k+h_k\,\tau_j) = \frac{1}{h_k} \sum_{n=1}^K n\,\mathbf{a}_n\,\tau_j^{n-1}
\]</div>
<p>The collocation condition requires that this polynomial derivative equals the right-hand side of the ODE at each collocation node <span class="math notranslate nohighlight">\(\tau_j\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k} \sum_{n=1}^K n\,\mathbf{a}_n\,\tau_j^{n-1} = \mathbf{f}\left( \sum_{n=0}^K \mathbf{a}_n\,\tau_j^{n},\ \mathbf{u}_j,\ t_k+h_k\,\tau_j \right), \quad \text{for each collocation node } \tau_j.
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{u}_j\)</span> represents the control value at node <span class="math notranslate nohighlight">\(\tau_j\)</span>.</p>
<section id="boundary-conditions-and-node-families">
<h3>Boundary Conditions and Node Families<a class="headerlink" href="#boundary-conditions-and-node-families" title="Link to this heading">#</a></h3>
<figure class="align-center" id="fig-collocation-illustration" style="width: 90%">
<img alt="_images/b8b61754cea49b59cc6f8d689a0441b018d0d840d5ee6951e54465c3cd786643.png" src="_images/b8b61754cea49b59cc6f8d689a0441b018d0d840d5ee6951e54465c3cd786643.png" />
<figcaption>
<p><span class="caption-number">Fig. 1 </span><span class="caption-text">Collocation node families and where slope and continuity constraints are enforced.</span><a class="headerlink" href="#fig-collocation-illustration" title="Link to this image">#</a></p>
</figcaption>
</figure>
<p>The choice of collocation nodes determines how boundary conditions are handled and affects the resulting discretization properties. Three standard families are commonly used: Labatto, Randau and and Gauss.</p>
<p>Let’s consider these three setup with more generality over any given basis. We start again by taking a mesh interval <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> of length <span class="math notranslate nohighlight">\(h_k=t_{k+1}-t_k\)</span> and reparametrize time by</p>
<div class="math notranslate nohighlight">
\[
t = t_k + h_k\,\tau,\qquad \tau\in[0,1].
\]</div>
<p>We then choose to represent the (unknown) state by a degree–<span class="math notranslate nohighlight">\(K\)</span> polynomial</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\tau) \;=\; \sum_{n=0}^{K}\mathbf{a}_n\,\phi_n(\tau),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\{\phi_n\}_{n=0}^K\)</span> is any linearly independent basis of polynomials of degree <span class="math notranslate nohighlight">\(\le K\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{a}_0,\dots,\mathbf{a}_K\)</span> are vector coefficients to be determined.</p>
<p>The <strong>collocation condition</strong>  mean that we require for the chosen <span class="math notranslate nohighlight">\(K\)</span> collocation points that:
$<span class="math notranslate nohighlight">\(
\frac{d}{dt}\mathbf{x}_h\bigl(\tau_j\bigr) \;=\; \mathbf{f}\bigl(\mathbf{x}_h(\tau_j),\mathbf{u}_h(\tau_j),t_k+h_k\tau_j\bigr),
\qquad j=0,1,\dots,K,
\)</span>$</p>
<p>which, using <span class="math notranslate nohighlight">\(\tfrac{d}{dt}=(1/h_k)\tfrac{d}{d\tau}\)</span>, becomes</p>
<div class="math notranslate nohighlight">
\[
\underbrace{\tfrac{1}{h_k}\mathbf{x}_h'(\tau_j)}_{\text{polynomial slope at node}}
\;=\;
\underbrace{\mathbf{f}\!\bigl(\mathbf{x}_h(\tau_j),\mathbf{u}_h(\tau_j),t_k+h_k\tau_j\bigr)}_{\text{ODE slope at same point}},
\qquad j=0,\dots,K.
\]</div>
<p>Put simply: choose some nodes inside the interval, and at each of those nodes force the slope of the polynomial approximation to match the slope prescribed by the ODE. What we mean by the expression “collocation conditions” is simply to say that we want to satisfy a set of “slope-matching equations” at the chosen nodes.</p>
<p>By <strong>definition of the mesh variables</strong>,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_k := \mathbf{x}_h(0),\qquad \mathbf{x}_{k+1} := \mathbf{x}_h(1),
\]</div>
<p>and (if you sample the control at endpoints)</p>
<div class="math notranslate nohighlight">
\[
\mathbf{u}_k := \mathbf{u}_h(0),\qquad \mathbf{u}_{k+1} := \mathbf{u}_h(1).
\]</div>
<p>With the monomial basis,</p>
<div class="math notranslate nohighlight">
\[
\phi_n(0)=\delta_{n0}\ \Rightarrow\ \mathbf{x}_h(0)=\sum_{n=0}^K \mathbf{a}_n \phi_n(0)=\mathbf{a}_0=\mathbf{x}_k,
\]</div>
<div class="math notranslate nohighlight">
\[
\phi_n(1)=1\ \Rightarrow\ \mathbf{x}_h(1)=\sum_{n=0}^K \mathbf{a}_n=\mathbf{x}_{k+1}.
\]</div>
<p>For the derivative, <span class="math notranslate nohighlight">\(\phi_n'(\tau)=n\,\tau^{n-1}\)</span>, so</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h'(0)=\sum_{n=0}^K \mathbf{a}_n\,\phi_n'(0)=\mathbf{a}_1,
\qquad
\mathbf{x}_h'(1)=\sum_{n=1}^K n\,\mathbf{a}_n.
\]</div>
<p>When chaining intervals into a global trajectory, <strong>direct collocation enforces state continuity by construction</strong>: the variable <span class="math notranslate nohighlight">\(\mathbf{x}_{k+1}\)</span> at the end of one interval is the same as the starting variable of the next. What is <em>not</em> enforced automatically is <strong>slope continuity</strong>; the derivative at the end of one interval generally does not match the derivative at the start of the next. Different collocation methods may have different slope continuity properties depending on the chosen collocation nodes.</p>
<p><strong>Lobatto Nodes (endpoints included):</strong></p>
<p>The family of Labotto methods correspond to any set of so-called <strong>Lobatto nodes</strong> <span class="math notranslate nohighlight">\(\{\tau_j\}_{j=0}^K\)</span> with the specificity that we require <span class="math notranslate nohighlight">\(\tau_0=0\)</span> and <span class="math notranslate nohighlight">\(\tau_K=1\)</span>. Let’s assume that we work with the <strong>power (monomial) basis</strong> <span class="math notranslate nohighlight">\(\phi_n(\tau)=\tau^n\)</span>, so that</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\tau)=\sum_{n=0}^{K}\mathbf{a}_n\,\tau^n,
\]</div>
<p>Differentiating <span class="math notranslate nohighlight">\(\mathbf{x}_h\)</span> with respect to <span class="math notranslate nohighlight">\(\tau\)</span> gives</p>
<div class="math notranslate nohighlight">
\[
\frac{d\mathbf{x}_h}{d\tau}(\tau)=\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n'(\tau),
\]</div>
<p>Since we have the chain rule <span class="math notranslate nohighlight">\(\frac{d}{dt} = \frac{1}{h_k}\frac{d}{d\tau}\)</span> from the time transformation <span class="math notranslate nohighlight">\(t = t_k + h_k\tau\)</span>, the time derivative becomes</p>
<div class="math notranslate nohighlight">
\[
\frac{d\mathbf{x}_h}{dt}(t_k + h_k\tau) = \frac{1}{h_k}\frac{d\mathbf{x}_h}{d\tau}(\tau) = \frac{1}{h_k}\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n'(\tau).
\]</div>
<p>so the <strong>collocation equations</strong> at Lobatto nodes are</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n'(\tau_j)
\;=\;
\mathbf{f}\!\Bigl(\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n(\tau_j),\ \mathbf{u}_h(\tau_j),\ t_k+h_k\tau_j\Bigr),
\qquad j=0,1,\dots,K.
\]</div>
<p>For <span class="math notranslate nohighlight">\(j=0\)</span> and <span class="math notranslate nohighlight">\(j=K\)</span>, these conditions become:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n'(0)
\;=\;
\mathbf{f}\!\Bigl(\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n(0),\ \mathbf{u}_h(0),\ t_k\Bigr),
\qquad \text{(left endpoint)}
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n'(1)
\;=\;
\mathbf{f}\!\Bigl(\sum_{n=0}^{K}\mathbf{a}_n\,\phi_n(1),\ \mathbf{u}_h(1),\ t_{k+1}\Bigr),
\qquad \text{(right endpoint)}
\]</div>
<p>With the monomial basis <span class="math notranslate nohighlight">\(\phi_n(\tau)=\tau^n\)</span>, we have <span class="math notranslate nohighlight">\(\phi_n'(0)=n\delta_{n,1}\)</span> (only <span class="math notranslate nohighlight">\(\phi_1'=1\)</span>, others vanish) and <span class="math notranslate nohighlight">\(\phi_n'(1)=n\)</span>. Also, <span class="math notranslate nohighlight">\(\phi_n(0)=\delta_{n,0}\)</span> and <span class="math notranslate nohighlight">\(\phi_n(1)=1\)</span> for all <span class="math notranslate nohighlight">\(n\)</span>. This simplifies the endpoint conditions to:</p>
<div class="math notranslate nohighlight">
\[
\frac{\mathbf{a}_1}{h_k} = \mathbf{f}(\mathbf{a}_0, \mathbf{u}_h(0), t_k) = \mathbf{f}(\mathbf{x}_k, \mathbf{u}_k, t_k),
\qquad \text{(left endpoint slope)}
\]</div>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\sum_{n=1}^{K}n\,\mathbf{a}_n = \mathbf{f}\!\Bigl(\sum_{n=0}^{K}\mathbf{a}_n, \mathbf{u}_h(1), t_{k+1}\Bigr) = \mathbf{f}(\mathbf{x}_{k+1}, \mathbf{u}_{k+1}, t_{k+1}),
\qquad \text{(right endpoint slope)}
\]</div>
<p>These equations enforce that the polynomial’s slope at both endpoints matches the ODE’s prescribed slope, which is why the figure shows red tangent lines at both endpoints for Lobatto methods.</p>
<p><strong>Radau Nodes (one endpoint included):</strong>
Radau points include only one endpoint. Radau-I includes the left endpoint (<span class="math notranslate nohighlight">\(\tau_0 = 0\)</span>) while Radau-II includes the right endpoint (<span class="math notranslate nohighlight">\(\tau_K = 1\)</span>). This means that a radau collocation is defined by any set of collocation nodes such that <span class="math notranslate nohighlight">\(\tau_K = 1\)</span>. This translates into requireing that we match the ODE over the mesh only at the right endpoiunt in addition to the interior nodes.  As a consequence, we leave the solution unconstrained to take any value on the left endpoint. When chaining up multiple intervals across a global solution, this may pose some complication as we will no longer be able to ensure continuity as the slope at one endpoitn need not match that of the next endpoint. (But could you have a situation where slopes match but the states don’t line up?)</p>
<p>At the included endpoint the ODE is enforced (slope shown in the figure), while at the other endpoint continuity links adjacent intervals. For Radau-I with <span class="math notranslate nohighlight">\(K+1\)</span> points:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_k = \mathbf{x}_h(0) = \mathbf{a}_0
\]</div>
<p>The endpoint <span class="math notranslate nohighlight">\(\mathbf{x}_{k+1} = \mathbf{x}_h(1) = \sum_{n=0}^K \mathbf{a}_n\)</span> is not directly constrained by a collocation condition, requiring separate continuity enforcement between intervals.</p>
<p><strong>Gauss Nodes (endpoints excluded):</strong>
Gauss points exclude both endpoints, using only interior points <span class="math notranslate nohighlight">\(\tau_j \in (0,1)\)</span> for <span class="math notranslate nohighlight">\(j = 1,\ldots,K\)</span>. The ODE is enforced only at interior nodes; both endpoints are handled through separate continuity constraints:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_k = \mathbf{x}_h(0) = \mathbf{a}_0
\]</div>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1} = \mathbf{x}_h(1) = \sum_{n=0}^K \mathbf{a}_n
\]</div>
<p><strong>Origins and Selection Criteria:</strong>
These node families derive from orthogonal polynomial theory. Gauss nodes correspond to roots of Legendre polynomials and provide optimal quadrature accuracy for smooth integrands. Radau nodes are roots of modified Legendre polynomials with one endpoint constraint, while Lobatto nodes include both endpoints and correspond to roots of derivatives of Legendre polynomials.</p>
<p>For optimal control applications, Radau-II nodes are often preferred because they provide implicit time-stepping behavior and good stability properties. Lobatto nodes simplify boundary condition handling but may require smaller time steps. Gauss nodes offer highest quadrature accuracy but complicate endpoint treatment.</p>
</section>
<section id="control-parameterization-and-cost-integration">
<h3>Control Parameterization and Cost Integration<a class="headerlink" href="#control-parameterization-and-cost-integration" title="Link to this heading">#</a></h3>
<p>The control inputs can be handled with similar polynomial approximations. We may use piecewise-constant controls, piecewise-linear controls, or higher-order polynomial parameterizations of the form:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{u}_h(\tau) = \sum_{n=0}^{K_u} \mathbf{b}_n\,\tau^n
\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{u}_j = \mathbf{u}_h(\tau_j)\)</span> represents the control values at each collocation point. This polynomial framework extends to cost function evaluation, where running costs are integrated using the same quadrature nodes and weights:</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c\,dt \approx h_k\sum_{j=0}^K w_j\, c\big(\mathbf{x}_h(\tau_j),\mathbf{u}_h(\tau_j), t_k+h_k\,\tau_j\big)
\]</div>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="applying-the-recipe-concrete-transcriptions">
<h1>Applying the recipe: concrete transcriptions<a class="headerlink" href="#applying-the-recipe-concrete-transcriptions" title="Link to this heading">#</a></h1>
<p>The mesh and interior nodes are the common scaffold. What distinguishes one transcription from another is how we obtain values at those nodes and how we approximate the two integrals that appear implicitly and explicitly: the integral of the running cost and the integral that carries the state forward. In other words, we now commit to two design choices that mirror the previous section: a finite representation for <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> over each interval <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span>, and a quadrature rule whose nodes and weights are used consistently for both cost and dynamics. The result is always a sparse nonlinear program; the differences are in where we sample and how we tie samples together.</p>
<p>Below, each transcription should be read as “same grid, same interior points, same evaluations for cost and physics,” with only the local representation changing.</p>
<section id="euler-collocation">
<h2>Euler Collocation<a class="headerlink" href="#euler-collocation" title="Link to this heading">#</a></h2>
<p>Work on one interval <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> of length <span class="math notranslate nohighlight">\(h_k\)</span> with the reparametrization <span class="math notranslate nohighlight">\(t=t_k+h_k\,\tau\)</span>, <span class="math notranslate nohighlight">\(\tau\in[0,1]\)</span>. Assume a degree 1 polynomial:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\tau)=\sum_{n=0}^{1}\mathbf{a}_n\,\phi_n(\tau),
\]</div>
<p>for any basis <span class="math notranslate nohighlight">\(\{\phi_0,\phi_1\}\)</span> of linear polynomials.
Endpoint conditions give</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(0)=\mathbf{x}_k\Rightarrow \mathbf{a}_0=\mathbf{x}_k,\qquad
\mathbf{x}_h(1)=\mathbf{x}_{k+1}\Rightarrow \mathbf{a}_1=\mathbf{x}_{k+1}-\mathbf{x}_k.
\]</div>
<p>by backsubstitution and because</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\tau)=\mathbf{a}_0+\mathbf{a}_1\,\tau.
\]</div>
<p>Furthermore, the derivative with respect to <span class="math notranslate nohighlight">\(\tau\)</span> is:
$<span class="math notranslate nohighlight">\(
\frac{d}{d\tau}\mathbf{x}_h(\tau)=\mathbf{a}_1=\mathbf{x}_{k+1}-\mathbf{x}_k,
\qquad
\frac{d}{dt}=\frac{1}{h_k}\frac{d}{d\tau}
\Rightarrow
\frac{d}{dt}\mathbf{x}_h=\frac{1}{h_k}\,(\mathbf{x}_{k+1}-\mathbf{x}_k).
\)</span>$</p>
<p>Because from the mapping <span class="math notranslate nohighlight">\(t(\tau)=t_k+h_k\tau\)</span> we can invert:
<span class="math notranslate nohighlight">\(\tau(t)=\frac{t-t_k}{h_k}\)</span> and differentiating gives</p>
<div class="math notranslate nohighlight">
\[
\frac{d\tau}{dt}=\frac{1}{h_k}.
\]</div>
<p>The <strong>collocation condition</strong> at a single <strong>Radau-II node</strong> <span class="math notranslate nohighlight">\(\tau=1\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\,\mathbf{x}_h'(\tau)\Big|_{\tau=1}
\;=\;
\mathbf{f}\!\big(\mathbf{x}_h(1),\mathbf{u}_h(1),t_{k+1}\big)
\;=\;
\mathbf{f}\!\big(\mathbf{x}_{k+1},\mathbf{u}_{k+1},t_{k+1}\big).
\]</div>
<p>Because <span class="math notranslate nohighlight">\(\mathbf{x}_h\)</span> is linear, <span class="math notranslate nohighlight">\(\mathbf{x}_h'(\tau)\)</span> is constant in <span class="math notranslate nohighlight">\(\tau\)</span>, so <span class="math notranslate nohighlight">\(\mathbf{x}_h'(1)=\mathbf{x}_h'(\tau)\)</span> for all <span class="math notranslate nohighlight">\(\tau\)</span>. Moreover, linear interpolation between the two endpoints gives</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h'(\tau)=\mathbf{x}_{k+1}-\mathbf{x}_k.
\]</div>
<p>Substitute this into the collocation condition:</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_k}\big(\mathbf{x}_{k+1}-\mathbf{x}_k\big) \;=\; \mathbf{f}\!\big(\mathbf{x}_{k+1},\mathbf{u}_{k+1},t_{k+1}\big),
\]</div>
<p>which is exactly the <strong>implicit Euler</strong> step</p>
<div class="math notranslate nohighlight">
\[
{\ \mathbf{x}_{k+1}=\mathbf{x}_k + h_k\,\mathbf{f}\!\big(\mathbf{x}_{k+1},\mathbf{u}_{k+1},t_{k+1}\big)\ }.
\]</div>
<p>The overall direct transcription is then:</p>
<div class="proof definition admonition" id="definition-3">
<p class="admonition-title"><span class="caption-number">Definition 4 </span> (Implicit–Euler Collocation (Radau-II, degree 1))</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>. Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min\ &amp; c_T(\mathbf{x}_N)\;+\;\sum_{i=0}^{N-1} h_i\,c(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - h_i\,\mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})=\mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\le \mathbf{0},\\
&amp; \mathbf{x}_{\min}\le \mathbf{x}_i\le \mathbf{x}_{\max},\quad \mathbf{u}_{\min}\le \mathbf{u}_i\le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0=\mathbf{x}(t_0).
\end{aligned}
\end{split}\]</div>
</section>
</div><p>Note that:</p>
<ul class="simple">
<li><p>The running cost and path constraints are evaluated at the <strong>same</strong> right-endpoint where the dynamics are enforced, keeping “where we pay” aligned with “where we enforce.”</p></li>
<li><p>State continuity is automatic because <span class="math notranslate nohighlight">\(\mathbf{x}_{i+1}\)</span> is a shared variable between adjacent intervals; slope continuity is not enforced unless you add it.
Here’s an updated subsection that explicitly says <strong>what collocation nodes are chosen</strong> and why the trapezoidal defect uses them the way it does.</p></li>
</ul>
<blockquote>
<div><p>Side remark. If you instead collocate at the <strong>left</strong> endpoint (Radau-I with <span class="math notranslate nohighlight">\(\tau=0\)</span>) with the same linear model, you obtain <span class="math notranslate nohighlight">\(\frac{1}{h_k}(\mathbf{x}_{k+1}-\mathbf{x}_k)=\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k,t_k)\)</span>, i.e., the <strong>explicit Euler</strong> step. In that very precise sense, explicit Euler can be viewed as a (left-endpoint) degree-1 collocation scheme.</p>
</div></blockquote>
<div class="proof definition admonition" id="definition-4">
<p class="admonition-title"><span class="caption-number">Definition 5 </span> (Explicit–Euler Collocation (Radau-I, degree 1))</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span> and <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>. Solve
$<span class="math notranslate nohighlight">\(
\begin{aligned}
\min\ &amp; c_T(\mathbf{x}_N)\;+\;\sum_{i=0}^{N-1} h_i\,c(\mathbf{x}_i,\mathbf{u}_i)\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - h_i\,\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i)=\mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i)\le \mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{x}_{\min}\le \mathbf{x}_i\le \mathbf{x}_{\max},\quad \mathbf{u}_{\min}\le \mathbf{u}_i\le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0=\mathbf{x}(t_0).
\end{aligned}
\)</span>$</p>
</section>
</div></section>
<section id="trapezoidal-collocation">
<h2>Trapezoidal collocation<a class="headerlink" href="#trapezoidal-collocation" title="Link to this heading">#</a></h2>
<p>In this scheme we take the <strong>two endpoints as the nodes</strong> on each interval:</p>
<div class="math notranslate nohighlight">
\[
\tau_0=0,\qquad \tau_1=1\quad(\text{&quot;Lobatto with }K=1\text{&quot;).
\]</div>
<p>We approximate <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> <strong>linearly</strong> over <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span>, and we evaluate both the running cost and the dynamics at these two nodes with <strong>equal weights</strong>. Because a linear polynomial has a <strong>constant</strong> derivative, we do <strong>not</strong> try to match the ODE’s slope at both endpoints (that would overconstrain a linear function). Instead, we enforce the ODE in its <strong>integral form</strong> over the interval and approximate the integral of <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> by the <strong>trapezoid rule</strong> using those two nodes. This makes the cost quadrature and the state-update (“defect”) use the <strong>same nodes and weights</strong>.</p>
<div class="proof definition admonition" id="definition-5">
<p class="admonition-title"><span class="caption-number">Definition 6 </span> (Trapezoidal Collocation)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>. Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{\mathbf{x}_i,\mathbf{u}_i\}}\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} \tfrac{h_i}{2}\,\Big[c(\mathbf{x}_i,\mathbf{u}_i)+c(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big]\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i \;-\; \tfrac{h_i}{2}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i)+\mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big] \;=\; \mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \le \mathbf{0},\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0).
\end{aligned}
\end{split}\]</div>
</section>
</div><p><em>Summary:</em> the <strong>collocation nodes</strong> for trapezoidal are the <strong>two endpoints</strong>; the state is <strong>linear</strong> on each interval; and the dynamics are enforced via the <strong>integrated</strong> ODE with the <strong>trapezoid rule</strong> at those two nodes, yielding the familiar trapezoidal defect.</p>
</section>
<section id="hermitesimpson-quadratic-interpolation-midpoint-included">
<h2>Hermite–Simpson (quadratic interpolation; midpoint included)<a class="headerlink" href="#hermitesimpson-quadratic-interpolation-midpoint-included" title="Link to this heading">#</a></h2>
<p>On each interval <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span> we pick <strong>three collocation nodes</strong> on the reference domain <span class="math notranslate nohighlight">\(\tau\in[0,1]\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\tau_0=0,\qquad \tau_{1/2}=\tfrac12,\qquad \tau_1=1.
\]</div>
<p>So we evaluate at <strong>left, midpoint, right</strong>. These are the same three nodes used by Simpson’s rule (weights <span class="math notranslate nohighlight">\(1{:}4{:}1\)</span>) for numerical quadrature. We let <span class="math notranslate nohighlight">\(\mathbf{x}_h\)</span> be <strong>quadratic</strong> in <span class="math notranslate nohighlight">\(\tau\)</span>. Two things then happen:</p>
<ol class="arabic simple">
<li><p><strong>Integral (defect) enforcement with Simpson’s rule.</strong>
We enforce the ODE in integral form over the interval and approximate the integral of <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> with Simpson’s rule using the three nodes above. This yields the first constraint (the “Simpson defect”), which uses <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> evaluated at left, midpoint, and right.</p></li>
<li><p><strong>Slope matching at the midpoint (collocation).</strong>
Because a quadratic has limited shape, we don’t try to match slopes at both endpoints. Instead, we <strong>introduce midpoint variables</strong> <span class="math notranslate nohighlight">\((\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12})\)</span> and <strong>match the ODE at the midpoint</strong>. The second constraint below is exactly the midpoint collocation condition written in an equivalent Hermite form: it pins the midpoint state to the average of the endpoints plus a correction based on endpoint slopes, ensuring that the polynomial’s derivative is consistent with the ODE <strong>at <span class="math notranslate nohighlight">\(\tau=\tfrac12\)</span></strong>.</p></li>
</ol>
<p>This way, <strong>where we pay</strong> (Simpson quadrature) and <strong>where we enforce</strong> (midpoint collocation + Simpson defect) are aligned at the same three nodes, which is why the method is both accurate and well conditioned on smooth problems.</p>
<div class="proof definition admonition" id="definition-6">
<p class="admonition-title"><span class="caption-number">Definition 7 </span> (Hermite–Simpson Transcription)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span> and midpoints <span class="math notranslate nohighlight">\(t_{i+\frac12}\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>, plus midpoint variables <span class="math notranslate nohighlight">\(\{\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}\}_{i=0}^{N-1}\)</span>. Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} \tfrac{h_i}{6}\Big[ c(\mathbf{x}_i,\mathbf{u}_i) + 4\,c(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) + c(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \Big]\\
\text{s.t.}\ &amp; \underbrace{\mathbf{x}_{i+1}-\mathbf{x}_i - \tfrac{h_i}{6}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i) + 4\,\mathbf{f}(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) + \mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big]}_{\text{Simpson defect over }[t_i,t_{i+1}]} = \mathbf{0},\\
&amp; \underbrace{\mathbf{x}_{i+\frac12} - \tfrac{\mathbf{x}_i+\mathbf{x}_{i+1}}{2} - \tfrac{h_i}{8}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i) - \mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big]}_{\text{midpoint collocation (slope matching at }t_{i+\frac12}\text{)}} = \mathbf{0},\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \le \mathbf{0},\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i,\mathbf{x}_{i+\frac12} \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i,\mathbf{u}_{i+\frac12} \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0),\quad i=0,\ldots,N-1.
\end{aligned}
\end{split}\]</div>
</section>
</div><p><strong>Collocation nodes recap:</strong> <span class="math notranslate nohighlight">\(\tau=0,\ \tfrac12,\ 1\)</span>.</p>
<ul class="simple">
<li><p>The <strong>midpoint</strong> is where we explicitly <strong>match the ODE slope</strong> (collocation).</p></li>
<li><p>The <strong>three nodes together</strong> are used for the <strong>Simpson integral</strong> of <span class="math notranslate nohighlight">\(\mathbf{f}\)</span> (state update) and of <span class="math notranslate nohighlight">\(c\)</span> (cost), keeping physics and objective synchronized.</p></li>
</ul>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Link to this heading">#</a></h1>
<section id="compressor-surge-problem">
<h2>Compressor Surge Problem<a class="headerlink" href="#compressor-surge-problem" title="Link to this heading">#</a></h2>
<p>A compressor is a machine that raises the pressure of a gas by squeezing it into a smaller volume. You find them in natural gas pipelines, jet engines, and factories. But compressors can run into trouble if the flow of gas becomes too small. In that case, the machine can “stall” much like an airplane wing at too high an angle. Instead of moving forward, the gas briefly pushes back, creating strong pressure oscillations that can damage the compressor and anything connected to it.</p>
<p>To prevent this, engineers often add a close-coupled valve (CCV) at the outlet. The valve can quickly adjust the flow to keep the compressor away from these unstable conditions. Our goal is to design a control strategy for operating this valve so that the compressor never enters surge.</p>
<p>Following  <span id="id1">[<a class="reference internal" href="bibliography.html#id16" title="J.T. Gravdahl and O. Egeland. Compressor surge control using a close-coupled valve and backstepping. In Proceedings of the 1997 American Control Conference (Cat. No.97CH36041), 982–986 vol.2. IEEE, 1997. URL: http://dx.doi.org/10.1109/ACC.1997.609673, doi:10.1109/acc.1997.609673.">20</a>]</span> and <span id="id2">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span>, we model the compressor using a simplified second-order representation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\dot{x}_1 &amp;= B(\Psi_e(x_1) - x_2 - u) \\
\dot{x}_2 &amp;= \frac{1}{B}(x_1 - \Phi(x_2))
\end{aligned}
\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{x} = [x_1, x_2]^T\)</span> represents the state variables:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x_1\)</span> is the normalized mass flow through the compressor.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_2\)</span> is the normalized pressure ratio across the compressor.</p></li>
</ul>
<p>The control input <span class="math notranslate nohighlight">\(u\)</span> denotes the normalized mass flow through a CCV.
The functions <span class="math notranslate nohighlight">\(\Psi_e(x_1)\)</span> and <span class="math notranslate nohighlight">\(\Phi(x_2)\)</span> represent the characteristics of the compressor and valve, respectively:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\Psi_e(x_1) &amp;= \psi_{c0} + H\left(1 + 1.5\left(\frac{x_1}{W} - 1\right) - 0.5\left(\frac{x_1}{W} - 1\right)^3\right) \\
\Phi(x_2) &amp;= \gamma \operatorname{sign}(x_2) \sqrt{|x_2|}
\end{aligned}
\end{split}\]</div>
<p>The system parameters are given as <span class="math notranslate nohighlight">\(\gamma = 0.5\)</span>, <span class="math notranslate nohighlight">\(B = 1\)</span>, <span class="math notranslate nohighlight">\(H = 0.18\)</span>, <span class="math notranslate nohighlight">\(\psi_{c0} = 0.3\)</span>, and <span class="math notranslate nohighlight">\(W = 0.25\)</span>.</p>
<p>One possible way to pose the problem <span id="id3">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span> is by penalizing deviations from the setpoints using a quadratic penalty in the instantaneous cost function as well as in the terminal one. Furthermore, we also penalize taking large actions (which are energy hungry and potentially unsafe) within the integral term. The idea of penalizing deviations throughout is a natural way of posing the problem when solving it via single shooting. Another alternative, which we will explore below, is to set the desired setpoint as a hard terminal constraint.</p>
<p>The control objective is to stabilize the system and prevent surge, formulated as a continuous-time optimal control problem (COCP) in the Bolza form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; \left[ \int_0^T \alpha(\mathbf{x}(t) - \mathbf{x}^*)^T(\mathbf{x}(t) - \mathbf{x}^*) + \kappa u(t)^2 \, dt\right] + \beta(\mathbf{x}(T) - \mathbf{x}^*)^T(\mathbf{x}(T) - \mathbf{x}^*) + R v^2  \\
\text{subject to} \quad &amp; \dot{x}_1(t) = B(\Psi_e(x_1(t)) - x_2(t) - u(t)) \\
&amp; \dot{x}_2(t) = \frac{1}{B}(x_1(t) - \Phi(x_2(t))) \\
&amp; u_{\text{min}} \leq u(t) \leq u_{\text{max}} \\
&amp; -x_2(t) + 0.4 \leq v \\
&amp; -v \leq 0 \\
&amp; \mathbf{x}(0) = \mathbf{x}_0
\end{aligned}
\end{split}\]</div>
<p>The parameters <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\kappa\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> are non-negative weights that allow the designer to prioritize different aspects of performance (e.g., tight setpoint tracking vs. smooth control actions). We also constraint the control input to be within <span class="math notranslate nohighlight">\(0 \leq u(t) \leq 0.3\)</span> due to the physical limitations of the valve.</p>
<p>The authors in <span id="id4">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span> also add a soft path constraint <span class="math notranslate nohighlight">\(x_2(t) \geq 0.4\)</span> to ensure that we maintain a minimum pressure at all time. This is implemented as a soft constraint using slack variables. The reason that we have the term <span class="math notranslate nohighlight">\(R v^2\)</span> in the objective is to penalizes violations of the soft constraint: we allow for deviations, but don’t want to do it too much.</p>
<p>In the experiment below, we choose the setpoint <span class="math notranslate nohighlight">\(\mathbf{x}^* = [0.40, 0.60]^T\)</span> as it corresponds to an unstable equilibrium point. If we were to run the system without applying any control, we would see that the system starts to oscillate.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">60</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">N</span>
<span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span> <span class="o">=</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.60</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">instantenous_cost</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">terminal_cost</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">instantenous_cost</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">+=</span> <span class="n">terminal_cost</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">R</span> <span class="o">*</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_init</span><span class="p">):</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">z0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_init</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">z0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="o">-</span><span class="n">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">1</span><span class="p">]},</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">result</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="c1"># Run optimizations and simulations</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Optimized control starting from zero</span>
<span class="n">z_single_shooting</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="n">u_opt_shoot</span><span class="p">,</span> <span class="n">v_opt_shoot</span> <span class="o">=</span> <span class="n">z_single_shooting</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_single_shooting</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x_opt_shoot</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_opt_shoot</span><span class="p">)</span>

<span class="c1"># Do-nothing control (u = 0)</span>
<span class="n">u_nothing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">x_nothing</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_nothing</span><span class="p">)</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (opt from 0)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (opt from 0)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (do-nothing)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (do-nothing)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x2_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimized from 0&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Do-nothing&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control inputs</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_opt_shoot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimized from 0&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_nothing</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Do-nothing&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.17449650787602988
            Iterations: 37
            Function evaluations: 2306
            Gradient evaluations: 37
</pre></div>
</div>
<img alt="_images/eb0ffa1d50977921de230aec061a1ac4b423b6e36dda6b69679531f6ff581bbf.png" src="_images/eb0ffa1d50977921de230aec061a1ac4b423b6e36dda6b69679531f6ff581bbf.png" />
</div>
</div>
<section id="solution-by-trapezoidal-collocation">
<h3>Solution by Trapezoidal Collocation<a class="headerlink" href="#solution-by-trapezoidal-collocation" title="Link to this heading">#</a></h3>
<p>Another way to pose the problem is by imposing a terminal state constraint on the system rather than through a penalty in the integral term. In the following experiment, we use a problem formulation of the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; \left[ \int_0^T \kappa u(t)^2 \, dt\right] \\
\text{subject to} \quad &amp; \dot{x}_1(t) = B(\Psi_e(x_1(t)) - x_2(t) - u(t)) \\
&amp; \dot{x}_2(t) = \frac{1}{B}(x_1(t) - \Phi(x_2(t))) \\
&amp; u_{\text{min}} \leq u(t) \leq u_{\text{max}} \\
&amp; \mathbf{x}(0) = \mathbf{x}_0 \\
&amp; \mathbf{x}(T) = \mathbf{x}^\star
\end{aligned}
\end{split}\]</div>
<p>We then find a control function <span class="math notranslate nohighlight">\(u(t)\)</span> and state trajectory <span class="math notranslate nohighlight">\(x(t)\)</span> using the trapezoidal collocation method.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.08</span>
<span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span>  <span class="c1"># Number of collocation points</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span> <span class="o">=</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.60</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>
    
    <span class="c1"># Trapezoidal rule for the cost function</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cost</span>

<span class="k">def</span><span class="w"> </span><span class="nf">constraints</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>
    
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Dynamics constraints (trapezoidal rule)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">f_i</span> <span class="o">=</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">f_ip1</span> <span class="o">=</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_ip1</span><span class="p">)))</span>
    
    <span class="c1"># Terminal constraint</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_star</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_star</span><span class="p">])</span>
    
    <span class="c1"># Initial condition constraint</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">):</span>
    <span class="c1"># Initial guess</span>
    <span class="n">x_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="p">[</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">u_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_init</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">u_init</span><span class="p">])</span>
    
    <span class="c1"># Bounds</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># State variables</span>
    <span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># Control inputs</span>
    
    <span class="c1"># Constraints</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">constraints</span><span class="p">}</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">objective</span><span class="p">,</span>
        <span class="n">z0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">result</span>

<span class="c1"># Run optimization</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">z_opt</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="n">x_opt_coll</span> <span class="o">=</span> <span class="n">z_opt</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">u_opt_coll</span> <span class="o">=</span> <span class="n">z_opt</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization successful: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final objective value: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final state: x1 = </span><span class="si">{</span><span class="n">x_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target state: x1 = </span><span class="si">{</span><span class="n">x1_star</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x2_star</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Create interpolated control function</span>
<span class="n">u_func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_opt_coll</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">u_opt_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># Solve IVP with the optimized control</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">dense_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Generate solution points</span>
<span class="n">t_dense</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">x_ivp</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">sol</span><span class="p">(</span><span class="n">t_dense</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (collocation)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (collocation)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (integrated)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (integrated)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x2_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Collocation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Integrated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control inputs</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_opt_coll</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Collocation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t_dense</span><span class="p">),</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Interpolated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.002354322209548216
            Iterations: 13
            Function evaluations: 794
            Gradient evaluations: 13
Optimization successful: True
Final objective value: 0.002354322209548216
Final state: x1 = 0.4000, x2 = 0.6000
Target state: x1 = 0.4000, x2 = 0.6000
</pre></div>
</div>
<img alt="_images/9a74fc1652f3d21194ae87006d306c1071c1084523b7ec6c04eee27201ac3d2e.png" src="_images/9a74fc1652f3d21194ae87006d306c1071c1084523b7ec6c04eee27201ac3d2e.png" />
</div>
</div>
<p>You can try to vary the number of collocation points in the code and observe how the state trajectory progressively matches the ground truth (the line denoted “integrated solution”). Note that this version of the code also lacks bound constraints on the variable <span class="math notranslate nohighlight">\(x_2\)</span> to ensure a minimum pressure, as we did earlier. Consider this a good exercise to try on your own.</p>
</section>
<section id="system-identification-as-trajectory-optimization-compressor-surge">
<h3>System Identification as Trajectory Optimization (Compressor Surge)<a class="headerlink" href="#system-identification-as-trajectory-optimization-compressor-surge" title="Link to this heading">#</a></h3>
<p>We now turn the compressor surge model into a simple system identification task: estimate unknown parameters (here, the scalar <span class="math notranslate nohighlight">\(B\)</span>) from measured trajectories. This can be viewed as a trajectory optimization problem: choose parameters (and optionally states) to minimize reconstruction error while enforcing the dynamics.</p>
<p>Given time-aligned data <span class="math notranslate nohighlight">\(\{(\mathbf{u}_k,\mathbf{y}_k)\}_{k=0}^{N}\)</span>, model states <span class="math notranslate nohighlight">\(\mathbf{x}_k\in\mathbb{R}^d\)</span>, outputs <span class="math notranslate nohighlight">\(\mathbf{y}_k\approx \mathbf{h}(\mathbf{x}_k;\boldsymbol{\theta})\)</span>, step <span class="math notranslate nohighlight">\(\Delta t\)</span>, and dynamics <span class="math notranslate nohighlight">\(\mathbf{f}(\mathbf{x},\mathbf{u};\boldsymbol{\theta})\)</span>, the simultaneous (full-discretization) viewpoint is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\boldsymbol{\theta},\,\{\mathbf{x}_k\}} \quad &amp; \sum_{k\in K}\;\big\|\mathbf{y}_k - \mathbf{h}(\mathbf{x}_k;\boldsymbol{\theta})\big\|_2^2 \\
\text{s.t.}\quad &amp; \mathbf{x}_{k+1} - \mathbf{x}_k - \Delta t\,\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k;\boldsymbol{\theta}) = \mathbf{0},\quad k=0,\ldots,N-1, \\
&amp; \mathbf{x}_0 \;\text{given},
\end{aligned}
\end{split}\]</div>
<p>while the single-shooting (recursive elimination) variant eliminates the states by simulating forward from <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[
J(\boldsymbol{\theta}) := \sum_{k\in K}\;\big\|\mathbf{y}_k - \mathbf{h}(\boldsymbol{\phi}_k(\boldsymbol{\theta};\mathbf{x}_0,\mathbf{u}_{0:N-1})\big\|_2^2,\quad \min_{\boldsymbol{\theta}} J(\boldsymbol{\theta}),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_k\)</span> denotes the state reached at step <span class="math notranslate nohighlight">\(k\)</span> by an RK4 rollout under parameter <span class="math notranslate nohighlight">\(\boldsymbol{\theta}\)</span>. In our demo the data grid and rollout grid coincide, so <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_k = \mathbf{x}_k\)</span> and no interpolation is required. We will identify <span class="math notranslate nohighlight">\(B\)</span> by fitting the model to data generated from the ground-truth <span class="math notranslate nohighlight">\(B=1\)</span> system under randomized initial conditions and small input perturbations.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>

<span class="c1"># Simulation parameters</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># Total simulation time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Time step</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Number of trajectories</span>
<span class="n">num_trajectories</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">]</span>

<span class="c1"># &quot;Do nothing&quot; controller with small random noise</span>
<span class="k">def</span><span class="w"> </span><span class="nf">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Mean 0, standard deviation 0.01</span>

<span class="c1"># Function to simulate a single trajectory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">):</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate multiple trajectories</span>
<span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">initial_conditions</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_trajectories</span><span class="p">):</span>
    <span class="c1"># Randomize initial conditions around [0.5, 0.5]</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">initial_conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<span class="c1"># Calculate control inputs (small random noise)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u_func</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;x1 (Traj </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;x2 (Traj </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time (Multiple Trajectories)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait (Multiple Trajectories)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control input (small random noise)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time (Small random noise)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Save the data</span>
<span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;_static/compressor_surge_data_multi.npz&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">trajectories</span><span class="o">=</span><span class="n">trajectories</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="o">=</span><span class="n">initial_conditions</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data collection complete. Results saved to &#39;compressor_surge_data_multi.npz&#39;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data shape: </span><span class="si">{</span><span class="n">num_trajectories</span><span class="si">}</span><span class="s2"> trajectories, each with </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> time steps&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time range: 0 to </span><span class="si">{</span><span class="n">T</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial conditions:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Trajectory </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: x1 = </span><span class="si">{</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/2eda027356dc69b3f97a6ddbe109254f26c1b9b98e9913c5cff05dc598e9bb6c.png" src="_images/2eda027356dc69b3f97a6ddbe109254f26c1b9b98e9913c5cff05dc598e9bb6c.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data collection complete. Results saved to &#39;compressor_surge_data_multi.npz&#39;
Data shape: 10 trajectories, each with 501 time steps
Time range: 0 to 50 seconds
Initial conditions:
  Trajectory 1: x1 = 0.4535, x2 = 0.5538
  Trajectory 2: x1 = 0.4559, x2 = 0.5075
  Trajectory 3: x1 = 0.4804, x2 = 0.5273
  Trajectory 4: x1 = 0.4923, x2 = 0.4593
  Trajectory 5: x1 = 0.4919, x2 = 0.4814
  Trajectory 6: x1 = 0.4829, x2 = 0.4015
  Trajectory 7: x1 = 0.5212, x2 = 0.5046
  Trajectory 8: x1 = 0.5162, x2 = 0.4445
  Trajectory 9: x1 = 0.5731, x2 = 0.4336
  Trajectory 10: x1 = 0.4496, x2 = 0.4828
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;_static/compressor_surge_data_multi.npz&#39;</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
<span class="n">trajectories</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;trajectories&#39;</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span>
<span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;initial_conditions&#39;</span><span class="p">]</span>

<span class="c1"># Known system parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="c1"># B is the parameter we want to identify</span>
<span class="n">B_true</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># True value, used for comparison</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rk4_step</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k4</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k3</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">system_dynamics</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
        <span class="n">x_sim</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">error</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error</span>

<span class="c1"># Perform optimization</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>

<span class="n">B_identified</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True B: </span><span class="si">{</span><span class="n">B_true</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Identified B: </span><span class="si">{</span><span class="n">B_identified</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative error: </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">B_identified</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">B_true</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">B_true</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Plot one trajectory for comparison</span>
<span class="n">traj_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="n">traj_index</span><span class="p">]</span>
<span class="n">x_sim</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">[</span><span class="n">traj_index</span><span class="p">],</span> <span class="n">B_identified</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x1_obs</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed x1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed x2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated x1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated x2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Observed vs Simulated Trajectory&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase Portrait: Observed vs Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully.
         Current function value: 6.037438
         Iterations: 15
         Function evaluations: 30
True B: 1.0
Identified B: 0.9927978515624987
Relative error: 0.72%
</pre></div>
</div>
<img alt="_images/f09fa342132a1b32e91245c2c160fc55718932f5c9aab312fa805b30cae3addb.png" src="_images/f09fa342132a1b32e91245c2c160fc55718932f5c9aab312fa805b30cae3addb.png" />
</div>
</div>
</section>
</section>
<section id="flight-trajectory-optimization">
<h2>Flight Trajectory Optimization<a class="headerlink" href="#flight-trajectory-optimization" title="Link to this heading">#</a></h2>
<p>We consider a concrete task: computing a fuel-optimal trajectory between Montréal–Trudeau (CYUL) and Toronto Pearson (CYYZ), taking into account both aircraft dynamics and wind conditions along the route. The wind field comes from <strong>ERA5</strong>, a global atmospheric dataset produced by the ECMWF. It combines historical observations from satellites, aircraft, and surface stations with a weather model to reconstruct the state of the atmosphere across space and time. In climate science, this is called a <em>reanalysis</em>.</p>
<p>ERA5 data is stored in <strong>GRIB files</strong>, a compact format widely used in meteorology. Each file contains a <strong>gridded field</strong>: values of wind and other variables arranged on a regular 4D lattice over longitude, latitude, altitude, and time. Since the aircraft rarely sits exactly on a grid point, we interpolate the wind components it sees as it moves.</p>
<p>The aircraft is modeled as a point mass with state</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t) = (x(t), y(t), h(t), m(t)),
\]</div>
<p>where <span class="math notranslate nohighlight">\((x, y)\)</span> is horizontal position, <span class="math notranslate nohighlight">\(h\)</span> is altitude, and <span class="math notranslate nohighlight">\(m\)</span> is remaining mass. Controls are Mach number <span class="math notranslate nohighlight">\(M(t)\)</span>, vertical speed <span class="math notranslate nohighlight">\(v\_s(t)\)</span>, and heading angle <span class="math notranslate nohighlight">\(\psi(t)\)</span>. The equations of motion combine airspeed and wind:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\dot x &amp;= v(M,h)\cos\psi\cos\gamma + u_w(x,y,h,t), \\
\dot y &amp;= v(M,h)\sin\psi\cos\gamma + v_w(x,y,h,t), \\
\dot h &amp;= v_s, \\
\dot m &amp;= -\,\mathrm{FF}(T(h,M,v_s), h, M, v_s),
\end{aligned}
\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\gamma = \arcsin(v\_s / v)\)</span> is the flight path angle and <span class="math notranslate nohighlight">\(\mathrm{FF}\)</span> is the fuel flow rate based on current conditions. The wind terms <span class="math notranslate nohighlight">\(u\_w\)</span> and <span class="math notranslate nohighlight">\(v\_w\)</span> are taken from ERA5 and interpolated in space and time.</p>
<p>The optimization minimizes fuel burn over the CYUL–CYYZ leg. But the same setup could be used to minimize arrival time, or some weighted combination of time, cost, and emissions.</p>
<p>We use <strong>OpenAP.top</strong>, which solves the problem using direct collocation at <strong>Legendre–Gauss–Lobatto (LGL)</strong> points. Each trajectory segment is mapped to the unit interval, the state is interpolated by Lagrange polynomials at nonuniform LGL nodes, and the dynamics are enforced at those points. Integration is done with matching quadrature weights.</p>
<p>This setup lets us optimize trajectories under realistic conditions by feeding in the appropriate ERA5 GRIB file (e.g., <code class="docutils literal notranslate"><span class="pre">era5_mtl_20230601_12.grib</span></code>). The result accounts for wind patterns (eg. headwinds, tailwinds, shear) along the corridor between Montréal and Toronto.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># OpenAP.top demo with optional wind overlay – docs: https://github.com/junzis/openap-top</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openap</span><span class="w"> </span><span class="kn">import</span> <span class="n">top</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

<span class="c1"># Montreal region route (Canada): CYUL (Montréal–Trudeau) → CYYZ (Toronto)</span>
<span class="n">opt</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">CompleteFlight</span><span class="p">(</span><span class="s2">&quot;A320&quot;</span><span class="p">,</span> <span class="s2">&quot;CYUL&quot;</span><span class="p">,</span> <span class="s2">&quot;CYYZ&quot;</span><span class="p">,</span> <span class="n">m0</span><span class="o">=</span><span class="mf">0.85</span><span class="p">)</span>

<span class="c1"># Optional: point to a local ERA5/GRIB file to enable wind (set env var OPENAP_WIND_GRIB)</span>
<span class="c1"># If not set, look for a default small file produced by `_static/openap_fetch_era5.py`.</span>
<span class="n">fgrib</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;OPENAP_WIND_GRIB&quot;</span><span class="p">,</span> <span class="s2">&quot;_static/era5_mtl_20230601_12.grib&quot;</span><span class="p">)</span>
<span class="n">windfield</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">if</span> <span class="n">fgrib</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">fgrib</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">windfield</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">tools</span><span class="o">.</span><span class="n">read_grids</span><span class="p">(</span><span class="n">fgrib</span><span class="p">)</span>
        <span class="n">opt</span><span class="o">.</span><span class="n">enable_wind</span><span class="p">(</span><span class="n">windfield</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">windfield</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># fall back silently if GRIB reading deps are missing</span>

<span class="c1"># Solve for a fuel-optimal trajectory (CasADi direct collocation under the hood)</span>
<span class="n">flight</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">trajectory</span><span class="p">(</span><span class="n">objective</span><span class="o">=</span><span class="s2">&quot;fuel&quot;</span><span class="p">)</span>

<span class="c1"># Visualize; overlay wind barbs if windfield available</span>
<span class="k">if</span> <span class="n">windfield</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">trajectory</span><span class="p">(</span><span class="n">flight</span><span class="p">,</span> <span class="n">windfield</span><span class="o">=</span><span class="n">windfield</span><span class="p">,</span> <span class="n">barb_steps</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">vis</span><span class="o">.</span><span class="n">trajectory</span><span class="p">(</span><span class="n">flight</span><span class="p">)</span>

<span class="n">title</span> <span class="o">=</span> <span class="s2">&quot;OpenAP.top fuel-optimal trajectory (A320: CYUL → CYYZ)&quot;</span>
<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="s2">&quot;set_title&quot;</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/f9b6c8c1fa88ed1bdf864a5e7a4ae40a6f68104666bcd1ba3120a0a3be81531c.png" src="_images/f9b6c8c1fa88ed1bdf864a5e7a4ae40a6f68104666bcd1ba3120a0a3be81531c.png" />
</div>
</div>
</section>
<section id="hydro-cascade-scheduling-with-physical-routing-and-multiple-shooting">
<h2>Hydro Cascade Scheduling with Physical Routing and Multiple Shooting<a class="headerlink" href="#hydro-cascade-scheduling-with-physical-routing-and-multiple-shooting" title="Link to this heading">#</a></h2>
<p>Earlier in the book, we introduced a simplified view of hydro reservoir control, where the water level evolves in discrete time by accounting for inflow and outflow, with precipitation treated as a noisy input. While useful for learning and control design, this model abstracts away much of the physical behavior of actual rivers and dams.</p>
<p>In this chapter, we move toward a more realistic setup. We consider a series of dams arranged in a cascade, where the actions taken upstream influence downstream levels with a delay. The amount of power produced depends not only on how much water flows through the turbines, but also on the head—the vertical distance between the reservoir surface and the turbine outlet. The larger the head, the more potential energy is available for conversion into electricity, and the higher the power output.</p>
<p>To capture these effects, we follow a modeling approach inspired by the Saint-Venant equations, which describe how water levels and flows evolve in open channels. Instead of solving the full PDEs, we use a reduced model that approximates each dammed section of river—called a reach—as a lumped system governed by an ordinary differential equation. The key variable is the water level <span class="math notranslate nohighlight">\(h_r(t)\)</span>, which changes over time depending on how much water enters, how much is discharged through the turbines <span class="math notranslate nohighlight">\(q_r(t)\)</span>, and how much is spilled <span class="math notranslate nohighlight">\(s_r(t)\)</span>. The mass balance for reach <span class="math notranslate nohighlight">\(r\)</span> is written as:</p>
<div class="math notranslate nohighlight">
\[
\frac{d h_r(t)}{dt} = \frac{1}{A_r} \left( z_r(t) - q_r(t) - s_r(t) \right),
\]</div>
<p>where <span class="math notranslate nohighlight">\(A_r\)</span> is the surface area of the reservoir, assumed constant. The inflow <span class="math notranslate nohighlight">\(z_r(t)\)</span> to a reach either comes from nature (for the first dam), or from the upstream turbine and spill discharge, delayed by a travel time <span class="math notranslate nohighlight">\(\tau_{r-1}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
z_1(t) = \text{inflow}(t), \qquad
z_r(t) = q_{r-1}(t - \tau_{r-1}) + s_{r-1}(t - \tau_{r-1}), \quad \text{for } r &gt; 1.
\]</div>
<p>Power generation at each reach depends on how much water is discharged and the available head:</p>
<div class="math notranslate nohighlight">
\[
P_r(t) = \rho g \eta \, q_r(t) \, H_r(h_r(t)),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\rho\)</span> is water density, <span class="math notranslate nohighlight">\(g\)</span> is gravitational acceleration, <span class="math notranslate nohighlight">\(\eta\)</span> is turbine efficiency, and <span class="math notranslate nohighlight">\(H_r(h_r(t))\)</span> denotes the head as a function of the water level. In some models, the head is approximated as the difference between the current level and a fixed tailwater height.</p>
<p>The operator’s goal is to meet a target generation profile <span class="math notranslate nohighlight">\(P^\text{ref}(t)\)</span>, such as one dictated by a market dispatch or load-following constraint. This leads to an objective that minimizes the deviation from the target over the full horizon:</p>
<div class="math notranslate nohighlight">
\[
\min_{\{q_r(t), s_r(t)\}} \int_0^T \left( \sum_{r=1}^R P_r(t) - P^\text{ref}(t) \right)^2 dt.
\]</div>
<p>In practice, this is combined with operational constraints: turbine capacity <span class="math notranslate nohighlight">\(0 \le q_r(t) \le \bar{q}_r\)</span>, spillway limits <span class="math notranslate nohighlight">\(0 \le s_r(t) \le \bar{s}_r\)</span>, and safe level bounds <span class="math notranslate nohighlight">\(h_r^{\min} \le h_r(t) \le h_r^{\max}\)</span>. Depending on the use case, one may also penalize spill to encourage water conservation, or penalize fast changes in levels for ecological reasons.</p>
<p>What makes this problem particularly interesting is the coupling across space and time. An upstream reach cannot simply act in isolation: if the operator wants reach <span class="math notranslate nohighlight">\(r\)</span> to produce power at a specific time, the water must be released by reach <span class="math notranslate nohighlight">\(r-1\)</span> sufficiently in advance. This coordination is further complicated by delays, nonlinearities in head-dependent power, and limited storage capacity.</p>
<p>We solve the problem using <strong>multiple shooting</strong>. Each reach is divided into local simulation segments over short time windows. Within each segment, the dynamics are integrated forward using the ODEs, and continuity constraints are added to ensure that the water levels match across segment boundaries. At the same time, the inflows passed from upstream reaches must arrive at the right time and be consistent with previous decisions. In discrete time, this gives rise to a set of state-update equations:</p>
<div class="math notranslate nohighlight">
\[
h_r^{k+1} = h_r^k + \Delta t \cdot \frac{1}{A_r}(z_r^k - q_r^k - s_r^k),
\]</div>
<p>with delays handled by shifting <span class="math notranslate nohighlight">\(z_r^k\)</span> according to the appropriate travel time. These constraints are enforced as part of a nonlinear program, alongside the power tracking objective and control bounds.</p>
<p>Compared to the earlier inflow-outflow model, this richer setup introduces more structure, but also more opportunity. The cascade now behaves like a coordinated team: upstream reservoirs can store water in anticipation of future needs, while downstream dams adjust their output to match arrivals and avoid overflows. The optimization reveals not just a schedule, but a strategy for how the entire system should act together to meet demand.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Instrumented MSD hydro demo with heterogeneity + diagnostics</span>
<span class="c1"># - Breaks symmetry to avoid trivial identical plots</span>
<span class="c1"># - Adds rich diagnostics to explain flat levels and equalities</span>
<span class="c1">#</span>
<span class="c1"># This cell runs end-to-end and shows plots + tables.</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Tuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>

<span class="c1"># ---------- Model ----------</span>

<span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># m/s^2</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ReachParams</span><span class="p">:</span>
    <span class="n">L</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">W</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">k_b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">S_b</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">k_t</span><span class="p">:</span> <span class="nb">float</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">A_surf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span>

<span class="k">def</span><span class="w"> </span><span class="nf">smooth_relu</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-9</span><span class="p">):</span>
    <span class="k">return</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">eps</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">q_bypass</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rp</span><span class="p">:</span> <span class="n">ReachParams</span><span class="p">):</span>
    <span class="n">H_eff</span> <span class="o">=</span> <span class="n">smooth_relu</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rp</span><span class="o">.</span><span class="n">k_b</span> <span class="o">*</span> <span class="n">rp</span><span class="o">.</span><span class="n">S_b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">g</span><span class="o">*</span><span class="n">H_eff</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">muskingum_coeffs</span><span class="p">(</span><span class="n">K</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">X</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]:</span>
    <span class="n">D</span>  <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">dt</span>
    <span class="n">C0</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">-</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">+</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="n">X</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">K</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">dt</span><span class="p">)</span> <span class="o">/</span> <span class="n">D</span>
    <span class="k">return</span> <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span>

<span class="k">def</span><span class="w"> </span><span class="nf">integrate_interval</span><span class="p">(</span><span class="n">H0</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">rp</span><span class="p">:</span> <span class="n">ReachParams</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Forward Euler. Returns Hend, avg_qout.&quot;&quot;&quot;</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">dt</span><span class="o">/</span><span class="n">nsub</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">H0</span>
    <span class="n">qsum</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nsub</span><span class="p">):</span>
        <span class="n">qb</span> <span class="o">=</span> <span class="n">q_bypass</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">rp</span><span class="p">)</span>
        <span class="n">qout</span> <span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="n">qb</span>
        <span class="n">dHdt</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="n">qout</span><span class="p">)</span> <span class="o">/</span> <span class="n">rp</span><span class="o">.</span><span class="n">A_surf</span>
        <span class="n">H</span> <span class="o">+=</span> <span class="n">h</span><span class="o">*</span><span class="n">dHdt</span>
        <span class="n">qsum</span> <span class="o">+=</span> <span class="n">qout</span>
    <span class="k">return</span> <span class="n">H</span><span class="p">,</span> <span class="n">qsum</span><span class="o">/</span><span class="n">nsub</span>

<span class="k">def</span><span class="w"> </span><span class="nf">shapes</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">nH</span><span class="p">,</span> <span class="n">nu</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="n">H</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="n">nH</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nH</span><span class="p">:</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">:</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="o">+</span><span class="n">nz</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pack</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">H</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">u</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">z</span><span class="o">.</span><span class="n">ravel</span><span class="p">()])</span>

<span class="c1"># ---------- Problem builder ----------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_params_hetero</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Heterogeneous reaches to break symmetry.&quot;&quot;&quot;</span>
    <span class="c1"># Widths, spillway areas, and power coeffs vary by reach</span>
    <span class="n">W_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">80</span><span class="p">,</span> <span class="mi">140</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>         <span class="c1"># m</span>
    <span class="n">L_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">4000.0</span><span class="p">)</span>              <span class="c1"># m</span>
    <span class="n">S_b_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">14.0</span><span class="p">,</span> <span class="mf">20.0</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>    <span class="c1"># m^2</span>
    <span class="n">k_t_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">7.5</span><span class="p">,</span> <span class="mf">8.5</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>      <span class="c1"># power coeff</span>
    <span class="n">k_b_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.55</span><span class="p">,</span> <span class="mf">0.65</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>    <span class="c1"># spill coeff</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">ReachParams</span><span class="p">(</span><span class="n">L</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">L_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">W</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">W_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                        <span class="n">k_b</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">k_b_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">S_b</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">S_b_list</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                        <span class="n">k_t</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">k_t_list</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_demo</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">900.0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">hetero</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">make_params_hetero</span><span class="p">(</span><span class="n">M</span><span class="p">)</span> <span class="k">if</span> <span class="n">hetero</span> <span class="k">else</span> <span class="p">[</span><span class="n">ReachParams</span><span class="p">(</span><span class="mf">4000.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">,</span> <span class="mf">18.26</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span>

    <span class="c1"># initial levels (heterogeneous)</span>
    <span class="n">H0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">17.0</span><span class="p">,</span> <span class="mf">16.7</span><span class="p">,</span> <span class="mf">17.3</span><span class="p">][:</span><span class="n">M</span><span class="p">])</span>

    <span class="n">H_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">17.0</span><span class="p">,</span> <span class="mf">16.9</span><span class="p">,</span> <span class="mf">17.1</span><span class="p">][:</span><span class="n">M</span><span class="p">])</span> <span class="k">if</span> <span class="n">hetero</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">)</span>
    <span class="n">H_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mf">16.0</span><span class="p">,</span> <span class="mf">18.5</span><span class="p">)</span>
    <span class="n">u_bounds</span> <span class="o">=</span> <span class="p">(</span><span class="mf">40.0</span><span class="p">,</span> <span class="mf">160.0</span><span class="p">)</span>

    <span class="n">Qin_base</span> <span class="o">=</span> <span class="mf">300.0</span>
    <span class="n">Qin_ext</span> <span class="o">=</span> <span class="n">Qin_base</span> <span class="o">+</span> <span class="mf">30.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># stronger swing</span>

    <span class="n">Pref_raw</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">+</span> <span class="mf">15.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">N</span><span class="p">)</span>

    <span class="c1"># default Muskingum parameters per link (M-1 links)</span>
    <span class="k">if</span> <span class="n">M</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">K_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1800.0</span><span class="p">,</span> <span class="mf">2700.0</span><span class="p">,</span> <span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">K_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">H0</span><span class="o">=</span><span class="n">H0</span><span class="p">,</span> <span class="n">H_ref</span><span class="o">=</span><span class="n">H_ref</span><span class="p">,</span> <span class="n">H_bounds</span><span class="o">=</span><span class="n">H_bounds</span><span class="p">,</span>
                <span class="n">u_bounds</span><span class="o">=</span><span class="n">u_bounds</span><span class="p">,</span> <span class="n">Qin_ext</span><span class="o">=</span><span class="n">Qin_ext</span><span class="p">,</span> <span class="n">Pref_raw</span><span class="o">=</span><span class="n">Pref_raw</span><span class="p">,</span>
                <span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span><span class="n">M</span><span class="p">,</span> <span class="n">nsub</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                <span class="n">muskingum</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">K</span><span class="o">=</span><span class="n">K_list</span><span class="p">,</span> <span class="n">X</span><span class="o">=</span><span class="n">X_list</span><span class="p">))</span>

<span class="c1"># ---------- Objective / constraints / helpers ----------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">compute_total_power</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">params</span><span class="p">):</span>
    <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Pn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">Pn</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">k_t</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">Pn</span>

<span class="k">def</span><span class="w"> </span><span class="nf">decompose_objective</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">Pref</span><span class="p">,</span> <span class="n">wP</span><span class="p">,</span> <span class="n">wH</span><span class="p">,</span> <span class="n">wDu</span><span class="p">):</span>
    <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">])</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">H_ref</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H_ref&quot;</span><span class="p">]</span>
    <span class="n">track</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">compute_total_power</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">params</span><span class="p">)</span><span class="o">-</span><span class="n">Pref</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">lvl</span>   <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">H</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">H_ref</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">du</span>    <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">u</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">track</span><span class="o">=</span><span class="n">wP</span><span class="o">*</span><span class="n">track</span><span class="p">,</span> <span class="n">lvl</span><span class="o">=</span><span class="n">wH</span><span class="o">*</span><span class="n">lvl</span><span class="p">,</span> <span class="n">du</span><span class="o">=</span><span class="n">wDu</span><span class="o">*</span><span class="n">du</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">track</span><span class="o">=</span><span class="n">track</span><span class="p">,</span><span class="n">lvl</span><span class="o">=</span><span class="n">lvl</span><span class="p">,</span><span class="n">du</span><span class="o">=</span><span class="n">du</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_objective</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Pref</span><span class="p">,</span> <span class="n">wP</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">wH</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">wDu</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">H_ref</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H_ref&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">obj</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">wP</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">compute_total_power</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">params</span><span class="p">)</span><span class="o">-</span><span class="n">Pref</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">wH</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">H</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">H_ref</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">wDu</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">u</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">u</span><span class="p">[:,:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">wP</span><span class="o">=</span><span class="n">wP</span><span class="p">,</span><span class="n">wH</span><span class="o">=</span><span class="n">wH</span><span class="p">,</span><span class="n">wDu</span><span class="o">=</span><span class="n">wDu</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_constraints</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">H0</span><span class="p">,</span> <span class="n">Qin_ext</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">nsub</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H0&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Qin_ext&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nsub&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">init_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">);</span> <span class="k">return</span> <span class="n">H</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">H0</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span><span class="n">init_fun</span><span class="p">})</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dyn_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">Hend</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">Hend</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span><span class="n">dyn_fun</span><span class="p">})</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coup_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
        <span class="n">res</span><span class="o">=</span><span class="p">[]</span>
        <span class="c1"># First reach is exogenous inflow per interval</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">]</span><span class="o">-</span><span class="n">Qin_ext</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="c1"># Downstream links: Muskingum routing</span>
        <span class="n">K_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">X_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">):</span>
            <span class="c1"># Seed condition for z[i,0]</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">I0</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">I0</span><span class="p">)</span>
            <span class="c1"># Coefficients</span>
            <span class="n">Ki</span> <span class="o">=</span> <span class="n">K_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">K_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1800.0</span>
            <span class="n">Xi</span> <span class="o">=</span> <span class="n">X_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.2</span>
            <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">muskingum_coeffs</span><span class="p">(</span><span class="n">Ki</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="c1"># Recursion over intervals</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># upstream interval-average outflows for n and n+1</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">I_n</span>   <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">I_np1</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">C0</span><span class="o">*</span><span class="n">I_np1</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">I_n</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span><span class="s1">&#39;eq&#39;</span><span class="p">,</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span><span class="n">coup_fun</span><span class="p">})</span>
    <span class="k">return</span> <span class="n">cons</span>

<span class="k">def</span><span class="w"> </span><span class="nf">make_bounds</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">Hmin</span><span class="p">,</span><span class="n">Hmax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H_bounds&quot;</span><span class="p">]</span>
    <span class="n">umin</span><span class="p">,</span><span class="n">umax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;u_bounds&quot;</span><span class="p">]</span>
    <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span>
    <span class="n">nH</span><span class="p">,</span><span class="n">nu</span><span class="p">,</span><span class="n">nz</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="o">+</span><span class="n">nz</span><span class="p">);</span> <span class="n">ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">lb</span><span class="p">)</span>
    <span class="n">lb</span><span class="p">[:</span><span class="n">nH</span><span class="p">]</span><span class="o">=</span><span class="n">Hmin</span><span class="p">;</span> <span class="n">ub</span><span class="p">[:</span><span class="n">nH</span><span class="p">]</span><span class="o">=</span><span class="n">Hmax</span>
    <span class="n">lb</span><span class="p">[</span><span class="n">nH</span><span class="p">:</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">]</span><span class="o">=</span><span class="n">umin</span><span class="p">;</span> <span class="n">ub</span><span class="p">[</span><span class="n">nH</span><span class="p">:</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">]</span><span class="o">=</span><span class="n">umax</span>
    <span class="n">lb</span><span class="p">[</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">:]</span><span class="o">=</span><span class="mf">0.0</span><span class="p">;</span> <span class="n">ub</span><span class="p">[</span><span class="n">nH</span><span class="o">+</span><span class="n">nu</span><span class="p">:]</span><span class="o">=</span><span class="mf">2000.0</span>
    <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span><span class="n">ub</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">residuals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">params</span><span class="p">,</span> <span class="n">H0</span><span class="p">,</span> <span class="n">Qin_ext</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">nsub</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H0&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Qin_ext&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nsub&quot;</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">dyn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">));</span> <span class="n">coup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">Hend</span><span class="p">,</span> <span class="n">qavg</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">dyn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Hend</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">coup</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">Qin_ext</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Muskingum residual, align on current index using n and n-1</span>
                <span class="n">Ki</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1800.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">Xi</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">muskingum_coeffs</span><span class="p">(</span><span class="n">Ki</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">coup</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">I_nm1</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">I_n</span>   <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">coup</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">C0</span><span class="o">*</span><span class="n">I_n</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">I_nm1</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">dyn</span><span class="p">,</span> <span class="n">coup</span>

<span class="c1"># ---------- Feasible initial guess with hetero controls ----------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">feasible_initial_guess</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Feasible x0 with nontrivial u by setting u at mid + per-reach pattern, then integrating to define H,z.&quot;&quot;&quot;</span>
    <span class="n">M</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">nsub</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nsub&quot;</span><span class="p">]</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">]</span>
    <span class="n">umin</span><span class="p">,</span><span class="n">umax</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;u_bounds&quot;</span><span class="p">]</span>
    <span class="n">Qin_ext</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Qin_ext&quot;</span><span class="p">]</span>

    <span class="c1"># pattern to break symmetry</span>
    <span class="n">base</span> <span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">umin</span><span class="o">+</span><span class="n">umax</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
    <span class="n">tgrid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">u_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">base</span> <span class="o">+</span> <span class="mi">25</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">tgrid</span><span class="o">/</span><span class="n">N</span><span class="p">)</span> <span class="o">+</span> <span class="n">ph</span><span class="p">)</span> <span class="k">for</span> <span class="n">ph</span> <span class="ow">in</span> <span class="n">phase</span><span class="p">])</span>
    <span class="n">u_pattern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">u_pattern</span><span class="p">,</span> <span class="n">umin</span><span class="p">,</span> <span class="n">umax</span><span class="p">)</span>

    <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">));</span> <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">));</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="n">H</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;H0&quot;</span><span class="p">]</span>
    <span class="c1"># Set controls from pattern first</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">u_pattern</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span>

    <span class="c1"># First reach: exogenous inflow, integrate forward and record outflow averages</span>
    <span class="n">qavg_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">Qin_ext</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">Hend</span><span class="p">,</span> <span class="n">qavg</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">H</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hend</span>
        <span class="n">qavg_up</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">qavg</span>

    <span class="c1"># Downstream reaches with Muskingum routing</span>
    <span class="n">K_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1800.0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">X_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">M</span><span class="p">):</span>
        <span class="n">Ki</span> <span class="o">=</span> <span class="n">K_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">K_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1800.0</span>
        <span class="n">Xi</span> <span class="o">=</span> <span class="n">X_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.2</span>
        <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">muskingum_coeffs</span><span class="p">(</span><span class="n">Ki</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">I</span> <span class="o">=</span> <span class="n">qavg_up</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span>
        <span class="c1"># seed</span>
        <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># propagate recursively over time</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">C0</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">I</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span>
        <span class="c1"># integrate levels for reach i using routed inflow</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">Hend</span><span class="p">,</span> <span class="n">qavg</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">dt</span><span class="p">,</span> <span class="n">nsub</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Hend</span>
            <span class="n">qavg_up</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">qavg</span>
    <span class="k">return</span> <span class="n">pack</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">scale_pref</span><span class="p">(</span><span class="n">Pref_raw</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">])</span>
    <span class="n">P0</span> <span class="o">=</span> <span class="n">compute_total_power</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">P0</span><span class="p">),</span><span class="mf">1e-6</span><span class="p">)</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Pref_raw</span><span class="p">),</span><span class="mf">1e-6</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Pref_raw</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">P0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">run_demo</span><span class="p">(</span><span class="n">show</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">save_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s1">&#39;hydro.png&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build, solve, and render the hydro demo.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    show : bool</span>
<span class="sd">        If True, displays the matplotlib figure via plt.show().</span>
<span class="sd">    save_path : str | None</span>
<span class="sd">        If provided, saves the figure to this path.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        If True, prints diagnostic information.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    matplotlib.figure.Figure | None</span>
<span class="sd">        Returns the Figure when show is False; otherwise returns None.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ---------- Solve ----------</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">build_demo</span><span class="p">(</span><span class="n">M</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="mf">900.0</span><span class="p">,</span> <span class="n">hetero</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">feasible_initial_guess</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">Pref</span><span class="p">,</span> <span class="n">P0</span> <span class="o">=</span> <span class="n">scale_pref</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;Pref_raw&quot;</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="n">objective</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">make_objective</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Pref</span><span class="p">,</span> <span class="n">wP</span><span class="o">=</span><span class="mf">8.0</span><span class="p">,</span> <span class="n">wH</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span> <span class="n">wDu</span><span class="o">=</span><span class="mf">5e-4</span><span class="p">)</span>
    <span class="c1"># Suppress noisy SciPy warning about delta_grad during quasi-Newton updates</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span>
            <span class="s2">&quot;ignore&quot;</span><span class="p">,</span>
            <span class="n">message</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;delta_grad == 0.0&quot;</span><span class="p">,</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">UserWarning</span><span class="p">,</span>
            <span class="n">module</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;scipy\.optimize\.\_differentiable_functions&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
            <span class="n">fun</span><span class="o">=</span><span class="n">objective</span><span class="p">,</span>
            <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trust-constr&#39;</span><span class="p">,</span>
            <span class="n">bounds</span><span class="o">=</span><span class="n">make_bounds</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
            <span class="n">constraints</span><span class="o">=</span><span class="n">make_constraints</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
            <span class="n">options</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">maxiter</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="n">verbose</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">z</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">])</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">compute_total_power</span><span class="p">(</span><span class="n">H</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">])</span>
    <span class="n">dyn_res</span><span class="p">,</span> <span class="n">coup_res</span> <span class="o">=</span> <span class="n">residuals</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

    <span class="c1"># ---------- Diagnostics ----------</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">terms</span> <span class="o">=</span> <span class="n">decompose_objective</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">Pref</span><span class="p">,</span> <span class="o">**</span><span class="n">weights</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Objective decomposition ===&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span><span class="n">kk</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span> <span class="k">for</span> <span class="n">kk</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="n">v</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">terms</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Constraint residuals (max |.|) ===&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;dyn:&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dyn_res</span><span class="p">)))),</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;coup:&quot;</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">coup_res</span><span class="p">))))</span>

        <span class="c1"># Muskingum coefficient sanity and residuals</span>
        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">K_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">X_list</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;muskingum&quot;</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">coef_checks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">mean_abs_res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">]):</span>
                <span class="n">Ki</span> <span class="o">=</span> <span class="n">K_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">K_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1800.0</span>
                <span class="n">Xi</span> <span class="o">=</span> <span class="n">X_list</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_list</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.2</span>
                <span class="n">C0</span><span class="p">,</span> <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">muskingum_coeffs</span><span class="p">(</span><span class="n">Ki</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">])</span>
                <span class="n">coef_checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">link</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">C0</span><span class="o">+</span><span class="n">C1</span><span class="o">+</span><span class="n">C2</span><span class="p">),</span> <span class="n">min_coef</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">C0</span><span class="p">,</span><span class="n">C1</span><span class="p">,</span><span class="n">C2</span><span class="p">))))</span>
                <span class="c1"># compute mean abs residual for this link</span>
                <span class="n">res_vals</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">I_n</span>   <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="p">],</span>   <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nsub&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">I_np1</span> <span class="o">=</span> <span class="n">integrate_interval</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;nsub&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">res_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">C0</span><span class="o">*</span><span class="n">I_np1</span> <span class="o">+</span> <span class="n">C1</span><span class="o">*</span><span class="n">I_n</span> <span class="o">+</span> <span class="n">C2</span><span class="o">*</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]))))</span>
                <span class="n">mean_abs_res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">link</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">mean_abs</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">res_vals</span><span class="p">))))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Muskingum coeff checks (sum, min_coef) ===&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">coef_checks</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Muskingum mean |residual| per link ===&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">mean_abs_res</span><span class="p">)</span>

    <span class="c1"># Per-interval diagnostic table for each reach (kept for debugging but unused here)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">interval_table</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
        <span class="n">rp</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;params&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]):</span>
            <span class="n">qb</span> <span class="o">=</span> <span class="n">q_bypass</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">rp</span><span class="p">)</span>
            <span class="n">net</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">qb</span><span class="p">)</span>
            <span class="n">dH</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;dt&quot;</span><span class="p">]</span><span class="o">*</span><span class="n">net</span><span class="o">/</span><span class="n">rp</span><span class="o">.</span><span class="n">A_surf</span>
            <span class="n">rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">interval</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">Hn</span><span class="o">=</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">Hn1</span><span class="o">=</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">z</span><span class="o">=</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">n</span><span class="p">],</span> <span class="n">qb</span><span class="o">=</span><span class="n">qb</span><span class="p">,</span> <span class="n">net_flow</span><span class="o">=</span><span class="n">net</span><span class="p">,</span> <span class="n">dH_pred</span><span class="o">=</span><span class="n">dH</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>

    <span class="c1"># summary and tables available to callers if needed</span>
    <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="n">interval_table</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">])]</span>
    <span class="n">summary</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">([</span>
        <span class="nb">dict</span><span class="p">(</span><span class="n">reach</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
             <span class="n">H_mean</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">H_std</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
             <span class="n">u_mean</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">u_std</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span>
             <span class="n">z_mean</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">z_std</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">])</span>
    <span class="p">])</span>

    <span class="c1"># ---------- Plots ----------</span>
    <span class="n">M</span><span class="p">,</span><span class="n">N</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;M&quot;</span><span class="p">],</span> <span class="n">data</span><span class="p">[</span><span class="s2">&quot;N&quot;</span><span class="p">]</span>
    <span class="n">t_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="s1">&#39;Hydroelectric System Optimization Results&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">16</span><span class="p">)</span>

    <span class="n">ax1</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_nodes</span><span class="p">,</span> <span class="n">H</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Reach </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Node n&quot;</span><span class="p">);</span> <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;H [m]&quot;</span><span class="p">);</span> <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Water Levels&quot;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax1</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Reach </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Interval n&quot;</span><span class="p">);</span> <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;u [m³/s]&quot;</span><span class="p">);</span> <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Turbine Discharge&quot;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax2</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">ax3</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">ax3</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Reach </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">ax3</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Interval n&quot;</span><span class="p">);</span> <span class="n">ax3</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;z [m³/s]&quot;</span><span class="p">);</span> <span class="n">ax3</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Inflow (Coupling)&quot;</span><span class="p">)</span>
    <span class="n">ax3</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">);</span> <span class="n">ax3</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

    <span class="n">ax4</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P0</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Power @ x0&quot;</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Power @ optimum&quot;</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Pref</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Scaled Pref&quot;</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Interval n&quot;</span><span class="p">);</span> <span class="n">ax4</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Power units&quot;</span><span class="p">);</span> <span class="n">ax4</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Power Tracking&quot;</span><span class="p">)</span>
    <span class="n">ax4</span><span class="o">.</span><span class="n">legend</span><span class="p">();</span> <span class="n">ax4</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">return</span> <span class="n">fig</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c1"># When executed as a loaded notebook cell, __name__ == &#39;__main__&#39;.</span>
    <span class="c1"># Display once (no file write, no verbose prints).</span>
    <span class="n">run_demo</span><span class="p">(</span><span class="n">show</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/a56e0a2ebcb206e2516003798af741666e22b241953ba0173b721004284b4568.png" src="_images/a56e0a2ebcb206e2516003798af741666e22b241953ba0173b721004284b4568.png" />
</div>
</div>
<p>The figure shows the result of a multiple-shooting optimization applied to a three-reach hydroelectric cascade. The time horizon is discretized into 16 intervals, and SciPy’s <code class="docutils literal notranslate"><span class="pre">trust-constr</span></code> solver is used to find a feasible control sequence that satisfies mass balance, turbine and spillway limits, and Muskingum-style routing dynamics. Each reach integrates its own local ODE, with continuity constraints linking the flows between reaches.</p>
<p>The top-left panel shows the water levels in each reservoir. We observe that upstream reservoirs tend to increase their levels ahead of discharge events, building potential energy before releasing water downstream. The top-right panel shows turbine discharges for each reach. These vary smoothly and are temporally coordinated across the system. The bottom-right panel compares the total generation to a synthetic demand profile, which is generated by a sum of time-shifted sigmoids and normalized to be feasible given turbine capacities. The optimized schedule (orange) tracks this demand closely, while the initial guess (blue) lags behind. The bottom-left panel plots the routed inflows between reaches, which display the expected lag and smoothing effects from Muskingum routing. The interplay between these plots shows how the system anticipates, stores, and routes water to meet time-varying generation targets within physical and operational limits.</p>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ocp.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Discrete-Time Trajectory Optimization</p>
      </div>
    </a>
    <a class="right-next"
       href="mpc.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Model Predictive Control</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trajectory Optimization in Continuous Time</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-transcription-methods">Direct Transcription Methods</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discretizing-cost-and-dynamics-together">Discretizing cost and dynamics together</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#on-the-choice-of-interior-points">On the choice of interior points</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint">Step-function based construction (piecewise constants; rectangle or midpoint)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#polynomial-interpolation">Polynomial Interpolation</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-for-the-coefficients-monomial-basis">Solving for the Coefficients (Monomial Basis)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-different-basis">Using a Different Basis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#derivative-constraints">Derivative Constraints</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-ode-trajectories-collocation">Interpolating ODE Trajectories (Collocation)</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#boundary-conditions-and-node-families">Boundary Conditions and Node Families</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#control-parameterization-and-cost-integration">Control Parameterization and Cost Integration</a></li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-recipe-concrete-transcriptions">Applying the recipe: concrete transcriptions</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#euler-collocation">Euler Collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#trapezoidal-collocation">Trapezoidal collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hermitesimpson-quadratic-interpolation-midpoint-included">Hermite–Simpson (quadratic interpolation; midpoint included)</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#examples">Examples</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#compressor-surge-problem">Compressor Surge Problem</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-trapezoidal-collocation">Solution by Trapezoidal Collocation</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#system-identification-as-trajectory-optimization-compressor-surge">System Identification as Trajectory Optimization (Compressor Surge)</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#flight-trajectory-optimization">Flight Trajectory Optimization</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hydro-cascade-scheduling-with-physical-routing-and-multiple-shooting">Hydro Cascade Scheduling with Physical Routing and Multiple Shooting</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pierre-Luc Bacon
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>