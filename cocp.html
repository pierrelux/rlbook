
<!DOCTYPE html>


<html lang="en" data-content_root="./" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Trajectory Optimization in Continuous Time &#8212; Practical Reinforcement Learning: From Algorithms to Applications</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css?v=be8a1c11" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css?v=b4b7a797" />
    <link rel="stylesheet" type="text/css" href="_static/graphviz.css?v=fd3f3429" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="_static/custom.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="_static/copybutton.js?v=f281be69"></script>
    <script src="_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>window.MathJax = {"tex": {"macros": {"bm": ["{\\boldsymbol #1}", 1]}, "processEscapes": true}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'cocp';</script>
    <script src="_static/iframe-modal.js?v=f72a1242"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="From Trajectories to Policies" href="mpc.html" />
    <link rel="prev" title="Discrete-Time Trajectory Optimization" href="ocp.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Practical Reinforcement Learning: From Algorithms to Applications</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Why This Book?
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Modeling</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="modeling.html">Why Build a Model? For Whom?</a></li>

<li class="toctree-l1"><a class="reference internal" href="ssm.html">Dynamics Models for Decision Making</a></li>




<li class="toctree-l1"><a class="reference internal" href="simulation.html">Programs as Models</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Numerical Trajectory Optimization</span></p>
<ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="ocp.html">Discrete-Time Trajectory Optimization</a></li>


<li class="toctree-l1 current active"><a class="current reference internal" href="#">Trajectory Optimization in Continuous Time</a></li>




</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">From Trajectories to Policies</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="mpc.html">From Trajectories to Policies</a></li>



<li class="toctree-l1"><a class="reference internal" href="dp.html">Dynamic Programming</a></li>

</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Learning from Data</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="adp.html">Approximate Dynamic Programming</a></li>





<li class="toctree-l1"><a class="reference internal" href="cadp.html">Policy Parametrization Methods</a></li>







</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendix</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="appendix_examples.html">Example COCPs</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_ivps.html">Solving Initial Value Problems</a></li>
<li class="toctree-l1"><a class="reference internal" href="appendix_nlp.html">Nonlinear Programming</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">References</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/edit/main/cocp.md" target="_blank"
   class="btn btn-sm btn-source-edit-button dropdown-item"
   title="Suggest edit"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="btn__text-container">Suggest edit</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/pierrelux/rlbook/issues/new?title=Issue%20on%20page%20%2Fcocp.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/cocp.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Trajectory Optimization in Continuous Time</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trajectory Optimization in Continuous Time</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-transcription-methods">Direct Transcription Methods</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discretizing-cost-and-dynamics-together">Discretizing cost and dynamics together</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-do-values-at-interior-points-arise-step-functions-vs-interpolating-functions">How do values at interior points arise? (step functions vs interpolating functions)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint">Step-function based construction (piecewise constants; rectangle or midpoint)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-interpolation-problem-functions-from-constraints">The Interpolation Problem: Functions from Constraints</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#how-many-coefficients-do-we-need">How Many Coefficients Do We Need?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-for-the-coefficients-monomial-basis">Solving for the Coefficients (Monomial Basis)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-different-basis">Using a Different Basis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#derivative-constraints">Derivative Constraints</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-ode-trajectories-collocation">Interpolating ODE trajectories (collocation)</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-recipe-concrete-transcriptions">Applying the recipe: concrete transcriptions</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-among-them">Choosing among them</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-brief-note-on-reconstruction">A brief note on reconstruction</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compressor-surge-problem">Example: Compressor Surge Problem</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-trapezoidal-collocation">Solution by Trapezoidal Collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#system-identification-as-trajectory-optimization-compressor-surge">System Identification as Trajectory Optimization (Compressor Surge)</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="trajectory-optimization-in-continuous-time">
<h1>Trajectory Optimization in Continuous Time<a class="headerlink" href="#trajectory-optimization-in-continuous-time" title="Link to this heading">#</a></h1>
<p>As in the discrete-time setting, we work with three continuous-time variants that differ only in how the objective is written while sharing the same dynamics, path constraints, and bounds. The path constraints <span class="math notranslate nohighlight">\(\mathbf{g}(\mathbf{x}(t),\mathbf{u}(t))\le \mathbf{0}\)</span> are pointwise in time, and the bounds <span class="math notranslate nohighlight">\(\mathbf{x}_{\min}\le \mathbf{x}(t)\le \mathbf{x}_{\max}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}_{\min}\le \mathbf{u}(t)\le \mathbf{u}_{\max}\)</span> are understood in the same pointwise sense.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row sd-g-1 sd-g-xs-1 sd-g-sm-1 sd-g-md-1 sd-g-lg-1 docutils">
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-0">
<p class="admonition-title"><span class="caption-number">Definition 1 </span> (Mayer Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; c(\mathbf{x}(t_f)) \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-1">
<p class="admonition-title"><span class="caption-number">Definition 2 </span> (Lagrange Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; \int_{t_0}^{t_f} c(\mathbf{x}(t), \mathbf{u}(t)) \, dt \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
<div class="sd-col sd-d-flex-column docutils">
<div class="proof definition admonition" id="definition-2">
<p class="admonition-title"><span class="caption-number">Definition 3 </span> (Bolza Problem)</p>
<section class="definition-content" id="proof-content">
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    \text{minimize} \quad &amp; c(\mathbf{x}(t_f)) + \int_{t_0}^{t_f} c(\mathbf{x}(t), \mathbf{u}(t)) \, dt \\
    \text{subject to} \quad &amp; \dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t), \mathbf{u}(t)) \\
                            &amp; \mathbf{g}(\mathbf{x}(t), \mathbf{u}(t)) \leq \mathbf{0} \\
                            &amp; \mathbf{x}_{\text{min}} \leq \mathbf{x}(t) \leq \mathbf{x}_{\text{max}} \\
                            &amp; \mathbf{u}_{\text{min}} \leq \mathbf{u}(t) \leq \mathbf{u}_{\text{max}} \\
    \text{given} \quad &amp; \mathbf{x}(t_0) = \mathbf{x}_0 \enspace .
\end{aligned}
\end{split}\]</div>
</section>
</div></div>
</div>
</div>
<p>These three forms are different lenses on the same task. Bolza contains both terminal and running terms. Lagrange can be turned into Mayer by augmenting the state with an accumulator:</p>
<div class="math notranslate nohighlight">
\[
\dot{z}(t)=c(\mathbf{x}(t),\mathbf{u}(t)),\quad z(t_0)=0,\quad \text{minimize } z(t_f),
\]</div>
<p>with the original dynamics left unchanged. Mayer is a special case of Bolza with zero running cost. We will use these equivalences freely, since a numerical method cares only about what must be evaluated and where those evaluations are taken.</p>
<p>With this catalog in place, we now pass from functions to finite representations.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="direct-transcription-methods">
<h1>Direct Transcription Methods<a class="headerlink" href="#direct-transcription-methods" title="Link to this heading">#</a></h1>
<p>The discrete-time problems of the previous chapter already suggested how to proceed: we convert a continuous problem into one over finitely many numbers by deciding where to look at the trajectories and how to interpolate between those looks. We place a mesh <span class="math notranslate nohighlight">\(t_0&lt;t_1&lt;\cdots&lt;t_N=t_f\)</span> and, inside each window <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>, select a small set of interior fractions <span class="math notranslate nohighlight">\(\{\xi_i\}\)</span> on the reference interval <span class="math notranslate nohighlight">\([0,1]\)</span>. The running cost is additive over windows, so we write it as a sum of local integrals, map each window to <span class="math notranslate nohighlight">\([0,1]\)</span>, and approximate each local integral by a quadrature rule with nodes <span class="math notranslate nohighlight">\(\xi_i\)</span> and weights <span class="math notranslate nohighlight">\(w_i\)</span>. This produces</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
\sum_{k=0}^{N-1} h_k \sum_{i=1}^q w_i\, c\!\big(\mathbf{x}(t_k+h_k\xi_i),\,\mathbf{u}(t_k+h_k\xi_i)\big),
\]</div>
<p>with <span class="math notranslate nohighlight">\(h_k=t_{k+1}-t_k\)</span>. The dynamics are treated in the same way by the fundamental theorem of calculus,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
h_k \sum_{i=1}^q b_i\, \mathbf{f}\!\big(\mathbf{x}(t_k+h_k\xi_i),\,\mathbf{u}(t_k+h_k\xi_i)\big),
\]</div>
<p>so the places where we “pay” running cost are the same places where we “account” for state changes. Path constraints and bounds are then enforced at the same interior times. In the infinite-horizon discounted case, the same formulas apply with an extra factor <span class="math notranslate nohighlight">\(e^{-\rho(t_k+h_k\xi_i)}\)</span> multiplying the weights in the cost.</p>
<p>The values <span class="math notranslate nohighlight">\(\mathbf{x}(t_k+h_k\xi_i)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t_k+h_k\xi_i)\)</span> do not exist a priori. We create them by a finite representation. One option is shooting: parameterize <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> on the mesh, integrate the ODE across each window with a chosen numerical step, and read interior values from that step. Another is collocation: represent <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> inside each window by a local polynomial and choose its coefficients so that the ODE holds at the interior nodes. Both constructions lead to the same structure: a nonlinear program whose objective is a composite quadrature of the running term (plus any terminal term in the Bolza case) and whose constraints are algebraic relations that encode the ODE and the pointwise inequalities at the selected nodes.</p>
<p>Specific choices recover familiar schemes. If we use the left endpoint as the single interior node, we obtain the forward Euler transcription. If we use both endpoints with equal weights, we obtain the trapezoidal transcription. Higher-order rules arise when we include interior nodes and richer polynomials for <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>. What matters here is the unifying picture: choose nodes, translate integrals into weighted sums, and couple those evaluations to a finite trajectory representation so that cost and physics are enforced at the same places. This is the organizing idea that will guide the rest of the chapter.</p>
<section id="discretizing-cost-and-dynamics-together">
<h2>Discretizing cost and dynamics together<a class="headerlink" href="#discretizing-cost-and-dynamics-together" title="Link to this heading">#</a></h2>
<p>In a continuous-time OCP, integrals appear twice: in the objective, which accumulates running cost over time, and implicitly in the dynamics, since state changes over any interval are the integral of the vector field. To compute, we must approximate both the integrals and the unknown functions <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> with finitely many numbers that an optimizer can manipulate.</p>
<p>A natural way to do this is to lay down a finite set of time points (a mesh) over the horizon. You can think of the mesh as a grid we overlay on the “true” trajectories that exist as mathematical objects but are not directly accessible. Our aim is to approximate those trajectories and their integrals using values and simple models tied to the mesh. Using the same mesh for both the cost and the dynamics keeps the representation coherent: we evaluate what we pay and how the state changes at consistent times.</p>
<p>Concretely, we begin by choosing a mesh</p>
<div class="math notranslate nohighlight">
\[
t_0&lt;t_1&lt;\cdots&lt;t_N=t_f,\qquad h_k:=t_{k+1}-t_k .
\]</div>
<p>The running cost is additive over disjoint intervals. When the horizon <span class="math notranslate nohighlight">\([t_0,t_f]\)</span> is partitioned by the mesh, additivity (linearity) of the integral gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;=\; \sum_{k=0}^{N-1} \int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt .
\]</div>
<p>This identity is exact: it is just the additivity (linearity) of the Lebesgue/Riemann integral over a partition. No approximation has been made yet. Approximations enter only when we later replace each window integral by a quadrature rule: a finite set of nodes and positive weights prescribing an integral approximation. This sets the table for three important ingredients that we will use throughout the chapter.</p>
<p>First, it turns a global object into <strong>local contributions</strong> that live on each <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>. Numerical integration is most effective when it is composite: we approximate each small interval integral and then sum the results. Doing so controls error uniformly, because the global quadrature error is the accumulation of local errors that shrink with the step size. It also allows non-uniform steps <span class="math notranslate nohighlight">\(h_k=t_{k+1}-t_k\)</span>, which we will use later for mesh refinement.</p>
<p>Second, the split aligns the cost with the <strong>local dynamics constraints</strong>. On each interval the ODE can be written, by the fundamental theorem of calculus, as</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt.
\]</div>
<p>When we approximate this integral, we introduce interior evaluation points <span class="math notranslate nohighlight">\(t_k^{(i)}\in[t_k,t_{k+1}]\)</span>. Using the <strong>same points</strong> in the cost and in the dynamics ties <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> together coherently: the places where we “pay” for running cost are also the places where we enforce the ODE. This avoids a mismatch between where we approximate the objective and where we impose feasibility.</p>
<p>Third, the decomposition yields a nonlinear program with <strong>sparse structure</strong>. Each interval contributes a small block to the objective and constraints that depends only on variables from that interval (and its endpoints). Modern solvers exploit this banded sparsity to scale to long horizons.</p>
<p>With the split justified, we standardize the approximation. Map each interval to a reference domain via <span class="math notranslate nohighlight">\(t=t_k+h_k\tau\)</span> with <span class="math notranslate nohighlight">\(\tau\in[0,1]\)</span> and <span class="math notranslate nohighlight">\(dt=h_k\,d\tau\)</span>. A <strong>quadrature rule on <span class="math notranslate nohighlight">\([0,1]\)</span></strong> is specified by evaluation points <span class="math notranslate nohighlight">\(\{\xi_i\}_{i=1}^q \subset [0,1]\)</span> and positive weights <span class="math notranslate nohighlight">\(\{w_i\}_{i=1}^q\)</span> such that, for a smooth <span class="math notranslate nohighlight">\(\phi\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\int_0^1 \phi(\tau)\,d\tau \;\approx\; \sum_{i=1}^q w_i\,\phi(\xi_i).
\]</div>
<p>Applying it on each interval gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
h_k\sum_{i=1}^q w_i\, c\!\big(\mathbf{x}(t_k+h_k\xi_i),\,\mathbf{u}(t_k+h_k\xi_i)\big).
\]</div>
<p>Summing these window contributions gives a composite approximation of the integral over <span class="math notranslate nohighlight">\([t_0,t_f]\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\int_{t_0}^{t_f} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\;
\sum_{k=0}^{N-1} h_k \sum_{i=1}^q w_i\, c\!\big(\mathbf{x}(t_k^{(i)}),\mathbf{u}(t_k^{(i)})\big).
\]</div>
<p>The outer index <span class="math notranslate nohighlight">\(k\)</span> indicates the window; the inner index <span class="math notranslate nohighlight">\(i\)</span> indicates the samples within that window; the factor <span class="math notranslate nohighlight">\(h_k\)</span> appears from the change of variables.</p>
<p>The dynamics admit the same treatment. By the fundamental theorem of calculus,</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}(t_{k+1})-\mathbf{x}(t_k)
=\int_{t_k}^{t_{k+1}} \dot{\mathbf{x}}(t)\,dt
=\int_{t_k}^{t_{k+1}} \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t))\,dt .
\]</div>
<p>Replacing this integral by a quadrature rule that uses the <strong>same</strong> nodes produces the window defect relation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}-\mathbf{x}_k
\;\approx\;
h_k\sum_{i=1}^q b_i\, \mathbf{f}\!\big(\mathbf{x}(t_k^{(i)}),\mathbf{u}(t_k^{(i)})\big),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\{b_i\}\)</span> are the weights used for the ODE. Path constraints <span class="math notranslate nohighlight">\(\mathbf{g}(\mathbf{x}(t),\mathbf{u}(t))\le 0\)</span> are imposed at selected nodes <span class="math notranslate nohighlight">\(t_k^{(i)}\)</span> in the same spirit. Using the same evaluation points for cost and dynamics keeps the representation coherent: we “pay” running cost and “account” for state changes at the same times.</p>
<section id="how-do-values-at-interior-points-arise-step-functions-vs-interpolating-functions">
<h3>How do values at interior points arise? (step functions vs interpolating functions)<a class="headerlink" href="#how-do-values-at-interior-points-arise-step-functions-vs-interpolating-functions" title="Link to this heading">#</a></h3>
<p>Once we select a mesh <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> and interior fractions <span class="math notranslate nohighlight">\(\{\xi_i\}_{i=1}^q\)</span> per window <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>, we need <span class="math notranslate nohighlight">\(\mathbf{x}(t_k^{(i)})\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t_k^{(i)})\)</span> at the evaluation times <span class="math notranslate nohighlight">\(t_k^{(i)} := t_k + h_k\xi_i\)</span>. These values do not preexist. They come from one of two constructions that align with the standard quadrature taxonomy: <strong>step-function based</strong> and <strong>interpolating-function based</strong> rules.</p>
<section id="step-function-based-construction-piecewise-constants-rectangle-or-midpoint">
<h4>Step-function based construction (piecewise constants; rectangle or midpoint)<a class="headerlink" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint" title="Link to this heading">#</a></h4>
<p>Here we approximate the relevant time functions by step functions on each window. For controls, a common choice is piecewise-constant:</p>
<div class="math notranslate nohighlight">
\[
\mathbf{u}(t)=\mathbf{u}_k\quad\text{for }t\in[t_k,t_{k+1}].
\]</div>
<p>For the running cost and the vector field, the corresponding quadrature is a rectangle rule on <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span>. Using the left endpoint gives</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c(\mathbf{x}(t),\mathbf{u}(t))\,dt
\;\approx\; h_k\,c(\mathbf{x}_k,\mathbf{u}_k),
\]</div>
<p>and replacing the dynamics integral by the same step-function idea yields the forward Euler relation</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}=\mathbf{x}_k+h_k\,\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k,t_k).
\]</div>
<p>If we prefer the midpoint rectangle rule, we sample at <span class="math notranslate nohighlight">\(t_{k+\frac12}=t_k+\tfrac{h_k}{2}\)</span>. In practice we then generate <span class="math notranslate nohighlight">\(\mathbf{x}_{k+\frac12}\)</span> by a half-step of the chosen integrator, and set <span class="math notranslate nohighlight">\(\mathbf{u}_{k+\frac12}=\mathbf{u}_k\)</span> (piecewise-constant) or an average if we allow a short linear segment. Either way, interior values come from <strong>integrating forward</strong> given a step-function model for <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> and a rectangle-rule view of the integrals. This is the shooting viewpoint. Single shooting keeps only control parameters as decision variables; multiple shooting adds the window-start states and enforces step consistency.</p>
</section>
<section id="interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">
<h4>Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)<a class="headerlink" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto" title="Link to this heading">#</a></h4>
<p>Here we approximate time functions by <strong>polynomials</strong> on each window. If we interpolate <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> linearly between endpoints, the cost naturally uses the trapezoidal rule</p>
<div class="math notranslate nohighlight">
\[
\int_{t_k}^{t_{k+1}} c\,dt\;\approx\;\tfrac{h_k}{2}\big[c(\mathbf{x}_k,\mathbf{u}_k)+c(\mathbf{x}_{k+1},\mathbf{u}_{k+1})\big],
\]</div>
<p>and the dynamics use the matched trapezoidal defect</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_{k+1}=\mathbf{x}_k+\tfrac{h_k}{2}\Big[\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k,t_k)+\mathbf{f}(\mathbf{x}_{k+1},\mathbf{u}_{k+1},t_{k+1})\Big].
\]</div>
<p>With a quadratic interpolation that includes the midpoint, Simpson’s rule appears in the cost and the Hermite–Simpson relations tie <span class="math notranslate nohighlight">\(\mathbf{x}_{k+\frac12}\)</span> to endpoint values and slopes. More generally, <strong>collocation</strong> chooses interior nodes on <span class="math notranslate nohighlight">\([t_k,t_{k+1}]\)</span> (equally spaced gives Newton–Cotes like trapezoid or Simpson; Gaussian points give Gauss, Radau, or Lobatto schemes) and enforces the ODE at those nodes:</p>
<div class="math notranslate nohighlight">
\[
\frac{d}{dt}\mathbf{x}(t_k^{(i)})=\mathbf{f}\!\big(\mathbf{x}(t_k^{(i)}),\mathbf{u}(t_k^{(i)}),t_k^{(i)}\big),
\]</div>
<p>with continuity at endpoints. The interior values <span class="math notranslate nohighlight">\(\mathbf{x}(t_k^{(i)})\)</span> are <strong>evaluations of the decision polynomials</strong>; <span class="math notranslate nohighlight">\(\mathbf{u}(t_k^{(i)})\)</span> follows from the chosen control interpolation (constant, linear, or quadratic). The running cost is evaluated by the same interpolatory quadrature at the same nodes, which keeps “where we pay” aligned with “where we enforce.”</p>
</section>
</section>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="the-interpolation-problem-functions-from-constraints">
<h1>The Interpolation Problem: Functions from Constraints<a class="headerlink" href="#the-interpolation-problem-functions-from-constraints" title="Link to this heading">#</a></h1>
<p>We often want to construct a function that passes through a given set of points. For example, suppose we know a function should satisfy:</p>
<div class="math notranslate nohighlight">
\[
f(x_0) = y_0, \quad f(x_1) = y_1, \quad \dots, \quad f(x_m) = y_m.
\]</div>
<p>These are called <strong>interpolation constraints</strong>. Our goal is to find a function <span class="math notranslate nohighlight">\(f(x)\)</span> that satisfies all of them exactly.</p>
<p>To make the problem tractable, we restrict ourselves to a class of functions. In polynomial interpolation, we assume that <span class="math notranslate nohighlight">\(f(x)\)</span> is a polynomial of degree at most <span class="math notranslate nohighlight">\(N\)</span>. That means we are trying to find coefficients <span class="math notranslate nohighlight">\(c_0, \dots, c_N\)</span> such that</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \, \phi_n(x),
\]</div>
<p>where the functions <span class="math notranslate nohighlight">\(\phi_n(x)\)</span> form a basis for the space of polynomials. The most common choice is the <strong>monomial basis</strong>, where <span class="math notranslate nohighlight">\(\phi_n(x) = x^n\)</span>. This gives:</p>
<div class="math notranslate nohighlight">
\[
f(x) = c_0 + c_1 x + c_2 x^2 + \dots + c_N x^N.
\]</div>
<p>Other valid bases include Legendre, Chebyshev, and Lagrange polynomials, each chosen for specific numerical properties. But all span the same function space.</p>
<section id="how-many-coefficients-do-we-need">
<h2>How Many Coefficients Do We Need?<a class="headerlink" href="#how-many-coefficients-do-we-need" title="Link to this heading">#</a></h2>
<p>Each constraint adds one equation to the system. To find a unique solution, we need the number of unknowns (the <span class="math notranslate nohighlight">\(c_n\)</span>) to match the number of constraints. Since a degree-<span class="math notranslate nohighlight">\(N\)</span> polynomial has <span class="math notranslate nohighlight">\(N+1\)</span> coefficients, we need:</p>
<div class="math notranslate nohighlight">
\[
N + 1 = m + 1 \quad \Rightarrow \quad N = m.
\]</div>
<p>So if we want a function that passes through 4 points, we need a cubic polynomial (<span class="math notranslate nohighlight">\(N = 3\)</span>). Choosing a higher degree than necessary would give us infinitely many solutions; a lower degree may make the problem unsolvable.</p>
</section>
<section id="solving-for-the-coefficients-monomial-basis">
<h2>Solving for the Coefficients (Monomial Basis)<a class="headerlink" href="#solving-for-the-coefficients-monomial-basis" title="Link to this heading">#</a></h2>
<p>If we fix the basis functions to be monomials, we can build a system of equations by plugging in each <span class="math notranslate nohighlight">\(x_i\)</span> into <span class="math notranslate nohighlight">\(f(x)\)</span>. This gives:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
f(x_0) &amp;= c_0 + c_1 x_0 + c_2 x_0^2 + \dots + c_N x_0^N = y_0 \\
f(x_1) &amp;= c_0 + c_1 x_1 + c_2 x_1^2 + \dots + c_N x_1^N = y_1 \\
&amp;\vdots \\
f(x_m) &amp;= c_0 + c_1 x_m + c_2 x_m^2 + \dots + c_N x_m^N = y_m
\end{aligned}
\end{split}\]</div>
<p>This system can be written in matrix form as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
1 &amp; x_0 &amp; x_0^2 &amp; \cdots &amp; x_0^N \\
1 &amp; x_1 &amp; x_1^2 &amp; \cdots &amp; x_1^N \\
\vdots &amp; \vdots &amp; \vdots &amp; &amp; \vdots \\
1 &amp; x_m &amp; x_m^2 &amp; \cdots &amp; x_m^N
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ y_1 \\ \vdots \\ y_m
\end{bmatrix}
\end{split}\]</div>
<p>The matrix on the left is called the <strong>Vandermonde matrix</strong>. Solving this system gives the coefficients <span class="math notranslate nohighlight">\(c_n\)</span> that define the interpolating polynomial.</p>
</section>
<section id="using-a-different-basis">
<h2>Using a Different Basis<a class="headerlink" href="#using-a-different-basis" title="Link to this heading">#</a></h2>
<p>We don’t have to use monomials. We can pick any set of basis functions <span class="math notranslate nohighlight">\(\phi_n(x)\)</span>, such as Chebyshev or Fourier modes, and follow the same steps. The interpolating function becomes:</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \, \phi_n(x),
\]</div>
<p>and each interpolation constraint becomes:</p>
<div class="math notranslate nohighlight">
\[
f(x_i) = \sum_{n=0}^N c_n \, \phi_n(x_i) = y_i.
\]</div>
<p>Assembling these into a system gives:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\phi_0(x_0) &amp; \phi_1(x_0) &amp; \dots &amp; \phi_N(x_0) \\
\phi_0(x_1) &amp; \phi_1(x_1) &amp; \dots &amp; \phi_N(x_1) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0(x_m) &amp; \phi_1(x_m) &amp; \dots &amp; \phi_N(x_m)
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ y_1 \\ \vdots \\ y_m
\end{bmatrix}
\end{split}\]</div>
<p>From here, we solve as before and reconstruct <span class="math notranslate nohighlight">\(f(x)\)</span>.</p>
</section>
<section id="derivative-constraints">
<h2>Derivative Constraints<a class="headerlink" href="#derivative-constraints" title="Link to this heading">#</a></h2>
<p>Sometimes, instead of a value constraint <span class="math notranslate nohighlight">\(f(x_i) = y_i\)</span>, we want to impose a slope constraint <span class="math notranslate nohighlight">\(f'(x_i) = s_i\)</span>. This is common in applications like spline interpolation or collocation methods, where derivative information is available from an ODE.</p>
<p>Since</p>
<div class="math notranslate nohighlight">
\[
f(x) = \sum_{n=0}^N c_n \phi_n(x) \quad \Rightarrow \quad f'(x) = \sum_{n=0}^N c_n \phi_n'(x),
\]</div>
<p>we can directly write the slope constraint:</p>
<div class="math notranslate nohighlight">
\[
f'(x_i) = \sum_{n=0}^N c_n \phi_n'(x_i) = s_i.
\]</div>
<p>To enforce this, we replace one of the interpolation equations in our system with this slope constraint. The resulting system still has <span class="math notranslate nohighlight">\(m+1\)</span> equations and <span class="math notranslate nohighlight">\(N+1 = m+1\)</span> unknowns.</p>
<p>Concretely, suppose we have <span class="math notranslate nohighlight">\(k+1\)</span> value constraints at nodes <span class="math notranslate nohighlight">\(X=\{x_0,\ldots,x_k\}\)</span> with values <span class="math notranslate nohighlight">\(Y=\{y_0,\ldots,y_k\}\)</span> and <span class="math notranslate nohighlight">\(r\)</span> slope constraints at nodes <span class="math notranslate nohighlight">\(Z=\{z_1,\ldots,z_r\}\)</span> with slopes <span class="math notranslate nohighlight">\(S=\{s_1,\ldots,s_r\}\)</span>, with <span class="math notranslate nohighlight">\(k+1+r=N+1\)</span>. The linear system for the coefficients <span class="math notranslate nohighlight">\(\mathbf{c}=[c_0,\ldots,c_N]^\top\)</span> is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{bmatrix}
\phi_0(x_0) &amp; \phi_1(x_0) &amp; \cdots &amp; \phi_N(x_0) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0(x_k) &amp; \phi_1(x_k) &amp; \cdots &amp; \phi_N(x_k) \\
\phi_0'(z_1) &amp; \phi_1'(z_1) &amp; \cdots &amp; \phi_N'(z_1) \\
\vdots &amp; \vdots &amp; &amp; \vdots \\
\phi_0'(z_r) &amp; \phi_1'(z_r) &amp; \cdots &amp; \phi_N'(z_r)
\end{bmatrix}
\begin{bmatrix}
c_0 \\ c_1 \\ \vdots \\ c_N
\end{bmatrix}
=
\begin{bmatrix}
y_0 \\ \vdots \\ y_k \\ s_1 \\ \vdots \\ s_r
\end{bmatrix}.
\end{split}\]</div>
<p>If a value and a slope are imposed at the same node, take <span class="math notranslate nohighlight">\(z_j=x_i\)</span> and include both the value row and the derivative row; the system remains square. In the monomial basis, the top block is the Vandermonde matrix and the derivative block has entries <span class="math notranslate nohighlight">\(n\,x^{\,n-1}\)</span>. Once solved for <span class="math notranslate nohighlight">\(\mathbf{c}\)</span>, reconstruct</p>
<div class="math notranslate nohighlight">
\[
f(x)=\sum_{n=0}^N c_n\,\phi_n(x).
\]</div>
</section>
<section id="interpolating-ode-trajectories-collocation">
<h2>Interpolating ODE trajectories (collocation)<a class="headerlink" href="#interpolating-ode-trajectories-collocation" title="Link to this heading">#</a></h2>
<p>We now specialize the interpolation viewpoint to trajectories governed by an ODE</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}(t) = \mathbf{f}(\mathbf{x}(t),\mathbf{u}(t),t).
\]</div>
<p>On each mesh interval <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>, choose collocation nodes <span class="math notranslate nohighlight">\(\{\xi_j\}_{j=0}^s\subset[0,1]\)</span> and map <span class="math notranslate nohighlight">\(t=t_i+h_i\,\xi\)</span>. Use the monomial basis <span class="math notranslate nohighlight">\(\phi_n(\xi)=\xi^n\)</span> to approximate the (unknown) trajectory by</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_h(\xi) = \sum_{n=0}^s \mathbf{a}_n\,\xi^n,\quad \mathbf{a}_n\in\mathbb{R}^d.
\]</div>
<p>Differentiating with respect to time (using <span class="math notranslate nohighlight">\(\tfrac{d}{dt}=\tfrac{1}{h_i}\tfrac{d}{d\xi}\)</span>) gives, at the collocation nodes <span class="math notranslate nohighlight">\(\xi_j\)</span>,</p>
<div class="math notranslate nohighlight">
\[
\dot{\mathbf{x}}_h(t_i+h_i\,\xi_j) 
\;=\; \frac{1}{h_i} \sum_{n=1}^s n\,\mathbf{a}_n\,\xi_j^{\,n-1}.
\]</div>
<p>Collocation enforces that these polynomial slopes match the ODE at the same nodes (this is exactly “interpolation with derivative constraints,” where the slopes come from the ODE):</p>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_i} \sum_{n=1}^s n\,\mathbf{a}_n\,\xi_j^{\,n-1}
\;=\; \mathbf{f}\Big( \sum_{n=0}^s \mathbf{a}_n\,\xi_j^{\,n},\ \mathbf{U}_j,\ t_i+h_i\,\xi_j \Big),\quad j=0,\ldots,s.
\]</div>
<p>Endpoint consistency provides linear constraints on the coefficients. If endpoints are included among <span class="math notranslate nohighlight">\(\{\xi_j\}\)</span> (Lobatto-type nodes),</p>
<div class="math notranslate nohighlight">
\[
\mathbf{x}_i = \mathbf{x}_h(0) = \mathbf{a}_0,\qquad
\mathbf{x}_{i+1} = \mathbf{x}_h(1) = \sum_{n=0}^s \mathbf{a}_n.
\]</div>
<p>Controls can be piecewise-constant/linear or also parameterized by a low-degree polynomial <span class="math notranslate nohighlight">\(\mathbf{u}_h(\xi)=\sum_{n=0}^{s_u} \mathbf{b}_n\,\xi^n\)</span> with nodal values <span class="math notranslate nohighlight">\(\mathbf{U}_j=\mathbf{u}_h(\xi_j)\)</span>. The running cost on <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span> is evaluated with the same nodes and quadrature weights <span class="math notranslate nohighlight">\(\{w_j\}\)</span>:</p>
<div class="math notranslate nohighlight">
\[
\int_{t_i}^{t_{i+1}} c\,dt \;\approx\; h_i\sum_{j=0}^s w_j\, c\big(\mathbf{x}_h(\xi_j),\mathbf{u}_h(\xi_j), t_i+h_i\,\xi_j\big).
\]</div>
<p>In words: pick a small set of points inside the interval, write a low-degree polynomial for <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span>, and enforce that its time-derivative equals the ODE at those points. Endpoint equalities give value constraints; the ODE gives slope constraints. Stitch intervals by continuity, and use the same nodes and weights to evaluate the running cost. This is precisely the interpolation-with-derivatives idea, with derivatives supplied by the ODE.</p>
<div class="proof example admonition" id="example-3">
<p class="admonition-title"><span class="caption-number">Example 1 </span> (Two worked collocation examples (solve the local linear system))</p>
<section class="example-content" id="proof-content">
<p>Fix a window <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span> with step <span class="math notranslate nohighlight">\(h_i=t_{i+1}-t_i\)</span> and map it to <span class="math notranslate nohighlight">\(\xi\in[0,1]\)</span> via <span class="math notranslate nohighlight">\(t=t_i+h_i\,\xi\)</span>. Approximate the (unknown) scalar state by a degree-1 polynomial</p>
<div class="math notranslate nohighlight">
\[
x_h(\xi)=a_0+a_1\,\xi,\qquad \dot{x}_h(t)=\frac{1}{h_i}\,a_1.
\]</div>
<p>We will impose a value constraint at the left endpoint <span class="math notranslate nohighlight">\(x_h(0)=x_i\)</span> and one collocation condition <span class="math notranslate nohighlight">\(\dot{x}_h(t_i+h_i\xi_\star)=f\big(x_h(\xi_\star),u(\xi_\star),t_i+h_i\xi_\star\big)\)</span> at a single node <span class="math notranslate nohighlight">\(\xi_\star\)</span>. This produces a tiny linear system for the coefficients <span class="math notranslate nohighlight">\(a_0,a_1\)</span>; evaluating <span class="math notranslate nohighlight">\(x_h(1)\)</span> gives the step update.</p>
<ul class="simple">
<li><p>Forward (explicit) Euler: choose the left-endpoint node <span class="math notranslate nohighlight">\(\xi_\star=0\)</span> and piecewise-constant control <span class="math notranslate nohighlight">\(u(\xi_\star)=u_i\)</span>. The constraints are</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\underbrace{\begin{bmatrix}1 &amp; 0\\ 0 &amp; 1/h_i\end{bmatrix}}_{\text{linear in }(a_0,a_1)}
\begin{bmatrix}a_0\\ a_1\end{bmatrix}
=
\begin{bmatrix}x_i\\ f(x_i,u_i,t_i)\end{bmatrix}.
\end{split}\]</div>
<p>Hence <span class="math notranslate nohighlight">\(a_0=x_i\)</span> and <span class="math notranslate nohighlight">\(a_1=h_i f(x_i,u_i,t_i)\)</span>, so</p>
<div class="math notranslate nohighlight">
\[
x_{i+1}:=x_h(1)=x_i+h_i f(x_i,u_i,t_i),
\]</div>
<p>which is the forward Euler update recovered as one-point collocation.</p>
<ul class="simple">
<li><p>Backward (implicit) Euler: choose the right-endpoint node <span class="math notranslate nohighlight">\(\xi_\star=1\)</span> and use <span class="math notranslate nohighlight">\(u(\xi_\star)=u_{i+1}\)</span>. Then</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\frac{1}{h_i}a_1=f\big(x_h(1),u_{i+1},t_{i+1}\big)=f(x_{i+1},u_{i+1},t_{i+1}),\qquad a_0=x_i,
\]</div>
<p>so <span class="math notranslate nohighlight">\(x_{i+1}=x_i+h_i f(x_{i+1},u_{i+1},t_{i+1})\)</span>, the backward Euler relation. For the scalar linear ODE <span class="math notranslate nohighlight">\(\dot{x}=\lambda x\)</span> this becomes a 2×2 linear system in <span class="math notranslate nohighlight">\((a_0,a_1)\)</span> that yields the closed form</p>
<div class="math notranslate nohighlight">
\[
x_{i+1}=\frac{1}{1-h_i\lambda}\,x_i.
\]</div>
</section>
</div></section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="applying-the-recipe-concrete-transcriptions">
<h1>Applying the recipe: concrete transcriptions<a class="headerlink" href="#applying-the-recipe-concrete-transcriptions" title="Link to this heading">#</a></h1>
<p>The mesh and interior nodes are the common scaffold. What distinguishes one transcription from another is how we obtain values at those nodes and how we approximate the two integrals that appear implicitly and explicitly: the integral of the running cost and the integral that carries the state forward. In other words, we now commit to two design choices that mirror the previous section: a finite representation for <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> and <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> over each interval <span class="math notranslate nohighlight">\([t_i,t_{i+1}]\)</span>, and a quadrature rule whose nodes and weights are used consistently for both cost and dynamics. The result is always a sparse nonlinear program; the differences are in where we sample and how we tie samples together.</p>
<p>Below, each transcription should be read as “same grid, same interior points, same evaluations for cost and physics,” with only the local representation changing.</p>
<p><em>Euler (step functions; rectangle rule).</em>
Here we treat <span class="math notranslate nohighlight">\(\mathbf{u}\)</span> as piecewise constant and evaluate both cost and dynamics at the left endpoint. Interior values are not independent variables; they are whatever the step-function model implies. This is the simplest way to align “what we pay” with “how we advance,” and it reproduces the forward Euler update inside the NLP.</p>
<div class="proof definition admonition" id="definition-4">
<p class="admonition-title"><span class="caption-number">Definition 4 </span> (Euler Transcription (Discrete Bolza NLP))</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^{N-1}\)</span>. Given running cost <span class="math notranslate nohighlight">\(c\)</span>, terminal cost <span class="math notranslate nohighlight">\(c_T\)</span>, dynamics <span class="math notranslate nohighlight">\(\mathbf{f}\)</span>, and path constraint <span class="math notranslate nohighlight">\(\mathbf{g}\le \mathbf{0}\)</span>, solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{\mathbf{x}_i,\mathbf{u}_i\}}\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} h_i\, c(\mathbf{x}_i,\mathbf{u}_i)\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - h_i\,\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i) = \mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0).
\end{aligned}
\end{split}\]</div>
</section>
</div><p><em>Trapezoidal collocation (linear interpolation; end nodes).</em>
Now we let <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> vary linearly over the interval and evaluate both cost and dynamics at the two endpoints with equal weights. This matches the trapezoid rule in the objective and the trapezoidal defect in the dynamics, so cost accumulation and state accounting occur at the same two places.</p>
<div class="proof definition admonition" id="definition-5">
<p class="admonition-title"><span class="caption-number">Definition 5 </span> (Trapezoidal Collocation)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>. Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\{\mathbf{x}_i,\mathbf{u}_i\}}\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} \tfrac{h_i}{2}\,\Big[c(\mathbf{x}_i,\mathbf{u}_i)+c(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big]\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - \tfrac{h_i}{2}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i)+\mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big] = \mathbf{0},\quad i=0,\ldots,N-1,\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \le \mathbf{0},\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0).
\end{aligned}
\end{split}\]</div>
</section>
</div><p><em>Hermite–Simpson (quadratic interpolation; midpoint included).</em><br />
Adding a midpoint enriches the local model from linear to quadratic. Practically, this buys two things at once: (i) higher accuracy at low cost—Hermite–Simpson delivers fourth‑order state accuracy with a single interior node, so fewer intervals are needed for a given error; and (ii) tight alignment between physics and objective—Simpson’s rule in the cost and the Hermite–Simpson defect in the dynamics use the same three evaluation sites (left, middle, right). Introducing midpoint variables makes the interior state explicit so the ODE can be matched there, which reduces collocation defects and typically improves conditioning compared to trapezoid on smooth problems. In short, we evaluate and enforce at the same places we pay, and the extra node yields a noticeable accuracy boost without a large increase in variables.</p>
<div class="proof definition admonition" id="definition-6">
<p class="admonition-title"><span class="caption-number">Definition 6 </span> (Hermite–Simpson Transcription)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span> and midpoints <span class="math notranslate nohighlight">\(t_{i+\frac12}\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>, plus midpoint variables <span class="math notranslate nohighlight">\(\{\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}\}_{i=0}^{N-1}\)</span>. Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} \tfrac{h_i}{6}\Big[ c(\mathbf{x}_i,\mathbf{u}_i) + 4\,c(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) + c(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \Big]\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - \tfrac{h_i}{6}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i) + 4\,\mathbf{f}(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) + \mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big] = \mathbf{0},\\
&amp; \mathbf{x}_{i+\frac12} - \tfrac{\mathbf{x}_i+\mathbf{x}_{i+1}}{2} - \tfrac{h_i}{8}\Big[\mathbf{f}(\mathbf{x}_i,\mathbf{u}_i) - \mathbf{f}(\mathbf{x}_{i+1},\mathbf{u}_{i+1})\Big] = \mathbf{0},\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+\frac12},\mathbf{u}_{i+\frac12}) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \le \mathbf{0},\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i,\mathbf{x}_{i+\frac12} \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i,\mathbf{u}_{i+\frac12} \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0),\quad i=0,\ldots,N-1.
\end{aligned}
\end{split}\]</div>
</section>
</div><p><em>RK4 transcription (integrator stages as algebraic variables).</em>
Runge–Kutta methods approximate the interval integral by evaluating the vector field at a set of staged points and combining them with fixed weights. Introducing the stages as variables brings the usual RK4 update inside the NLP, and again the evaluation sites used to advance the state are the same places where we evaluate the running cost.</p>
<div class="proof definition admonition" id="definition-7">
<p class="admonition-title"><span class="caption-number">Definition 7 </span> (RK4 Transcription)</p>
<section class="definition-content" id="proof-content">
<p>Let <span class="math notranslate nohighlight">\(t_0&lt;\cdots&lt;t_N\)</span> with <span class="math notranslate nohighlight">\(h_i:=t_{i+1}-t_i\)</span>. Decision variables are <span class="math notranslate nohighlight">\(\{\mathbf{x}_i\}_{i=0}^N\)</span>, <span class="math notranslate nohighlight">\(\{\mathbf{u}_i\}_{i=0}^N\)</span>, and stage vectors <span class="math notranslate nohighlight">\(\{\mathbf{s}^{(1)}_i,\mathbf{s}^{(2)}_i,\mathbf{s}^{(3)}_i,\mathbf{s}^{(4)}_i\}_{i=0}^{N-1}\)</span> and midpoint controls <span class="math notranslate nohighlight">\(\{\bar{\mathbf{u}}_i\}\)</span>. Define the RK stages</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\mathbf{s}^{(1)}_i &amp;= \mathbf{f}(\mathbf{x}_i,\mathbf{u}_i),\\
\mathbf{s}^{(2)}_i &amp;= \mathbf{f}\!\big(\mathbf{x}_i + \tfrac{h_i}{2}\,\mathbf{s}^{(1)}_i,\ \bar{\mathbf{u}}_i\big),\\
\mathbf{s}^{(3)}_i &amp;= \mathbf{f}\!\big(\mathbf{x}_i + \tfrac{h_i}{2}\,\mathbf{s}^{(2)}_i,\ \bar{\mathbf{u}}_i\big),\\
\mathbf{s}^{(4)}_i &amp;= \mathbf{f}\!\big(\mathbf{x}_i + h_i\,\mathbf{s}^{(3)}_i,\ \mathbf{u}_{i+1}\big).
\end{aligned}
\end{split}\]</div>
<p>Solve</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min\ &amp; c_T(\mathbf{x}_N)\; +\; \sum_{i=0}^{N-1} \tfrac{h_i}{6}\Big[ c(\mathbf{x}_i,\mathbf{u}_i) + 4\,c\!\big(\mathbf{x}_i + \tfrac{h_i}{2}\,\mathbf{s}^{(2)}_i,\ \bar{\mathbf{u}}_i\big) + c(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \Big]\\
\text{s.t.}\ &amp; \mathbf{x}_{i+1}-\mathbf{x}_i - \tfrac{h_i}{6}\Big[\mathbf{s}^{(1)}_i + 2\mathbf{s}^{(2)}_i + 2\mathbf{s}^{(3)}_i + \mathbf{s}^{(4)}_i\Big] = \mathbf{0},\\
&amp; \mathbf{g}(\mathbf{x}_i,\mathbf{u}_i) \le \mathbf{0},\ \ \mathbf{g}(\mathbf{x}_{i+1},\mathbf{u}_{i+1}) \le \mathbf{0},\ \ \mathbf{g}\!\big(\mathbf{x}_i + \tfrac{h_i}{2}\,\mathbf{s}^{(2)}_i,\ \bar{\mathbf{u}}_i\big) \le \mathbf{0},\\
&amp; \mathbf{x}_{\min} \le \mathbf{x}_i \le \mathbf{x}_{\max},\ \ \mathbf{u}_{\min} \le \mathbf{u}_i,\bar{\mathbf{u}}_i \le \mathbf{u}_{\max},\\
&amp; \mathbf{x}_0 = \mathbf{x}(t_0),\quad i=0,\ldots,N-1.
\end{aligned}
\end{split}\]</div>
</section>
</div><section id="choosing-among-them">
<h2>Choosing among them<a class="headerlink" href="#choosing-among-them" title="Link to this heading">#</a></h2>
<p>All four transcriptions follow the same organizing idea from earlier: pick evaluation points, translate both integrals into weighted sums at those points, and couple those evaluations to a finite trajectory representation. Euler uses step functions and a single point per interval. Trapezoid and Hermite–Simpson use low-degree polynomials and endpoint or midpoint nodes, which brings collocation into play. RK4 uses staged vector-field samples in place of an explicit interpolant. In every case the mesh can be nonuniform and refined locally, and the resulting NLP keeps a banded sparsity that solvers exploit.</p>
</section>
<section id="a-brief-note-on-reconstruction">
<h2>A brief note on reconstruction<a class="headerlink" href="#a-brief-note-on-reconstruction" title="Link to this heading">#</a></h2>
<p>Once the finite problem is solved, the discrete solution <span class="math notranslate nohighlight">\(\{\mathbf{x}_i,\mathbf{u}_i\}\)</span> and any interior values determine a continuous-time approximation on each interval. Linear reconstruction matches Euler and trapezoid; cubic Hermite for <span class="math notranslate nohighlight">\(\mathbf{x}(t)\)</span> with quadratic <span class="math notranslate nohighlight">\(\mathbf{u}(t)\)</span> matches Hermite–Simpson; for RK4, piecewise-constant or piecewise-linear controls on the half-steps are consistent with the staged evaluations. The reconstruction should mirror the choice made in the transcription so that what is plotted reflects what was optimized.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="example-compressor-surge-problem">
<h1>Example: Compressor Surge Problem<a class="headerlink" href="#example-compressor-surge-problem" title="Link to this heading">#</a></h1>
<p>Compressors are mechanical devices used to increase the pressure of a gas by reducing its volume. They are found in many industrial settings, from natural gas pipelines to jet engines. However, compressors can suffer from a dangerous phenomenon called “surge” when the gas flow through the compressor falls too much below its design capacity. This can happen under different circumstances such as:</p>
<ul class="simple">
<li><p>In a natural gas pipeline system, when there is less customer demand (e.g., during warm weather when less heating is needed) the flow through the compressor lowers.</p></li>
<li><p>In a jet engine, when the pilot reduces thrust during landing, less air flows through the engine’s compressors.</p></li>
<li><p>In factory, the compressor might be connected through some equipment downstream via a valve. Closing it partially restricts gas flow, similar to pinching a garden hose, and can lead to compressor surge.</p></li>
</ul>
<p>As the gas flow decreases, the compressor must work harder to maintain a steady flow. If the flow becomes too low, it can lead to a “breakdown”: a phenomenon similar to an airplane stalling at low speeds or high angles of attack. In a compressor, when this breakdown occurs the gas briefly flows backward instead of moving forward, which in turn can cause violent oscillations in pressure that can damage the compressor and the equipment depending on it. One way to address this problem is by installing a close-coupled valve (CCV), which is a device connected at the output of the compressor to quickly modulate the flow. Our aim is not to devise an optimal control approach to ensure that the compressor does not experience a surge by operating this CCV appropriately.</p>
<p>Following  <span id="id1">[<a class="reference internal" href="bibliography.html#id16" title="J.T. Gravdahl and O. Egeland. Compressor surge control using a close-coupled valve and backstepping. In Proceedings of the 1997 American Control Conference (Cat. No.97CH36041), 982–986 vol.2. IEEE, 1997. URL: http://dx.doi.org/10.1109/ACC.1997.609673, doi:10.1109/acc.1997.609673.">20</a>]</span> and <span id="id2">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span>, we model the compressor using a simplified second-order representation:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\dot{x}_1 &amp;= B(\Psi_e(x_1) - x_2 - u) \\
\dot{x}_2 &amp;= \frac{1}{B}(x_1 - \Phi(x_2))
\end{aligned}
\end{split}\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\mathbf{x} = [x_1, x_2]^T\)</span> represents the state variables:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x_1\)</span> is the normalized mass flow through the compressor.</p></li>
<li><p><span class="math notranslate nohighlight">\(x_2\)</span> is the normalized pressure ratio across the compressor.</p></li>
</ul>
<p>The control input <span class="math notranslate nohighlight">\(u\)</span> denotes the normalized mass flow through a CCV.
The functions <span class="math notranslate nohighlight">\(\Psi_e(x_1)\)</span> and <span class="math notranslate nohighlight">\(\Phi(x_2)\)</span> represent the characteristics of the compressor and valve, respectively:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\Psi_e(x_1) &amp;= \psi_{c0} + H\left(1 + 1.5\left(\frac{x_1}{W} - 1\right) - 0.5\left(\frac{x_1}{W} - 1\right)^3\right) \\
\Phi(x_2) &amp;= \gamma \operatorname{sign}(x_2) \sqrt{|x_2|}
\end{aligned}
\end{split}\]</div>
<p>The system parameters are given as <span class="math notranslate nohighlight">\(\gamma = 0.5\)</span>, <span class="math notranslate nohighlight">\(B = 1\)</span>, <span class="math notranslate nohighlight">\(H = 0.18\)</span>, <span class="math notranslate nohighlight">\(\psi_{c0} = 0.3\)</span>, and <span class="math notranslate nohighlight">\(W = 0.25\)</span>.</p>
<p>One possible way to pose the problem <span id="id3">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span> is by penalizing deviations from the setpoints using a quadratic penalty in the instantaneous cost function as well as in the terminal one. Furthermore, we also penalize taking large actions (which are energy hungry and potentially unsafe) within the integral term. The idea of penalizing deviations throughout is a natural way of posing the problem when solving it via single shooting. Another alternative, which we will explore below, is to set the desired setpoint as a hard terminal constraint.</p>
<p>The control objective is to stabilize the system and prevent surge, formulated as a continuous-time optimal control problem (COCP) in the Bolza form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; \left[ \int_0^T \alpha(\mathbf{x}(t) - \mathbf{x}^*)^T(\mathbf{x}(t) - \mathbf{x}^*) + \kappa u(t)^2 \, dt\right] + \beta(\mathbf{x}(T) - \mathbf{x}^*)^T(\mathbf{x}(T) - \mathbf{x}^*) + R v^2  \\
\text{subject to} \quad &amp; \dot{x}_1(t) = B(\Psi_e(x_1(t)) - x_2(t) - u(t)) \\
&amp; \dot{x}_2(t) = \frac{1}{B}(x_1(t) - \Phi(x_2(t))) \\
&amp; u_{\text{min}} \leq u(t) \leq u_{\text{max}} \\
&amp; -x_2(t) + 0.4 \leq v \\
&amp; -v \leq 0 \\
&amp; \mathbf{x}(0) = \mathbf{x}_0
\end{aligned}
\end{split}\]</div>
<p>The parameters <span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span>, <span class="math notranslate nohighlight">\(\kappa\)</span>, and <span class="math notranslate nohighlight">\(R\)</span> are non-negative weights that allow the designer to prioritize different aspects of performance (e.g., tight setpoint tracking vs. smooth control actions). We also constraint the control input to be within <span class="math notranslate nohighlight">\(0 \leq u(t) \leq 0.3\)</span> due to the physical limitations of the valve.</p>
<p>The authors in <span id="id4">[<a class="reference internal" href="bibliography.html#id17" title="Alexandra Ivanova Grancharova and Tor Arne Johansen. Explicit nonlinear model predictive control. Lecture notes in control and information sciences. Springer, Berlin, Germany, 2012 edition, March 2012.">19</a>]</span> also add a soft path constraint <span class="math notranslate nohighlight">\(x_2(t) \geq 0.4\)</span> to ensure that we maintain a minimum pressure at all time. This is implemented as a soft constraint using slack variables. The reason that we have the term <span class="math notranslate nohighlight">\(R v^2\)</span> in the objective is to penalizes violations of the soft constraint: we allow for deviations, but don’t want to do it too much.</p>
<p>In the experiment below, we choose the setpoint <span class="math notranslate nohighlight">\(\mathbf{x}^* = [0.40, 0.60]^T\)</span> as it corresponds to an unstable equilibrium point. If we were to run the system without applying any control, we would see that the system starts to oscillate.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="n">alpha</span><span class="p">,</span> <span class="n">beta</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.08</span><span class="p">,</span> <span class="mi">0</span>
<span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">60</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="n">N</span>
<span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span> <span class="o">=</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.60</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">instantenous_cost</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">terminal_cost</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
        <span class="n">obj</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">instantenous_cost</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">cons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.4</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">+=</span> <span class="n">terminal_cost</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">R</span> <span class="o">*</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_init</span><span class="p">):</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">z0</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">u_init</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="n">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">z0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;ineq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">z</span><span class="p">:</span> <span class="o">-</span><span class="n">objective_and_constraints</span><span class="p">(</span><span class="n">z</span><span class="p">)[</span><span class="mi">1</span><span class="p">]},</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">result</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">euler_step</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dt</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="c1"># Run optimizations and simulations</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">])</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Optimized control starting from zero</span>
<span class="n">z_single_shooting</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
<span class="n">u_opt_shoot</span><span class="p">,</span> <span class="n">v_opt_shoot</span> <span class="o">=</span> <span class="n">z_single_shooting</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">z_single_shooting</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">x_opt_shoot</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_opt_shoot</span><span class="p">)</span>

<span class="c1"># Do-nothing control (u = 0)</span>
<span class="n">u_nothing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="n">x_nothing</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">u_nothing</span><span class="p">)</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (opt from 0)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (opt from 0)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (do-nothing)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (do-nothing)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x2_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_shoot</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimized from 0&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_nothing</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Do-nothing&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control inputs</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_opt_shoot</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Optimized from 0&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u_nothing</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Do-nothing&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.17449650787602988
            Iterations: 37
            Function evaluations: 2306
            Gradient evaluations: 37
</pre></div>
</div>
<img alt="_images/eb0ffa1d50977921de230aec061a1ac4b423b6e36dda6b69679531f6ff581bbf.png" src="_images/eb0ffa1d50977921de230aec061a1ac4b423b6e36dda6b69679531f6ff581bbf.png" />
</div>
</div>
<section id="solution-by-trapezoidal-collocation">
<h2>Solution by Trapezoidal Collocation<a class="headerlink" href="#solution-by-trapezoidal-collocation" title="Link to this heading">#</a></h2>
<p>Another way to pose the problem is by imposing a terminal state constraint on the system rather than through a penalty in the integral term. In the following experiment, we use a problem formulation of the form:</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\text{minimize} \quad &amp; \left[ \int_0^T \kappa u(t)^2 \, dt\right] \\
\text{subject to} \quad &amp; \dot{x}_1(t) = B(\Psi_e(x_1(t)) - x_2(t) - u(t)) \\
&amp; \dot{x}_2(t) = \frac{1}{B}(x_1(t) - \Phi(x_2(t))) \\
&amp; u_{\text{min}} \leq u(t) \leq u_{\text{max}} \\
&amp; \mathbf{x}(0) = \mathbf{x}_0 \\
&amp; \mathbf{x}(T) = \mathbf{x}^\star
\end{aligned}
\end{split}\]</div>
<p>We then find a control function <span class="math notranslate nohighlight">\(u(t)\)</span> and state trajectory <span class="math notranslate nohighlight">\(x(t)\)</span> using the trapezoidal collocation method.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="n">kappa</span> <span class="o">=</span> <span class="mf">0.08</span>
<span class="n">T</span><span class="p">,</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">20</span>  <span class="c1"># Number of collocation points</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="n">dt</span> <span class="o">=</span> <span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span> <span class="o">=</span> <span class="mf">0.40</span><span class="p">,</span> <span class="mf">0.60</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>
    
    <span class="c1"># Trapezoidal rule for the cost function</span>
    <span class="n">cost</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">kappa</span> <span class="o">*</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">cost</span>

<span class="k">def</span><span class="w"> </span><span class="nf">constraints</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">z</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>
    
    <span class="n">cons</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Dynamics constraints (trapezoidal rule)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">f_i</span> <span class="o">=</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">f_ip1</span> <span class="o">=</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_i</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_ip1</span><span class="p">)))</span>
    
    <span class="c1"># Terminal constraint</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_star</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_star</span><span class="p">])</span>
    
    <span class="c1"># Initial condition constraint</span>
    <span class="n">cons</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cons</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">):</span>
    <span class="c1"># Initial guess</span>
    <span class="n">x_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="p">[</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>
    <span class="n">u_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">z0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_init</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">u_init</span><span class="p">])</span>
    
    <span class="c1"># Bounds</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">[(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>  <span class="c1"># State variables</span>
    <span class="n">bounds</span> <span class="o">+=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>  <span class="c1"># Control inputs</span>
    
    <span class="c1"># Constraints</span>
    <span class="n">cons</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">constraints</span><span class="p">}</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span>
        <span class="n">objective</span><span class="p">,</span>
        <span class="n">z0</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
        <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
        <span class="n">constraints</span><span class="o">=</span><span class="n">cons</span><span class="p">,</span>
        <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span> <span class="s1">&#39;ftol&#39;</span><span class="p">:</span> <span class="mf">1e-6</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">result</span>

<span class="c1"># Run optimization</span>
<span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="n">z_opt</span><span class="p">,</span> <span class="n">result</span> <span class="o">=</span> <span class="n">solve_trajectory_optimization</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
<span class="n">x_opt_coll</span> <span class="o">=</span> <span class="n">z_opt</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">u_opt_coll</span> <span class="o">=</span> <span class="n">z_opt</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Optimization successful: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">success</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final objective value: </span><span class="si">{</span><span class="n">result</span><span class="o">.</span><span class="n">fun</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Final state: x1 = </span><span class="si">{</span><span class="n">x_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Target state: x1 = </span><span class="si">{</span><span class="n">x1_star</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x2_star</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Create interpolated control function</span>
<span class="n">u_func</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_opt_coll</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">u_opt_coll</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">u_opt_coll</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

<span class="c1"># Solve IVP with the optimized control</span>
<span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">dense_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Generate solution points</span>
<span class="n">t_dense</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
<span class="n">x_ivp</span> <span class="o">=</span> <span class="n">sol</span><span class="o">.</span><span class="n">sol</span><span class="p">(</span><span class="n">t_dense</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (collocation)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (collocation)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 (integrated)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 (integrated)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x1 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">x2_star</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;x2 setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_opt_coll</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;go-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Collocation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_ivp</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Integrated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_star</span><span class="p">,</span> <span class="n">x2_star</span><span class="p">,</span> <span class="s1">&#39;r*&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Setpoint&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control inputs</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">step</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u_opt_coll</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Collocation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_dense</span><span class="p">,</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t_dense</span><span class="p">),</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Interpolated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully    (Exit mode 0)
            Current function value: 0.002354322209548216
            Iterations: 13
            Function evaluations: 794
            Gradient evaluations: 13
Optimization successful: True
Final objective value: 0.002354322209548216
Final state: x1 = 0.4000, x2 = 0.6000
Target state: x1 = 0.4000, x2 = 0.6000
</pre></div>
</div>
<img alt="_images/9a74fc1652f3d21194ae87006d306c1071c1084523b7ec6c04eee27201ac3d2e.png" src="_images/9a74fc1652f3d21194ae87006d306c1071c1084523b7ec6c04eee27201ac3d2e.png" />
</div>
</div>
<p>You can try to vary the number of collocation points in the code and observe how the state trajectory progressively matches the ground truth (the line denoted “integrated solution”). Note that this version of the code also lacks bound constraints on the variable <span class="math notranslate nohighlight">\(x_2\)</span> to ensure a minimum pressure, as we did earlier. Consider this a good exercise to try on your own.</p>
</section>
<section id="system-identification-as-trajectory-optimization-compressor-surge">
<h2>System Identification as Trajectory Optimization (Compressor Surge)<a class="headerlink" href="#system-identification-as-trajectory-optimization-compressor-surge" title="Link to this heading">#</a></h2>
<p>We now turn the compressor surge model into a simple system identification task: estimate unknown parameters (here, the scalar <span class="math notranslate nohighlight">\(B\)</span>) from measured trajectories. This can be viewed as a trajectory optimization problem: choose parameters (and optionally states) to minimize reconstruction error while enforcing the dynamics.</p>
<p>Given time-aligned data <span class="math notranslate nohighlight">\(\{(\mathbf{u}_k,\mathbf{y}_k)\}_{k=0}^{N}\)</span>, model states <span class="math notranslate nohighlight">\(\mathbf{x}_k\in\mathbb{R}^d\)</span>, outputs <span class="math notranslate nohighlight">\(\mathbf{y}_k\approx \mathbf{h}(\mathbf{x}_k;\boldsymbol{\theta})\)</span>, step <span class="math notranslate nohighlight">\(\Delta t\)</span>, and dynamics <span class="math notranslate nohighlight">\(\mathbf{f}(\mathbf{x},\mathbf{u};\boldsymbol{\theta})\)</span>, the simultaneous (full-discretization) viewpoint is</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
\min_{\boldsymbol{\theta},\,\{\mathbf{x}_k\}} \quad &amp; \sum_{k\in K}\;\big\|\mathbf{y}_k - \mathbf{h}(\mathbf{x}_k;\boldsymbol{\theta})\big\|_2^2 \\
\text{s.t.}\quad &amp; \mathbf{x}_{k+1} - \mathbf{x}_k - \Delta t\,\mathbf{f}(\mathbf{x}_k,\mathbf{u}_k;\boldsymbol{\theta}) = \mathbf{0},\quad k=0,\ldots,N-1, \\
&amp; \mathbf{x}_0 \;\text{given},
\end{aligned}
\end{split}\]</div>
<p>while the single-shooting (recursive elimination) variant eliminates the states by simulating forward from <span class="math notranslate nohighlight">\(\mathbf{x}_0\)</span>:</p>
<div class="math notranslate nohighlight">
\[
J(\boldsymbol{\theta}) := \sum_{k\in K}\;\big\|\mathbf{y}_k - \mathbf{h}(\boldsymbol{\phi}_k(\boldsymbol{\theta};\mathbf{x}_0,\mathbf{u}_{0:N-1})\big\|_2^2,\quad \min_{\boldsymbol{\theta}} J(\boldsymbol{\theta}),
\]</div>
<p>where <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_k\)</span> denotes the state reached at step <span class="math notranslate nohighlight">\(k\)</span> by an RK4 rollout under parameter <span class="math notranslate nohighlight">\(\boldsymbol{\theta}\)</span>. In our demo the data grid and rollout grid coincide, so <span class="math notranslate nohighlight">\(\boldsymbol{\phi}_k = \mathbf{x}_k\)</span> and no interpolation is required. We will identify <span class="math notranslate nohighlight">\(B\)</span> by fitting the model to data generated from the ground-truth <span class="math notranslate nohighlight">\(B=1\)</span> system under randomized initial conditions and small input perturbations.</p>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">solve_ivp</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># System parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>

<span class="c1"># Simulation parameters</span>
<span class="n">T</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># Total simulation time</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mf">0.1</span>  <span class="c1"># Time step</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
<span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="c1"># Number of trajectories</span>
<span class="n">num_trajectories</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">]</span>

<span class="c1"># &quot;Do nothing&quot; controller with small random noise</span>
<span class="k">def</span><span class="w"> </span><span class="nf">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Mean 0, standard deviation 0.01</span>

<span class="c1"># Function to simulate a single trajectory</span>
<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">):</span>
    <span class="n">sol</span> <span class="o">=</span> <span class="n">solve_ivp</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u_func</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="n">x0</span><span class="p">,</span> <span class="n">t_eval</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;RK45&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sol</span><span class="o">.</span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="c1"># Generate multiple trajectories</span>
<span class="n">trajectories</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">initial_conditions</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_trajectories</span><span class="p">):</span>
    <span class="c1"># Randomize initial conditions around [0.5, 0.5]</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">initial_conditions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">trajectories</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<span class="c1"># Calculate control inputs (small random noise)</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u_func</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span> <span class="k">for</span> <span class="n">ti</span> <span class="ow">in</span> <span class="n">t</span><span class="p">])</span>

<span class="c1"># Plotting</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="c1"># State variables over time</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;x1 (Traj </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;x2 (Traj </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s1">)&#39;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;State variables over time (Multiple Trajectories)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Phase portrait</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="ow">in</span> <span class="n">trajectories</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase portrait (Multiple Trajectories)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Control input (small random noise)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Control input (u)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Control input over time (Small random noise)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Save the data</span>
<span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="s1">&#39;_static/compressor_surge_data_multi.npz&#39;</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span><span class="n">t</span><span class="p">,</span> <span class="n">trajectories</span><span class="o">=</span><span class="n">trajectories</span><span class="p">,</span> <span class="n">u</span><span class="o">=</span><span class="n">u</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="o">=</span><span class="n">initial_conditions</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Data collection complete. Results saved to &#39;compressor_surge_data_multi.npz&#39;&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Data shape: </span><span class="si">{</span><span class="n">num_trajectories</span><span class="si">}</span><span class="s2"> trajectories, each with </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> time steps&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time range: 0 to </span><span class="si">{</span><span class="n">T</span><span class="si">}</span><span class="s2"> seconds&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial conditions:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x0</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Trajectory </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">: x1 = </span><span class="si">{</span><span class="n">x0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">, x2 = </span><span class="si">{</span><span class="n">x0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<img alt="_images/a93d285b8d71d98170c1ae8a8bf7347f9bce592aa9ec2e7598d2910c3e5348cf.png" src="_images/a93d285b8d71d98170c1ae8a8bf7347f9bce592aa9ec2e7598d2910c3e5348cf.png" />
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Data collection complete. Results saved to &#39;compressor_surge_data_multi.npz&#39;
Data shape: 10 trajectories, each with 501 time steps
Time range: 0 to 50 seconds
Initial conditions:
  Trajectory 1: x1 = 0.5666, x2 = 0.5156
  Trajectory 2: x1 = 0.4635, x2 = 0.5140
  Trajectory 3: x1 = 0.4910, x2 = 0.4868
  Trajectory 4: x1 = 0.4960, x2 = 0.4644
  Trajectory 5: x1 = 0.5204, x2 = 0.4377
  Trajectory 6: x1 = 0.5059, x2 = 0.5009
  Trajectory 7: x1 = 0.5240, x2 = 0.4812
  Trajectory 8: x1 = 0.5535, x2 = 0.4836
  Trajectory 9: x1 = 0.5365, x2 = 0.4542
  Trajectory 10: x1 = 0.4427, x2 = 0.5510
</pre></div>
</div>
</div>
</div>
<div class="cell tag_hide-input docutils container">
<details class="hide above-input">
<summary aria-label="Toggle hidden content">
<span class="collapsed">Show code cell source</span>
<span class="expanded">Hide code cell source</span>
</summary>
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Load the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;_static/compressor_surge_data_multi.npz&#39;</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">]</span>
<span class="n">trajectories</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;trajectories&#39;</span><span class="p">]</span>
<span class="n">u</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;u&#39;</span><span class="p">]</span>
<span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;initial_conditions&#39;</span><span class="p">]</span>

<span class="c1"># Known system parameters</span>
<span class="n">gamma</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">psi_c0</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.18</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.25</span>
<span class="c1"># B is the parameter we want to identify</span>
<span class="n">B_true</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># True value, used for comparison</span>

<span class="k">def</span><span class="w"> </span><span class="nf">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">psi_c0</span> <span class="o">+</span> <span class="n">H</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">((</span><span class="n">x1</span> <span class="o">/</span> <span class="n">W</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

<span class="k">def</span><span class="w"> </span><span class="nf">system_dynamics</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">dx1dt</span> <span class="o">=</span> <span class="n">B</span> <span class="o">*</span> <span class="p">(</span><span class="n">psi_e</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x2</span> <span class="o">-</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">dx2dt</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">B</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">phi</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dx1dt</span><span class="p">,</span> <span class="n">dx2dt</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">rk4_step</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">k1</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k2</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k3</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="o">*</span><span class="n">k2</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="n">k4</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span> <span class="o">+</span> <span class="n">dt</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">dt</span><span class="o">*</span><span class="n">k3</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">dt</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">k3</span> <span class="o">+</span> <span class="n">k4</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">simulate_trajectory</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)):</span>
        <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rk4_step</span><span class="p">(</span><span class="n">system_dynamics</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">objective</span><span class="p">(</span><span class="n">B</span><span class="p">):</span>
    <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">trajectories</span><span class="p">):</span>
        <span class="n">x_sim</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">error</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1_obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x2_obs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">error</span>

<span class="c1"># Perform optimization</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="n">objective</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="p">[</span><span class="mf">1.5</span><span class="p">],</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">})</span>

<span class="n">B_identified</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;True B: </span><span class="si">{</span><span class="n">B_true</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Identified B: </span><span class="si">{</span><span class="n">B_identified</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Relative error: </span><span class="si">{</span><span class="nb">abs</span><span class="p">(</span><span class="n">B_identified</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">B_true</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">B_true</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="c1"># Plot one trajectory for comparison</span>
<span class="n">traj_index</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span> <span class="o">=</span> <span class="n">trajectories</span><span class="p">[</span><span class="n">traj_index</span><span class="p">]</span>
<span class="n">x_sim</span> <span class="o">=</span> <span class="n">simulate_trajectory</span><span class="p">(</span><span class="n">initial_conditions</span><span class="p">[</span><span class="n">traj_index</span><span class="p">],</span> <span class="n">B_identified</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x1_obs</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed x1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed x2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated x1&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated x2&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;State variables&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Observed vs Simulated Trajectory&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x1_obs</span><span class="p">,</span> <span class="n">x2_obs</span><span class="p">,</span> <span class="s1">&#39;g-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Observed&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">x_sim</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;m--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;x1 (mass flow)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;x2 (pressure)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Phase Portrait: Observed vs Simulated&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
</details>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Optimization terminated successfully.
         Current function value: 6.028195
         Iterations: 15
         Function evaluations: 30
True B: 1.0
Identified B: 0.9832763671874989
Relative error: 1.67%
</pre></div>
</div>
<img alt="_images/80fb2a9d5277eccf9900506a39095dd77ac8aa5d73e6868aa0e106a639d1ad53.png" src="_images/80fb2a9d5277eccf9900506a39095dd77ac8aa5d73e6868aa0e106a639d1ad53.png" />
</div>
</div>
<!-- ## Parameterization of $f$ and Neural ODEs
In our compressor surge problem, we were provided with a physically-motivated form for the function $f$. This set of equations was likely derived by scientists with deep knowledge of the physical phenomena at play (i.e., gas compression). However, in complex systems, the underlying physics might not be well understood or too complicated to model explicitly. In such cases, we might opt for a more flexible, data-driven approach.

Instead of specifying a fixed structure for $f$, we could use a "black box" model such as a neural network to learn the dynamics directly from data. 
The optimization problem remains conceptually the same as that of parameter identification. However, we are now optimizing over the parameters of the neural network that defines $f$.

Another possibility is to blend the two approaches and use a grey-box model. In this approach, we typically use a physics-informed parameterization which we then supplement with a black-box model to account for the discrepancies in the observations. Mathematically, this can be expressed as:

$$
\dot{\mathbf{x}}(t) = f_{\text{physics}}(\mathbf{x}, t; \boldsymbol{\theta}_{\text{physics}}) + f_{\text{NN}}(\mathbf{x}, t; \boldsymbol{\theta}_{\text{NN}})
$$

where $f_{\text{physics}}$ is the physics-based model with parameters $\boldsymbol{\theta}_{\text{physics}}$, and $f_{\text{NN}}$ is a neural network with parameters $\boldsymbol{\theta}_{\text{NN}}$ that captures unmodeled dynamics.

We then learn the parameters of the black-box model in tandem with the output of the given physics-based model. You can think of the combination of these two models as a neural network of its own, with the key difference being that one subnetwork (the physics-based one) has frozen weights (non-adjustable parameters).

This approach is easy to implement using automatic differentiation techniques and allows us to leverage prior knowledge to make the data-driven modelling more sample efficient. From a learning perspective, it amounts to providing inductive biases to make learning more efficient and to generalize better.  --></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="ocp.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Discrete-Time Trajectory Optimization</p>
      </div>
    </a>
    <a class="right-next"
       href="mpc.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">From Trajectories to Policies</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">Trajectory Optimization in Continuous Time</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#direct-transcription-methods">Direct Transcription Methods</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#discretizing-cost-and-dynamics-together">Discretizing cost and dynamics together</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#how-do-values-at-interior-points-arise-step-functions-vs-interpolating-functions">How do values at interior points arise? (step functions vs interpolating functions)</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#step-function-based-construction-piecewise-constants-rectangle-or-midpoint">Step-function based construction (piecewise constants; rectangle or midpoint)</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-function-based-construction-low-order-polynomials-trapezoid-simpson-gauss-radau-lobatto">Interpolating-function based construction (low-order polynomials; trapezoid, Simpson, Gauss/Radau/Lobatto)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#the-interpolation-problem-functions-from-constraints">The Interpolation Problem: Functions from Constraints</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#how-many-coefficients-do-we-need">How Many Coefficients Do We Need?</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solving-for-the-coefficients-monomial-basis">Solving for the Coefficients (Monomial Basis)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-a-different-basis">Using a Different Basis</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#derivative-constraints">Derivative Constraints</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#interpolating-ode-trajectories-collocation">Interpolating ODE trajectories (collocation)</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-recipe-concrete-transcriptions">Applying the recipe: concrete transcriptions</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#choosing-among-them">Choosing among them</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-brief-note-on-reconstruction">A brief note on reconstruction</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#example-compressor-surge-problem">Example: Compressor Surge Problem</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#solution-by-trapezoidal-collocation">Solution by Trapezoidal Collocation</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#system-identification-as-trajectory-optimization-compressor-surge">System Identification as Trajectory Optimization (Compressor Surge)</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Pierre-Luc Bacon
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>